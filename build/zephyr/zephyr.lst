
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

0000c200 <_vector_start>:
    c200:	20000d68 	.word	0x20000d68
    c204:	0000da5d 	.word	0x0000da5d
    c208:	00010561 	.word	0x00010561
    c20c:	0000dabd 	.word	0x0000dabd
    c210:	0000dabd 	.word	0x0000dabd
    c214:	0000dabd 	.word	0x0000dabd
    c218:	0000dabd 	.word	0x0000dabd
    c21c:	0000dabd 	.word	0x0000dabd
	...
    c22c:	0000d8a1 	.word	0x0000d8a1
    c230:	0000dabd 	.word	0x0000dabd
    c234:	00000000 	.word	0x00000000
    c238:	0000d849 	.word	0x0000d849
    c23c:	00010539 	.word	0x00010539

0000c240 <_irq_vector_table>:
    c240:	0000da1d 0000da1d 0000da1d 0000da1d     ................
    c250:	0000da1d 0000da1d 0000da1d 0000da1d     ................
    c260:	0000da1d 0000da1d 0000da1d 0000da1d     ................
    c270:	0000da1d 0000da1d 0000da1d 0000da1d     ................
    c280:	0000da1d 0000da1d 0000da1d 0000da1d     ................
    c290:	0000da1d 0000da1d 0000da1d 0000da1d     ................
    c2a0:	0000da1d 0000da1d 0000da1d 0000da1d     ................
    c2b0:	0000da1d 0000da1d 0000da1d 0000da1d     ................
    c2c0:	0000da1d 0000da1d 0000da1d 0000da1d     ................
    c2d0:	0000da1d 0000da1d 0000da1d 0000da1d     ................
    c2e0:	0000da1d 0000da1d 0000da1d 0000da1d     ................
    c2f0:	0000da1d 0000da1d 0000da1d 0000da1d     ................
    c300:	0000da1d 0000da1d 0000da1d 0000da1d     ................
    c310:	0000da1d 0000da1d 0000da1d 0000da1d     ................
    c320:	0000da1d 0000da1d 0000da1d 0000da1d     ................
    c330:	0000da1d 0000da1d 0000da1d 0000da1d     ................
    c340:	0000da1d 0000da1d 0000da1d 0000da1d     ................
    c350:	0000da1d                                ....

Disassembly of section text:

0000c354 <__aeabi_uldivmod>:
    c354:	b953      	cbnz	r3, c36c <__aeabi_uldivmod+0x18>
    c356:	b94a      	cbnz	r2, c36c <__aeabi_uldivmod+0x18>
    c358:	2900      	cmp	r1, #0
    c35a:	bf08      	it	eq
    c35c:	2800      	cmpeq	r0, #0
    c35e:	bf1c      	itt	ne
    c360:	f04f 31ff 	movne.w	r1, #4294967295
    c364:	f04f 30ff 	movne.w	r0, #4294967295
    c368:	f000 b970 	b.w	c64c <__aeabi_idiv0>
    c36c:	f1ad 0c08 	sub.w	ip, sp, #8
    c370:	e96d ce04 	strd	ip, lr, [sp, #-16]!
    c374:	f000 f806 	bl	c384 <__udivmoddi4>
    c378:	f8dd e004 	ldr.w	lr, [sp, #4]
    c37c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    c380:	b004      	add	sp, #16
    c382:	4770      	bx	lr

0000c384 <__udivmoddi4>:
    c384:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    c388:	9e08      	ldr	r6, [sp, #32]
    c38a:	460d      	mov	r5, r1
    c38c:	4604      	mov	r4, r0
    c38e:	468a      	mov	sl, r1
    c390:	2b00      	cmp	r3, #0
    c392:	d17f      	bne.n	c494 <__udivmoddi4+0x110>
    c394:	428a      	cmp	r2, r1
    c396:	4617      	mov	r7, r2
    c398:	d941      	bls.n	c41e <__udivmoddi4+0x9a>
    c39a:	fab2 f282 	clz	r2, r2
    c39e:	b14a      	cbz	r2, c3b4 <__udivmoddi4+0x30>
    c3a0:	f1c2 0120 	rsb	r1, r2, #32
    c3a4:	fa05 f302 	lsl.w	r3, r5, r2
    c3a8:	4097      	lsls	r7, r2
    c3aa:	4094      	lsls	r4, r2
    c3ac:	fa20 f101 	lsr.w	r1, r0, r1
    c3b0:	ea41 0a03 	orr.w	sl, r1, r3
    c3b4:	ea4f 4817 	mov.w	r8, r7, lsr #16
    c3b8:	ea4f 4c14 	mov.w	ip, r4, lsr #16
    c3bc:	fa1f f987 	uxth.w	r9, r7
    c3c0:	fbba fef8 	udiv	lr, sl, r8
    c3c4:	fb08 a31e 	mls	r3, r8, lr, sl
    c3c8:	fb0e f109 	mul.w	r1, lr, r9
    c3cc:	ea4c 4303 	orr.w	r3, ip, r3, lsl #16
    c3d0:	4299      	cmp	r1, r3
    c3d2:	d906      	bls.n	c3e2 <__udivmoddi4+0x5e>
    c3d4:	18fb      	adds	r3, r7, r3
    c3d6:	d202      	bcs.n	c3de <__udivmoddi4+0x5a>
    c3d8:	4299      	cmp	r1, r3
    c3da:	f200 8124 	bhi.w	c626 <__udivmoddi4+0x2a2>
    c3de:	f10e 3eff 	add.w	lr, lr, #4294967295
    c3e2:	1a59      	subs	r1, r3, r1
    c3e4:	b2a3      	uxth	r3, r4
    c3e6:	fbb1 f0f8 	udiv	r0, r1, r8
    c3ea:	fb08 1110 	mls	r1, r8, r0, r1
    c3ee:	fb00 f909 	mul.w	r9, r0, r9
    c3f2:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
    c3f6:	45a1      	cmp	r9, r4
    c3f8:	d905      	bls.n	c406 <__udivmoddi4+0x82>
    c3fa:	193c      	adds	r4, r7, r4
    c3fc:	d202      	bcs.n	c404 <__udivmoddi4+0x80>
    c3fe:	45a1      	cmp	r9, r4
    c400:	f200 810e 	bhi.w	c620 <__udivmoddi4+0x29c>
    c404:	3801      	subs	r0, #1
    c406:	eba4 0409 	sub.w	r4, r4, r9
    c40a:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
    c40e:	2100      	movs	r1, #0
    c410:	b11e      	cbz	r6, c41a <__udivmoddi4+0x96>
    c412:	40d4      	lsrs	r4, r2
    c414:	2300      	movs	r3, #0
    c416:	e9c6 4300 	strd	r4, r3, [r6]
    c41a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    c41e:	b902      	cbnz	r2, c422 <__udivmoddi4+0x9e>
    c420:	deff      	udf	#255	; 0xff
    c422:	fab2 f282 	clz	r2, r2
    c426:	2a00      	cmp	r2, #0
    c428:	d14f      	bne.n	c4ca <__udivmoddi4+0x146>
    c42a:	1bcb      	subs	r3, r1, r7
    c42c:	ea4f 4e17 	mov.w	lr, r7, lsr #16
    c430:	fa1f f887 	uxth.w	r8, r7
    c434:	2101      	movs	r1, #1
    c436:	0c25      	lsrs	r5, r4, #16
    c438:	fbb3 fcfe 	udiv	ip, r3, lr
    c43c:	fb0e 301c 	mls	r0, lr, ip, r3
    c440:	462b      	mov	r3, r5
    c442:	fb08 f90c 	mul.w	r9, r8, ip
    c446:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
    c44a:	45a9      	cmp	r9, r5
    c44c:	d90a      	bls.n	c464 <__udivmoddi4+0xe0>
    c44e:	197d      	adds	r5, r7, r5
    c450:	bf2c      	ite	cs
    c452:	2301      	movcs	r3, #1
    c454:	2300      	movcc	r3, #0
    c456:	45a9      	cmp	r9, r5
    c458:	d902      	bls.n	c460 <__udivmoddi4+0xdc>
    c45a:	2b00      	cmp	r3, #0
    c45c:	f000 80d9 	beq.w	c612 <__udivmoddi4+0x28e>
    c460:	f10c 3cff 	add.w	ip, ip, #4294967295
    c464:	eba5 0509 	sub.w	r5, r5, r9
    c468:	b2a3      	uxth	r3, r4
    c46a:	fbb5 f0fe 	udiv	r0, r5, lr
    c46e:	fb0e 5510 	mls	r5, lr, r0, r5
    c472:	fb08 f800 	mul.w	r8, r8, r0
    c476:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
    c47a:	45a0      	cmp	r8, r4
    c47c:	d905      	bls.n	c48a <__udivmoddi4+0x106>
    c47e:	193c      	adds	r4, r7, r4
    c480:	d202      	bcs.n	c488 <__udivmoddi4+0x104>
    c482:	45a0      	cmp	r8, r4
    c484:	f200 80c9 	bhi.w	c61a <__udivmoddi4+0x296>
    c488:	3801      	subs	r0, #1
    c48a:	eba4 0408 	sub.w	r4, r4, r8
    c48e:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
    c492:	e7bd      	b.n	c410 <__udivmoddi4+0x8c>
    c494:	428b      	cmp	r3, r1
    c496:	d908      	bls.n	c4aa <__udivmoddi4+0x126>
    c498:	2e00      	cmp	r6, #0
    c49a:	f000 80b1 	beq.w	c600 <__udivmoddi4+0x27c>
    c49e:	2100      	movs	r1, #0
    c4a0:	e9c6 0500 	strd	r0, r5, [r6]
    c4a4:	4608      	mov	r0, r1
    c4a6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    c4aa:	fab3 f183 	clz	r1, r3
    c4ae:	2900      	cmp	r1, #0
    c4b0:	d146      	bne.n	c540 <__udivmoddi4+0x1bc>
    c4b2:	42ab      	cmp	r3, r5
    c4b4:	f0c0 80a7 	bcc.w	c606 <__udivmoddi4+0x282>
    c4b8:	4282      	cmp	r2, r0
    c4ba:	f240 80a4 	bls.w	c606 <__udivmoddi4+0x282>
    c4be:	4608      	mov	r0, r1
    c4c0:	2e00      	cmp	r6, #0
    c4c2:	d0aa      	beq.n	c41a <__udivmoddi4+0x96>
    c4c4:	e9c6 4a00 	strd	r4, sl, [r6]
    c4c8:	e7a7      	b.n	c41a <__udivmoddi4+0x96>
    c4ca:	f1c2 0020 	rsb	r0, r2, #32
    c4ce:	4097      	lsls	r7, r2
    c4d0:	fa01 f302 	lsl.w	r3, r1, r2
    c4d4:	ea4f 4e17 	mov.w	lr, r7, lsr #16
    c4d8:	40c1      	lsrs	r1, r0
    c4da:	fa24 f500 	lsr.w	r5, r4, r0
    c4de:	fa1f f887 	uxth.w	r8, r7
    c4e2:	4094      	lsls	r4, r2
    c4e4:	431d      	orrs	r5, r3
    c4e6:	fbb1 f0fe 	udiv	r0, r1, lr
    c4ea:	0c2b      	lsrs	r3, r5, #16
    c4ec:	fb0e 1110 	mls	r1, lr, r0, r1
    c4f0:	fb00 fc08 	mul.w	ip, r0, r8
    c4f4:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
    c4f8:	459c      	cmp	ip, r3
    c4fa:	d909      	bls.n	c510 <__udivmoddi4+0x18c>
    c4fc:	18fb      	adds	r3, r7, r3
    c4fe:	bf2c      	ite	cs
    c500:	2101      	movcs	r1, #1
    c502:	2100      	movcc	r1, #0
    c504:	459c      	cmp	ip, r3
    c506:	d902      	bls.n	c50e <__udivmoddi4+0x18a>
    c508:	2900      	cmp	r1, #0
    c50a:	f000 8095 	beq.w	c638 <__udivmoddi4+0x2b4>
    c50e:	3801      	subs	r0, #1
    c510:	eba3 030c 	sub.w	r3, r3, ip
    c514:	b2ad      	uxth	r5, r5
    c516:	fbb3 f1fe 	udiv	r1, r3, lr
    c51a:	fb0e 3311 	mls	r3, lr, r1, r3
    c51e:	fb01 fc08 	mul.w	ip, r1, r8
    c522:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
    c526:	45ac      	cmp	ip, r5
    c528:	d905      	bls.n	c536 <__udivmoddi4+0x1b2>
    c52a:	197d      	adds	r5, r7, r5
    c52c:	d202      	bcs.n	c534 <__udivmoddi4+0x1b0>
    c52e:	45ac      	cmp	ip, r5
    c530:	f200 8089 	bhi.w	c646 <__udivmoddi4+0x2c2>
    c534:	3901      	subs	r1, #1
    c536:	eba5 030c 	sub.w	r3, r5, ip
    c53a:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
    c53e:	e77a      	b.n	c436 <__udivmoddi4+0xb2>
    c540:	f1c1 0420 	rsb	r4, r1, #32
    c544:	408b      	lsls	r3, r1
    c546:	fa02 f701 	lsl.w	r7, r2, r1
    c54a:	fa05 fc01 	lsl.w	ip, r5, r1
    c54e:	40e2      	lsrs	r2, r4
    c550:	fa20 f804 	lsr.w	r8, r0, r4
    c554:	40e5      	lsrs	r5, r4
    c556:	fa00 fe01 	lsl.w	lr, r0, r1
    c55a:	4313      	orrs	r3, r2
    c55c:	ea48 020c 	orr.w	r2, r8, ip
    c560:	ea4f 4813 	mov.w	r8, r3, lsr #16
    c564:	ea4f 4c12 	mov.w	ip, r2, lsr #16
    c568:	fa1f f983 	uxth.w	r9, r3
    c56c:	fbb5 faf8 	udiv	sl, r5, r8
    c570:	fb08 551a 	mls	r5, r8, sl, r5
    c574:	fb0a f009 	mul.w	r0, sl, r9
    c578:	ea4c 4c05 	orr.w	ip, ip, r5, lsl #16
    c57c:	4560      	cmp	r0, ip
    c57e:	d90a      	bls.n	c596 <__udivmoddi4+0x212>
    c580:	eb13 0c0c 	adds.w	ip, r3, ip
    c584:	bf2c      	ite	cs
    c586:	2501      	movcs	r5, #1
    c588:	2500      	movcc	r5, #0
    c58a:	4560      	cmp	r0, ip
    c58c:	d901      	bls.n	c592 <__udivmoddi4+0x20e>
    c58e:	2d00      	cmp	r5, #0
    c590:	d055      	beq.n	c63e <__udivmoddi4+0x2ba>
    c592:	f10a 3aff 	add.w	sl, sl, #4294967295
    c596:	ebac 0c00 	sub.w	ip, ip, r0
    c59a:	b292      	uxth	r2, r2
    c59c:	fbbc f0f8 	udiv	r0, ip, r8
    c5a0:	fb08 cc10 	mls	ip, r8, r0, ip
    c5a4:	fb00 f909 	mul.w	r9, r0, r9
    c5a8:	ea42 4c0c 	orr.w	ip, r2, ip, lsl #16
    c5ac:	45e1      	cmp	r9, ip
    c5ae:	d905      	bls.n	c5bc <__udivmoddi4+0x238>
    c5b0:	eb13 0c0c 	adds.w	ip, r3, ip
    c5b4:	d201      	bcs.n	c5ba <__udivmoddi4+0x236>
    c5b6:	45e1      	cmp	r9, ip
    c5b8:	d83b      	bhi.n	c632 <__udivmoddi4+0x2ae>
    c5ba:	3801      	subs	r0, #1
    c5bc:	ea40 400a 	orr.w	r0, r0, sl, lsl #16
    c5c0:	ebac 0c09 	sub.w	ip, ip, r9
    c5c4:	fba0 8907 	umull	r8, r9, r0, r7
    c5c8:	45cc      	cmp	ip, r9
    c5ca:	4645      	mov	r5, r8
    c5cc:	464a      	mov	r2, r9
    c5ce:	d302      	bcc.n	c5d6 <__udivmoddi4+0x252>
    c5d0:	d106      	bne.n	c5e0 <__udivmoddi4+0x25c>
    c5d2:	45c6      	cmp	lr, r8
    c5d4:	d204      	bcs.n	c5e0 <__udivmoddi4+0x25c>
    c5d6:	3801      	subs	r0, #1
    c5d8:	ebb8 0507 	subs.w	r5, r8, r7
    c5dc:	eb69 0203 	sbc.w	r2, r9, r3
    c5e0:	b32e      	cbz	r6, c62e <__udivmoddi4+0x2aa>
    c5e2:	ebbe 0305 	subs.w	r3, lr, r5
    c5e6:	eb6c 0c02 	sbc.w	ip, ip, r2
    c5ea:	fa23 f201 	lsr.w	r2, r3, r1
    c5ee:	fa0c f404 	lsl.w	r4, ip, r4
    c5f2:	fa2c f301 	lsr.w	r3, ip, r1
    c5f6:	2100      	movs	r1, #0
    c5f8:	4314      	orrs	r4, r2
    c5fa:	e9c6 4300 	strd	r4, r3, [r6]
    c5fe:	e70c      	b.n	c41a <__udivmoddi4+0x96>
    c600:	4631      	mov	r1, r6
    c602:	4630      	mov	r0, r6
    c604:	e709      	b.n	c41a <__udivmoddi4+0x96>
    c606:	1a84      	subs	r4, r0, r2
    c608:	eb65 0303 	sbc.w	r3, r5, r3
    c60c:	2001      	movs	r0, #1
    c60e:	469a      	mov	sl, r3
    c610:	e756      	b.n	c4c0 <__udivmoddi4+0x13c>
    c612:	f1ac 0c02 	sub.w	ip, ip, #2
    c616:	443d      	add	r5, r7
    c618:	e724      	b.n	c464 <__udivmoddi4+0xe0>
    c61a:	3802      	subs	r0, #2
    c61c:	443c      	add	r4, r7
    c61e:	e734      	b.n	c48a <__udivmoddi4+0x106>
    c620:	3802      	subs	r0, #2
    c622:	443c      	add	r4, r7
    c624:	e6ef      	b.n	c406 <__udivmoddi4+0x82>
    c626:	f1ae 0e02 	sub.w	lr, lr, #2
    c62a:	443b      	add	r3, r7
    c62c:	e6d9      	b.n	c3e2 <__udivmoddi4+0x5e>
    c62e:	4631      	mov	r1, r6
    c630:	e6f3      	b.n	c41a <__udivmoddi4+0x96>
    c632:	3802      	subs	r0, #2
    c634:	449c      	add	ip, r3
    c636:	e7c1      	b.n	c5bc <__udivmoddi4+0x238>
    c638:	3802      	subs	r0, #2
    c63a:	443b      	add	r3, r7
    c63c:	e768      	b.n	c510 <__udivmoddi4+0x18c>
    c63e:	f1aa 0a02 	sub.w	sl, sl, #2
    c642:	449c      	add	ip, r3
    c644:	e7a7      	b.n	c596 <__udivmoddi4+0x212>
    c646:	3902      	subs	r1, #2
    c648:	443d      	add	r5, r7
    c64a:	e774      	b.n	c536 <__udivmoddi4+0x1b2>

0000c64c <__aeabi_idiv0>:
    c64c:	4770      	bx	lr
    c64e:	bf00      	nop

0000c650 <main>:
#include <zephyr.h>
#include <sys/printk.h>

void main(void)
{
	printk("Hello World! %s\n", CONFIG_BOARD);
    c650:	4901      	ldr	r1, [pc, #4]	; (c658 <main+0x8>)
    c652:	4802      	ldr	r0, [pc, #8]	; (c65c <main+0xc>)
    c654:	f003 bcce 	b.w	fff4 <printk>
    c658:	00010f94 	.word	0x00010f94
    c65c:	00010fad 	.word	0x00010fad

0000c660 <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
    c660:	680b      	ldr	r3, [r1, #0]
    c662:	3301      	adds	r3, #1
    c664:	600b      	str	r3, [r1, #0]
	return _char_out(c);
    c666:	4b01      	ldr	r3, [pc, #4]	; (c66c <char_out+0xc>)
    c668:	681b      	ldr	r3, [r3, #0]
    c66a:	4718      	bx	r3
    c66c:	20000000 	.word	0x20000000

0000c670 <__printk_hook_install>:
	_char_out = fn;
    c670:	4b01      	ldr	r3, [pc, #4]	; (c678 <__printk_hook_install+0x8>)
    c672:	6018      	str	r0, [r3, #0]
}
    c674:	4770      	bx	lr
    c676:	bf00      	nop
    c678:	20000000 	.word	0x20000000

0000c67c <vprintk>:
#endif
	}
}
#else
void vprintk(const char *fmt, va_list ap)
{
    c67c:	b507      	push	{r0, r1, r2, lr}
    c67e:	460b      	mov	r3, r1
	struct out_context ctx = { 0 };
    c680:	2100      	movs	r1, #0
{
    c682:	4602      	mov	r2, r0
	struct out_context ctx = { 0 };
    c684:	9101      	str	r1, [sp, #4]
#ifdef CONFIG_PRINTK_SYNC
	k_spinlock_key_t key = k_spin_lock(&lock);
#endif

	cbvprintf(char_out, &ctx, fmt, ap);
    c686:	4803      	ldr	r0, [pc, #12]	; (c694 <vprintk+0x18>)
    c688:	a901      	add	r1, sp, #4
    c68a:	f000 f8eb 	bl	c864 <cbvprintf>

#ifdef CONFIG_PRINTK_SYNC
	k_spin_unlock(&lock, key);
#endif
}
    c68e:	b003      	add	sp, #12
    c690:	f85d fb04 	ldr.w	pc, [sp], #4
    c694:	0000c661 	.word	0x0000c661

0000c698 <process_event>:
 * regions.
 */
static void process_event(struct onoff_manager *mgr,
			  int evt,
			  k_spinlock_key_t key)
{
    c698:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	sys_slist_t clients;
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    c69c:	f8b0 9018 	ldrh.w	r9, [r0, #24]
{
    c6a0:	4604      	mov	r4, r0
	__ASSERT_NO_MSG(evt != EVT_NOP);

	/* If this is a nested call record the event for processing in
	 * the top invocation.
	 */
	if (processing) {
    c6a2:	f019 0808 	ands.w	r8, r9, #8
{
    c6a6:	4693      	mov	fp, r2
	if (processing) {
    c6a8:	d00d      	beq.n	c6c6 <process_event+0x2e>
		if (evt == EVT_COMPLETE) {
    c6aa:	2901      	cmp	r1, #1
			mgr->flags |= ONOFF_FLAG_COMPLETE;
    c6ac:	bf0c      	ite	eq
    c6ae:	f049 0910 	orreq.w	r9, r9, #16
		} else {
			__ASSERT_NO_MSG(evt == EVT_RECHECK);

			mgr->flags |= ONOFF_FLAG_RECHECK;
    c6b2:	f049 0920 	orrne.w	r9, r9, #32
    c6b6:	f8a0 9018 	strh.w	r9, [r0, #24]
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
    c6ba:	f38b 8811 	msr	BASEPRI, fp
    c6be:	f3bf 8f6f 	isb	sy
		state = mgr->flags & ONOFF_STATE_MASK;
	} while (evt != EVT_NOP);

out:
	k_spin_unlock(&mgr->lock, key);
}
    c6c2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    c6c6:	f009 0907 	and.w	r9, r9, #7
		if (evt == EVT_RECHECK) {
    c6ca:	2902      	cmp	r1, #2
    c6cc:	d107      	bne.n	c6de <process_event+0x46>
			evt = process_recheck(mgr);
    c6ce:	4620      	mov	r0, r4
    c6d0:	f003 fc9d 	bl	1000e <process_recheck>
		if (evt == EVT_NOP) {
    c6d4:	2800      	cmp	r0, #0
    c6d6:	d0f0      	beq.n	c6ba <process_event+0x22>
		if (evt == EVT_COMPLETE) {
    c6d8:	2801      	cmp	r0, #1
    c6da:	8b23      	ldrh	r3, [r4, #24]
    c6dc:	d150      	bne.n	c780 <process_event+0xe8>
			res = mgr->last_res;
    c6de:	6967      	ldr	r7, [r4, #20]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    c6e0:	8b21      	ldrh	r1, [r4, #24]
	if (res < 0) {
    c6e2:	2f00      	cmp	r7, #0
    c6e4:	da15      	bge.n	c712 <process_event+0x7a>
		*clients = mgr->clients;
    c6e6:	6825      	ldr	r5, [r4, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    c6e8:	f021 0107 	bic.w	r1, r1, #7
 * @param list A pointer on the list to initialize
 */
static inline void sys_slist_init(sys_slist_t *list)
{
	list->head = NULL;
	list->tail = NULL;
    c6ec:	e9c4 8800 	strd	r8, r8, [r4]
    c6f0:	f041 0101 	orr.w	r1, r1, #1
	mgr->flags = (state & ONOFF_STATE_MASK)
    c6f4:	8321      	strh	r1, [r4, #24]
		onoff_transition_fn transit = NULL;
    c6f6:	2600      	movs	r6, #0
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
    c6f8:	8b21      	ldrh	r1, [r4, #24]
    c6fa:	f001 0a07 	and.w	sl, r1, #7
				   && !sys_slist_is_empty(&mgr->monitors);
    c6fe:	45ca      	cmp	sl, r9
    c700:	d002      	beq.n	c708 <process_event+0x70>
		if (do_monitors
    c702:	68a3      	ldr	r3, [r4, #8]
    c704:	2b00      	cmp	r3, #0
    c706:	d15c      	bne.n	c7c2 <process_event+0x12a>
		    || !sys_slist_is_empty(&clients)
    c708:	b90d      	cbnz	r5, c70e <process_event+0x76>
		    || (transit != NULL)) {
    c70a:	2e00      	cmp	r6, #0
    c70c:	d074      	beq.n	c7f8 <process_event+0x160>
    c70e:	2300      	movs	r3, #0
    c710:	e058      	b.n	c7c4 <process_event+0x12c>
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    c712:	f001 0307 	and.w	r3, r1, #7
		   || (state == ONOFF_STATE_RESETTING)) {
    c716:	1f5a      	subs	r2, r3, #5
	} else if ((state == ONOFF_STATE_TO_ON)
    c718:	2a01      	cmp	r2, #1
    c71a:	d820      	bhi.n	c75e <process_event+0xc6>
		*clients = mgr->clients;
    c71c:	f021 0107 	bic.w	r1, r1, #7
		if (state == ONOFF_STATE_TO_ON) {
    c720:	2b06      	cmp	r3, #6
		*clients = mgr->clients;
    c722:	6825      	ldr	r5, [r4, #0]
	list->head = NULL;
    c724:	b289      	uxth	r1, r1
	list->tail = NULL;
    c726:	e9c4 8800 	strd	r8, r8, [r4]
		if (state == ONOFF_STATE_TO_ON) {
    c72a:	d10c      	bne.n	c746 <process_event+0xae>
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
    c72c:	2d00      	cmp	r5, #0
    c72e:	462b      	mov	r3, r5
    c730:	bf38      	it	cc
    c732:	2300      	movcc	r3, #0
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
    c734:	b12b      	cbz	r3, c742 <process_event+0xaa>
				mgr->refs += 1U;
    c736:	8b62      	ldrh	r2, [r4, #26]
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next_no_check(sys_snode_t *node);

Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    c738:	681b      	ldr	r3, [r3, #0]
    c73a:	3201      	adds	r2, #1
    c73c:	8362      	strh	r2, [r4, #26]
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
    c73e:	2b00      	cmp	r3, #0
    c740:	d1f8      	bne.n	c734 <process_event+0x9c>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    c742:	f041 0102 	orr.w	r1, r1, #2
		if (process_recheck(mgr) != EVT_NOP) {
    c746:	4620      	mov	r0, r4
	mgr->flags = (state & ONOFF_STATE_MASK)
    c748:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
    c74a:	f003 fc60 	bl	1000e <process_recheck>
    c74e:	4606      	mov	r6, r0
    c750:	2800      	cmp	r0, #0
    c752:	d0d1      	beq.n	c6f8 <process_event+0x60>
			mgr->flags |= ONOFF_FLAG_RECHECK;
    c754:	8b23      	ldrh	r3, [r4, #24]
    c756:	f043 0320 	orr.w	r3, r3, #32
    c75a:	8323      	strh	r3, [r4, #24]
    c75c:	e7cb      	b.n	c6f6 <process_event+0x5e>
	} else if (state == ONOFF_STATE_TO_OFF) {
    c75e:	2b04      	cmp	r3, #4
    c760:	d10c      	bne.n	c77c <process_event+0xe4>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    c762:	f021 0107 	bic.w	r1, r1, #7
    c766:	b289      	uxth	r1, r1
		if (process_recheck(mgr) != EVT_NOP) {
    c768:	4620      	mov	r0, r4
	mgr->flags = (state & ONOFF_STATE_MASK)
    c76a:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
    c76c:	f003 fc4f 	bl	1000e <process_recheck>
    c770:	4605      	mov	r5, r0
    c772:	2800      	cmp	r0, #0
    c774:	d0bf      	beq.n	c6f6 <process_event+0x5e>
			mgr->flags |= ONOFF_FLAG_RECHECK;
    c776:	f041 0120 	orr.w	r1, r1, #32
    c77a:	8321      	strh	r1, [r4, #24]
    c77c:	2500      	movs	r5, #0
    c77e:	e7ba      	b.n	c6f6 <process_event+0x5e>
		} else if (evt == EVT_START) {
    c780:	2803      	cmp	r0, #3
    c782:	d109      	bne.n	c798 <process_event+0x100>
			transit = mgr->transitions->start;
    c784:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    c786:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->start;
    c78a:	6816      	ldr	r6, [r2, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    c78c:	f043 0306 	orr.w	r3, r3, #6
}
    c790:	2500      	movs	r5, #0
	mgr->flags = (state & ONOFF_STATE_MASK)
    c792:	8323      	strh	r3, [r4, #24]
		res = 0;
    c794:	462f      	mov	r7, r5
    c796:	e7af      	b.n	c6f8 <process_event+0x60>
		} else if (evt == EVT_STOP) {
    c798:	2804      	cmp	r0, #4
    c79a:	d106      	bne.n	c7aa <process_event+0x112>
			transit = mgr->transitions->stop;
    c79c:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    c79e:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->stop;
    c7a2:	6856      	ldr	r6, [r2, #4]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    c7a4:	f043 0304 	orr.w	r3, r3, #4
    c7a8:	e7f2      	b.n	c790 <process_event+0xf8>
		} else if (evt == EVT_RESET) {
    c7aa:	2805      	cmp	r0, #5
    c7ac:	d106      	bne.n	c7bc <process_event+0x124>
			transit = mgr->transitions->reset;
    c7ae:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    c7b0:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->reset;
    c7b4:	6896      	ldr	r6, [r2, #8]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
    c7b6:	f043 0305 	orr.w	r3, r3, #5
    c7ba:	e7e9      	b.n	c790 <process_event+0xf8>
    c7bc:	2500      	movs	r5, #0
		onoff_transition_fn transit = NULL;
    c7be:	462e      	mov	r6, r5
    c7c0:	e7e8      	b.n	c794 <process_event+0xfc>
				   && !sys_slist_is_empty(&mgr->monitors);
    c7c2:	2301      	movs	r3, #1
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
    c7c4:	f041 0108 	orr.w	r1, r1, #8
			mgr->flags = flags;
    c7c8:	8321      	strh	r1, [r4, #24]
    c7ca:	f38b 8811 	msr	BASEPRI, fp
    c7ce:	f3bf 8f6f 	isb	sy
			if (do_monitors) {
    c7d2:	bb03      	cbnz	r3, c816 <process_event+0x17e>
	while (!sys_slist_is_empty(list)) {
    c7d4:	2d00      	cmp	r5, #0
    c7d6:	d133      	bne.n	c840 <process_event+0x1a8>
			if (transit != NULL) {
    c7d8:	b116      	cbz	r6, c7e0 <process_event+0x148>
				transit(mgr, transition_complete);
    c7da:	4620      	mov	r0, r4
    c7dc:	4920      	ldr	r1, [pc, #128]	; (c860 <process_event+0x1c8>)
    c7de:	47b0      	blx	r6
	__asm__ volatile(
    c7e0:	f04f 0320 	mov.w	r3, #32
    c7e4:	f3ef 8b11 	mrs	fp, BASEPRI
    c7e8:	f383 8811 	msr	BASEPRI, r3
    c7ec:	f3bf 8f6f 	isb	sy
			mgr->flags &= ~ONOFF_FLAG_PROCESSING;
    c7f0:	8b23      	ldrh	r3, [r4, #24]
    c7f2:	f023 0308 	bic.w	r3, r3, #8
    c7f6:	8323      	strh	r3, [r4, #24]
		if ((mgr->flags & ONOFF_FLAG_COMPLETE) != 0) {
    c7f8:	8b23      	ldrh	r3, [r4, #24]
    c7fa:	06da      	lsls	r2, r3, #27
    c7fc:	d528      	bpl.n	c850 <process_event+0x1b8>
			evt = EVT_COMPLETE;
    c7fe:	2101      	movs	r1, #1
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
    c800:	f023 0310 	bic.w	r3, r3, #16
    c804:	8323      	strh	r3, [r4, #24]
		state = mgr->flags & ONOFF_STATE_MASK;
    c806:	f8b4 9018 	ldrh.w	r9, [r4, #24]
    c80a:	f009 0907 	and.w	r9, r9, #7
	} while (evt != EVT_NOP);
    c80e:	2900      	cmp	r1, #0
    c810:	f47f af5b 	bne.w	c6ca <process_event+0x32>
out:
    c814:	e751      	b.n	c6ba <process_event+0x22>
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
    c816:	68a1      	ldr	r1, [r4, #8]
    c818:	2900      	cmp	r1, #0
    c81a:	d0db      	beq.n	c7d4 <process_event+0x13c>
	return node->next;
    c81c:	680b      	ldr	r3, [r1, #0]
    c81e:	2b00      	cmp	r3, #0
    c820:	bf38      	it	cc
    c822:	2300      	movcc	r3, #0
    c824:	4699      	mov	r9, r3
		mon->callback(mgr, mon, state, res);
    c826:	4652      	mov	r2, sl
    c828:	463b      	mov	r3, r7
    c82a:	4620      	mov	r0, r4
    c82c:	f8d1 b004 	ldr.w	fp, [r1, #4]
    c830:	47d8      	blx	fp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
    c832:	f1b9 0f00 	cmp.w	r9, #0
    c836:	d0cd      	beq.n	c7d4 <process_event+0x13c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
    c838:	4649      	mov	r1, r9
    c83a:	f8d9 3000 	ldr.w	r3, [r9]
    c83e:	e7ee      	b.n	c81e <process_event+0x186>
 *
 * @return A pointer to the first node of the list
 */
static inline sys_snode_t *sys_slist_get_not_empty(sys_slist_t *list);

Z_GENLIST_GET_NOT_EMPTY(slist, snode)
    c840:	4629      	mov	r1, r5
		notify_one(mgr, cli, state, res);
    c842:	463b      	mov	r3, r7
    c844:	4652      	mov	r2, sl
    c846:	4620      	mov	r0, r4
    c848:	682d      	ldr	r5, [r5, #0]
    c84a:	f003 fbfc 	bl	10046 <notify_one>
    c84e:	e7c1      	b.n	c7d4 <process_event+0x13c>
		} else if ((mgr->flags & ONOFF_FLAG_RECHECK) != 0) {
    c850:	f013 0120 	ands.w	r1, r3, #32
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
    c854:	bf1e      	ittt	ne
    c856:	f023 0320 	bicne.w	r3, r3, #32
			evt = EVT_RECHECK;
    c85a:	2102      	movne	r1, #2
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
    c85c:	8323      	strhne	r3, [r4, #24]
			evt = EVT_RECHECK;
    c85e:	e7d2      	b.n	c806 <process_event+0x16e>
    c860:	00010073 	.word	0x00010073

0000c864 <cbvprintf>:

	return (int)count;
}

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
    c864:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c868:	468b      	mov	fp, r1
    c86a:	4692      	mov	sl, r2
    c86c:	461c      	mov	r4, r3
	char buf[CONVERTED_BUFLEN];
	size_t count = 0;
    c86e:	2500      	movs	r5, #0
{
    c870:	b091      	sub	sp, #68	; 0x44
    c872:	9002      	str	r0, [sp, #8]
		return rc; \
	} \
	count += rc; \
} while (false)

	while (*fp != 0) {
    c874:	f89a 0000 	ldrb.w	r0, [sl]
    c878:	b908      	cbnz	r0, c87e <cbvprintf+0x1a>
			OUTC(' ');
			--width;
		}
	}

	return count;
    c87a:	4628      	mov	r0, r5
    c87c:	e35e      	b.n	cf3c <cbvprintf+0x6d8>
		if (*fp != '%') {
    c87e:	2825      	cmp	r0, #37	; 0x25
    c880:	f10a 0701 	add.w	r7, sl, #1
    c884:	d007      	beq.n	c896 <cbvprintf+0x32>
			OUTC('%');
    c886:	4659      	mov	r1, fp
    c888:	9b02      	ldr	r3, [sp, #8]
    c88a:	4798      	blx	r3
    c88c:	2800      	cmp	r0, #0
    c88e:	f2c0 8355 	blt.w	cf3c <cbvprintf+0x6d8>
    c892:	3501      	adds	r5, #1
			break;
    c894:	e210      	b.n	ccb8 <cbvprintf+0x454>
		} state = {
    c896:	2218      	movs	r2, #24
    c898:	2100      	movs	r1, #0
    c89a:	a80a      	add	r0, sp, #40	; 0x28
    c89c:	f003 fed4 	bl	10648 <memset>
	if (*sp == '%') {
    c8a0:	f89a 3001 	ldrb.w	r3, [sl, #1]
    c8a4:	2b25      	cmp	r3, #37	; 0x25
    c8a6:	d078      	beq.n	c99a <cbvprintf+0x136>
    c8a8:	2200      	movs	r2, #0
    c8aa:	4694      	mov	ip, r2
    c8ac:	4616      	mov	r6, r2
    c8ae:	4696      	mov	lr, r2
    c8b0:	4610      	mov	r0, r2
    c8b2:	4639      	mov	r1, r7
		switch (*sp) {
    c8b4:	f817 3b01 	ldrb.w	r3, [r7], #1
    c8b8:	2b2b      	cmp	r3, #43	; 0x2b
    c8ba:	f000 809d 	beq.w	c9f8 <cbvprintf+0x194>
    c8be:	f200 8094 	bhi.w	c9ea <cbvprintf+0x186>
    c8c2:	2b20      	cmp	r3, #32
    c8c4:	f000 809b 	beq.w	c9fe <cbvprintf+0x19a>
    c8c8:	2b23      	cmp	r3, #35	; 0x23
    c8ca:	f000 809a 	beq.w	ca02 <cbvprintf+0x19e>
    c8ce:	b128      	cbz	r0, c8dc <cbvprintf+0x78>
    c8d0:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
    c8d4:	f040 0004 	orr.w	r0, r0, #4
    c8d8:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
    c8dc:	f1be 0f00 	cmp.w	lr, #0
    c8e0:	d005      	beq.n	c8ee <cbvprintf+0x8a>
    c8e2:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
    c8e6:	f040 0008 	orr.w	r0, r0, #8
    c8ea:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
    c8ee:	b12e      	cbz	r6, c8fc <cbvprintf+0x98>
    c8f0:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
    c8f4:	f040 0010 	orr.w	r0, r0, #16
    c8f8:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
    c8fc:	f1bc 0f00 	cmp.w	ip, #0
    c900:	d005      	beq.n	c90e <cbvprintf+0xaa>
    c902:	f89d 0030 	ldrb.w	r0, [sp, #48]	; 0x30
    c906:	f040 0020 	orr.w	r0, r0, #32
    c90a:	f88d 0030 	strb.w	r0, [sp, #48]	; 0x30
    c90e:	b12a      	cbz	r2, c91c <cbvprintf+0xb8>
    c910:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
    c914:	f042 0240 	orr.w	r2, r2, #64	; 0x40
    c918:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (conv->flag_zero && conv->flag_dash) {
    c91c:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
    c920:	f002 0044 	and.w	r0, r2, #68	; 0x44
    c924:	2844      	cmp	r0, #68	; 0x44
    c926:	d103      	bne.n	c930 <cbvprintf+0xcc>
		conv->flag_zero = false;
    c928:	f36f 1286 	bfc	r2, #6, #1
    c92c:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	conv->width_present = true;
    c930:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
    c934:	2b2a      	cmp	r3, #42	; 0x2a
	conv->width_present = true;
    c936:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    c93a:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	if (*sp == '*') {
    c93e:	d17b      	bne.n	ca38 <cbvprintf+0x1d4>
		conv->width_star = true;
    c940:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    c944:	1c4b      	adds	r3, r1, #1
    c946:	f042 0201 	orr.w	r2, r2, #1
    c94a:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	conv->prec_present = (*sp == '.');
    c94e:	781a      	ldrb	r2, [r3, #0]
    c950:	2a2e      	cmp	r2, #46	; 0x2e
    c952:	bf0c      	ite	eq
    c954:	2101      	moveq	r1, #1
    c956:	2100      	movne	r1, #0
    c958:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    c95c:	f361 0241 	bfi	r2, r1, #1, #1
    c960:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	if (!conv->prec_present) {
    c964:	d174      	bne.n	ca50 <cbvprintf+0x1ec>
	if (*sp == '*') {
    c966:	785a      	ldrb	r2, [r3, #1]
    c968:	2a2a      	cmp	r2, #42	; 0x2a
    c96a:	d06a      	beq.n	ca42 <cbvprintf+0x1de>
	size_t val = 0;
    c96c:	2100      	movs	r1, #0
		val = 10U * val + *sp++ - '0';
    c96e:	260a      	movs	r6, #10
    c970:	3301      	adds	r3, #1
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
    c972:	4618      	mov	r0, r3
    c974:	f810 2b01 	ldrb.w	r2, [r0], #1
    c978:	f1a2 0730 	sub.w	r7, r2, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
    c97c:	2f09      	cmp	r7, #9
    c97e:	f240 808e 	bls.w	ca9e <cbvprintf+0x23a>
	conv->unsupported |= ((conv->prec_value < 0)
    c982:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
	conv->prec_value = prec;
    c986:	910e      	str	r1, [sp, #56]	; 0x38
	conv->unsupported |= ((conv->prec_value < 0)
    c988:	f3c2 0040 	ubfx	r0, r2, #1, #1
    c98c:	ea40 71d1 	orr.w	r1, r0, r1, lsr #31
    c990:	f361 0241 	bfi	r2, r1, #1, #1
    c994:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
    c998:	e05a      	b.n	ca50 <cbvprintf+0x1ec>
		conv->specifier = *sp++;
    c99a:	f10a 0702 	add.w	r7, sl, #2
    c99e:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
		if (conv->width_star) {
    c9a2:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
    c9a6:	07d9      	lsls	r1, r3, #31
    c9a8:	f140 8149 	bpl.w	cc3e <cbvprintf+0x3da>
			width = va_arg(ap, int);
    c9ac:	f854 9b04 	ldr.w	r9, [r4], #4
			if (width < 0) {
    c9b0:	f1b9 0f00 	cmp.w	r9, #0
    c9b4:	da07      	bge.n	c9c6 <cbvprintf+0x162>
				conv->flag_dash = true;
    c9b6:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
				width = -width;
    c9ba:	f1c9 0900 	rsb	r9, r9, #0
				conv->flag_dash = true;
    c9be:	f042 0204 	orr.w	r2, r2, #4
    c9c2:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
		if (conv->prec_star) {
    c9c6:	075a      	lsls	r2, r3, #29
    c9c8:	f140 8142 	bpl.w	cc50 <cbvprintf+0x3ec>
			int arg = va_arg(ap, int);
    c9cc:	f854 8b04 	ldr.w	r8, [r4], #4
			if (arg < 0) {
    c9d0:	f1b8 0f00 	cmp.w	r8, #0
    c9d4:	f280 8141 	bge.w	cc5a <cbvprintf+0x3f6>
				conv->prec_present = false;
    c9d8:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
    c9dc:	f36f 0341 	bfc	r3, #1, #1
    c9e0:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		int precision = -1;
    c9e4:	f04f 38ff 	mov.w	r8, #4294967295
    c9e8:	e137      	b.n	cc5a <cbvprintf+0x3f6>
		switch (*sp) {
    c9ea:	2b2d      	cmp	r3, #45	; 0x2d
    c9ec:	d00c      	beq.n	ca08 <cbvprintf+0x1a4>
    c9ee:	2b30      	cmp	r3, #48	; 0x30
    c9f0:	f47f af6d 	bne.w	c8ce <cbvprintf+0x6a>
			conv->flag_zero = true;
    c9f4:	2201      	movs	r2, #1
	} while (loop);
    c9f6:	e75c      	b.n	c8b2 <cbvprintf+0x4e>
			conv->flag_plus = true;
    c9f8:	f04f 0e01 	mov.w	lr, #1
    c9fc:	e759      	b.n	c8b2 <cbvprintf+0x4e>
			conv->flag_space = true;
    c9fe:	2601      	movs	r6, #1
    ca00:	e757      	b.n	c8b2 <cbvprintf+0x4e>
			conv->flag_hash = true;
    ca02:	f04f 0c01 	mov.w	ip, #1
    ca06:	e754      	b.n	c8b2 <cbvprintf+0x4e>
		switch (*sp) {
    ca08:	2001      	movs	r0, #1
    ca0a:	e752      	b.n	c8b2 <cbvprintf+0x4e>
		val = 10U * val + *sp++ - '0';
    ca0c:	4633      	mov	r3, r6
    ca0e:	fb0c 0202 	mla	r2, ip, r2, r0
    ca12:	3a30      	subs	r2, #48	; 0x30
    ca14:	461e      	mov	r6, r3
    ca16:	f816 0b01 	ldrb.w	r0, [r6], #1
    ca1a:	f1a0 0730 	sub.w	r7, r0, #48	; 0x30
	while (isdigit((int)(unsigned char)*sp)) {
    ca1e:	2f09      	cmp	r7, #9
    ca20:	d9f4      	bls.n	ca0c <cbvprintf+0x1a8>
	if (sp != wp) {
    ca22:	4299      	cmp	r1, r3
    ca24:	d093      	beq.n	c94e <cbvprintf+0xea>
		conv->unsupported |= ((conv->width_value < 0)
    ca26:	f89d 1030 	ldrb.w	r1, [sp, #48]	; 0x30
		conv->width_value = width;
    ca2a:	920d      	str	r2, [sp, #52]	; 0x34
				      || (width != (size_t)conv->width_value));
    ca2c:	0fd2      	lsrs	r2, r2, #31
		conv->unsupported |= ((conv->width_value < 0)
    ca2e:	f362 0141 	bfi	r1, r2, #1, #1
    ca32:	f88d 1030 	strb.w	r1, [sp, #48]	; 0x30
    ca36:	e78a      	b.n	c94e <cbvprintf+0xea>
    ca38:	460b      	mov	r3, r1
	size_t val = 0;
    ca3a:	2200      	movs	r2, #0
		val = 10U * val + *sp++ - '0';
    ca3c:	f04f 0c0a 	mov.w	ip, #10
    ca40:	e7e8      	b.n	ca14 <cbvprintf+0x1b0>
		conv->prec_star = true;
    ca42:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
		return ++sp;
    ca46:	3302      	adds	r3, #2
		conv->prec_star = true;
    ca48:	f042 0204 	orr.w	r2, r2, #4
    ca4c:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
	switch (*sp) {
    ca50:	461f      	mov	r7, r3
    ca52:	f817 2b01 	ldrb.w	r2, [r7], #1
    ca56:	2a6c      	cmp	r2, #108	; 0x6c
    ca58:	d041      	beq.n	cade <cbvprintf+0x27a>
    ca5a:	d825      	bhi.n	caa8 <cbvprintf+0x244>
    ca5c:	2a68      	cmp	r2, #104	; 0x68
    ca5e:	d02b      	beq.n	cab8 <cbvprintf+0x254>
    ca60:	2a6a      	cmp	r2, #106	; 0x6a
    ca62:	d046      	beq.n	caf2 <cbvprintf+0x28e>
    ca64:	2a4c      	cmp	r2, #76	; 0x4c
    ca66:	d04c      	beq.n	cb02 <cbvprintf+0x29e>
    ca68:	461f      	mov	r7, r3
	conv->specifier = *sp++;
    ca6a:	f817 2b01 	ldrb.w	r2, [r7], #1
    ca6e:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
	switch (conv->specifier) {
    ca72:	2a78      	cmp	r2, #120	; 0x78
	conv->specifier = *sp++;
    ca74:	f88d 2033 	strb.w	r2, [sp, #51]	; 0x33
	switch (conv->specifier) {
    ca78:	f200 80d9 	bhi.w	cc2e <cbvprintf+0x3ca>
    ca7c:	2a57      	cmp	r2, #87	; 0x57
    ca7e:	d84d      	bhi.n	cb1c <cbvprintf+0x2b8>
    ca80:	2a41      	cmp	r2, #65	; 0x41
    ca82:	d003      	beq.n	ca8c <cbvprintf+0x228>
    ca84:	3a45      	subs	r2, #69	; 0x45
    ca86:	2a02      	cmp	r2, #2
    ca88:	f200 80d1 	bhi.w	cc2e <cbvprintf+0x3ca>
		conv->specifier_cat = SPECIFIER_FP;
    ca8c:	2204      	movs	r2, #4
    ca8e:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
    ca92:	f362 0302 	bfi	r3, r2, #0, #3
    ca96:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
			unsupported = true;
    ca9a:	2301      	movs	r3, #1
			break;
    ca9c:	e09e      	b.n	cbdc <cbvprintf+0x378>
		val = 10U * val + *sp++ - '0';
    ca9e:	fb06 2101 	mla	r1, r6, r1, r2
    caa2:	4603      	mov	r3, r0
    caa4:	3930      	subs	r1, #48	; 0x30
    caa6:	e764      	b.n	c972 <cbvprintf+0x10e>
	switch (*sp) {
    caa8:	2a74      	cmp	r2, #116	; 0x74
    caaa:	d026      	beq.n	cafa <cbvprintf+0x296>
    caac:	2a7a      	cmp	r2, #122	; 0x7a
    caae:	d1db      	bne.n	ca68 <cbvprintf+0x204>
		conv->length_mod = LENGTH_Z;
    cab0:	2206      	movs	r2, #6
    cab2:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
    cab6:	e00d      	b.n	cad4 <cbvprintf+0x270>
		if (*++sp == 'h') {
    cab8:	785a      	ldrb	r2, [r3, #1]
    caba:	2a68      	cmp	r2, #104	; 0x68
    cabc:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    cac0:	d106      	bne.n	cad0 <cbvprintf+0x26c>
			conv->length_mod = LENGTH_HH;
    cac2:	2101      	movs	r1, #1
			conv->length_mod = LENGTH_LL;
    cac4:	f361 02c6 	bfi	r2, r1, #3, #4
    cac8:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
			++sp;
    cacc:	1c9f      	adds	r7, r3, #2
    cace:	e7cc      	b.n	ca6a <cbvprintf+0x206>
			conv->length_mod = LENGTH_H;
    cad0:	4613      	mov	r3, r2
    cad2:	2202      	movs	r2, #2
		conv->length_mod = LENGTH_T;
    cad4:	f362 03c6 	bfi	r3, r2, #3, #4
    cad8:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
		break;
    cadc:	e7c5      	b.n	ca6a <cbvprintf+0x206>
		if (*++sp == 'l') {
    cade:	785a      	ldrb	r2, [r3, #1]
    cae0:	2a6c      	cmp	r2, #108	; 0x6c
    cae2:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    cae6:	d101      	bne.n	caec <cbvprintf+0x288>
			conv->length_mod = LENGTH_LL;
    cae8:	2104      	movs	r1, #4
    caea:	e7eb      	b.n	cac4 <cbvprintf+0x260>
			conv->length_mod = LENGTH_L;
    caec:	4613      	mov	r3, r2
    caee:	2203      	movs	r2, #3
    caf0:	e7f0      	b.n	cad4 <cbvprintf+0x270>
		conv->length_mod = LENGTH_J;
    caf2:	2205      	movs	r2, #5
    caf4:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
    caf8:	e7ec      	b.n	cad4 <cbvprintf+0x270>
		conv->length_mod = LENGTH_T;
    cafa:	2207      	movs	r2, #7
    cafc:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
    cb00:	e7e8      	b.n	cad4 <cbvprintf+0x270>
		conv->unsupported = true;
    cb02:	f8bd 3030 	ldrh.w	r3, [sp, #48]	; 0x30
    cb06:	f423 43f0 	bic.w	r3, r3, #30720	; 0x7800
    cb0a:	f023 0302 	bic.w	r3, r3, #2
    cb0e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    cb12:	f043 0302 	orr.w	r3, r3, #2
    cb16:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
		break;
    cb1a:	e7a6      	b.n	ca6a <cbvprintf+0x206>
    cb1c:	f1a2 0158 	sub.w	r1, r2, #88	; 0x58
    cb20:	2920      	cmp	r1, #32
    cb22:	f200 8084 	bhi.w	cc2e <cbvprintf+0x3ca>
    cb26:	a001      	add	r0, pc, #4	; (adr r0, cb2c <cbvprintf+0x2c8>)
    cb28:	f850 f021 	ldr.w	pc, [r0, r1, lsl #2]
    cb2c:	0000cbf1 	.word	0x0000cbf1
    cb30:	0000cc2f 	.word	0x0000cc2f
    cb34:	0000cc2f 	.word	0x0000cc2f
    cb38:	0000cc2f 	.word	0x0000cc2f
    cb3c:	0000cc2f 	.word	0x0000cc2f
    cb40:	0000cc2f 	.word	0x0000cc2f
    cb44:	0000cc2f 	.word	0x0000cc2f
    cb48:	0000cc2f 	.word	0x0000cc2f
    cb4c:	0000cc2f 	.word	0x0000cc2f
    cb50:	0000ca8d 	.word	0x0000ca8d
    cb54:	0000cc2f 	.word	0x0000cc2f
    cb58:	0000cbf1 	.word	0x0000cbf1
    cb5c:	0000cbb1 	.word	0x0000cbb1
    cb60:	0000ca8d 	.word	0x0000ca8d
    cb64:	0000ca8d 	.word	0x0000ca8d
    cb68:	0000ca8d 	.word	0x0000ca8d
    cb6c:	0000cc2f 	.word	0x0000cc2f
    cb70:	0000cbb1 	.word	0x0000cbb1
    cb74:	0000cc2f 	.word	0x0000cc2f
    cb78:	0000cc2f 	.word	0x0000cc2f
    cb7c:	0000cc2f 	.word	0x0000cc2f
    cb80:	0000cc2f 	.word	0x0000cc2f
    cb84:	0000cbf9 	.word	0x0000cbf9
    cb88:	0000cbf1 	.word	0x0000cbf1
    cb8c:	0000cc15 	.word	0x0000cc15
    cb90:	0000cc2f 	.word	0x0000cc2f
    cb94:	0000cc2f 	.word	0x0000cc2f
    cb98:	0000cc15 	.word	0x0000cc15
    cb9c:	0000cc2f 	.word	0x0000cc2f
    cba0:	0000cbf1 	.word	0x0000cbf1
    cba4:	0000cc2f 	.word	0x0000cc2f
    cba8:	0000cc2f 	.word	0x0000cc2f
    cbac:	0000cbf1 	.word	0x0000cbf1
		conv->specifier_cat = SPECIFIER_SINT;
    cbb0:	2001      	movs	r0, #1
    cbb2:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
    cbb6:	f003 0378 	and.w	r3, r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_UINT;
    cbba:	f360 0102 	bfi	r1, r0, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
    cbbe:	2b40      	cmp	r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_UINT;
    cbc0:	f88d 1032 	strb.w	r1, [sp, #50]	; 0x32
			conv->invalid = true;
    cbc4:	bf02      	ittt	eq
    cbc6:	f89d 1030 	ldrbeq.w	r1, [sp, #48]	; 0x30
    cbca:	f041 0101 	orreq.w	r1, r1, #1
    cbce:	f88d 1030 	strbeq.w	r1, [sp, #48]	; 0x30
		if (conv->specifier == 'c') {
    cbd2:	2a63      	cmp	r2, #99	; 0x63
    cbd4:	d131      	bne.n	cc3a <cbvprintf+0x3d6>
			unsupported = (conv->length_mod != LENGTH_NONE);
    cbd6:	3b00      	subs	r3, #0
    cbd8:	bf18      	it	ne
    cbda:	2301      	movne	r3, #1
	conv->unsupported |= unsupported;
    cbdc:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
    cbe0:	f3c2 0140 	ubfx	r1, r2, #1, #1
    cbe4:	430b      	orrs	r3, r1
    cbe6:	f363 0241 	bfi	r2, r3, #1, #1
    cbea:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
	return sp;
    cbee:	e6d8      	b.n	c9a2 <cbvprintf+0x13e>
		conv->specifier_cat = SPECIFIER_UINT;
    cbf0:	2002      	movs	r0, #2
    cbf2:	f89d 1032 	ldrb.w	r1, [sp, #50]	; 0x32
    cbf6:	e7de      	b.n	cbb6 <cbvprintf+0x352>
		conv->specifier_cat = SPECIFIER_PTR;
    cbf8:	2103      	movs	r1, #3
    cbfa:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
    cbfe:	f003 0378 	and.w	r3, r3, #120	; 0x78
    cc02:	f1a3 0040 	sub.w	r0, r3, #64	; 0x40
		conv->specifier_cat = SPECIFIER_PTR;
    cc06:	f361 0202 	bfi	r2, r1, #0, #3
		if (conv->length_mod == LENGTH_UPPER_L) {
    cc0a:	4243      	negs	r3, r0
		conv->specifier_cat = SPECIFIER_PTR;
    cc0c:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod == LENGTH_UPPER_L) {
    cc10:	4143      	adcs	r3, r0
    cc12:	e7e3      	b.n	cbdc <cbvprintf+0x378>
		conv->specifier_cat = SPECIFIER_PTR;
    cc14:	2103      	movs	r1, #3
    cc16:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod != LENGTH_NONE) {
    cc1a:	f013 0f78 	tst.w	r3, #120	; 0x78
		conv->specifier_cat = SPECIFIER_PTR;
    cc1e:	f361 0202 	bfi	r2, r1, #0, #3
		if (conv->length_mod != LENGTH_NONE) {
    cc22:	bf14      	ite	ne
    cc24:	2301      	movne	r3, #1
    cc26:	2300      	moveq	r3, #0
		conv->specifier_cat = SPECIFIER_PTR;
    cc28:	f88d 2032 	strb.w	r2, [sp, #50]	; 0x32
		if (conv->length_mod != LENGTH_NONE) {
    cc2c:	e7d6      	b.n	cbdc <cbvprintf+0x378>
		conv->invalid = true;
    cc2e:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
    cc32:	f043 0301 	orr.w	r3, r3, #1
    cc36:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
	bool unsupported = false;
    cc3a:	2300      	movs	r3, #0
    cc3c:	e7ce      	b.n	cbdc <cbvprintf+0x378>
		} else if (conv->width_present) {
    cc3e:	f99d 2030 	ldrsb.w	r2, [sp, #48]	; 0x30
    cc42:	2a00      	cmp	r2, #0
		int width = -1;
    cc44:	bfac      	ite	ge
    cc46:	f04f 39ff 	movge.w	r9, #4294967295
			width = conv->width_value;
    cc4a:	f8dd 9034 	ldrlt.w	r9, [sp, #52]	; 0x34
    cc4e:	e6ba      	b.n	c9c6 <cbvprintf+0x162>
		} else if (conv->prec_present) {
    cc50:	079b      	lsls	r3, r3, #30
    cc52:	f57f aec7 	bpl.w	c9e4 <cbvprintf+0x180>
			precision = conv->prec_value;
    cc56:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
		conv->pad0_value = 0;
    cc5a:	2300      	movs	r3, #0
		conv->pad0_pre_exp = 0;
    cc5c:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
			= (enum specifier_cat_enum)conv->specifier_cat;
    cc60:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
			= (enum length_mod_enum)conv->length_mod;
    cc64:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
		enum specifier_cat_enum specifier_cat
    cc68:	f003 0307 	and.w	r3, r3, #7
		if (specifier_cat == SPECIFIER_SINT) {
    cc6c:	2b01      	cmp	r3, #1
			= (enum length_mod_enum)conv->length_mod;
    cc6e:	f3c2 02c3 	ubfx	r2, r2, #3, #4
		if (specifier_cat == SPECIFIER_SINT) {
    cc72:	d136      	bne.n	cce2 <cbvprintf+0x47e>
			switch (length_mod) {
    cc74:	1ed3      	subs	r3, r2, #3
    cc76:	2b04      	cmp	r3, #4
    cc78:	d820      	bhi.n	ccbc <cbvprintf+0x458>
    cc7a:	e8df f003 	tbb	[pc, r3]
    cc7e:	0703      	.short	0x0703
    cc80:	1f07      	.short	0x1f07
    cc82:	1f          	.byte	0x1f
    cc83:	00          	.byte	0x00
					value->sint = va_arg(ap, long);
    cc84:	f854 0b04 	ldr.w	r0, [r4], #4
				value->sint = (short)value->sint;
    cc88:	17c1      	asrs	r1, r0, #31
    cc8a:	e004      	b.n	cc96 <cbvprintf+0x432>
					(sint_value_type)va_arg(ap, intmax_t);
    cc8c:	3407      	adds	r4, #7
    cc8e:	f024 0407 	bic.w	r4, r4, #7
				value->sint =
    cc92:	e8f4 0102 	ldrd	r0, r1, [r4], #8
				value->sint = (short)value->sint;
    cc96:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
		if (conv->invalid || conv->unsupported) {
    cc9a:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
    cc9e:	f013 0603 	ands.w	r6, r3, #3
    cca2:	d054      	beq.n	cd4e <cbvprintf+0x4ea>
			OUTS(sp, fp);
    cca4:	463b      	mov	r3, r7
    cca6:	4652      	mov	r2, sl
    cca8:	4659      	mov	r1, fp
    ccaa:	9802      	ldr	r0, [sp, #8]
    ccac:	f003 fb8b 	bl	103c6 <outs>
    ccb0:	2800      	cmp	r0, #0
    ccb2:	f2c0 8143 	blt.w	cf3c <cbvprintf+0x6d8>
    ccb6:	4405      	add	r5, r0
			continue;
    ccb8:	46ba      	mov	sl, r7
    ccba:	e5db      	b.n	c874 <cbvprintf+0x10>
					(sint_value_type)va_arg(ap, ptrdiff_t);
    ccbc:	f854 0b04 	ldr.w	r0, [r4], #4
			if (length_mod == LENGTH_HH) {
    ccc0:	2a01      	cmp	r2, #1
					(sint_value_type)va_arg(ap, ptrdiff_t);
    ccc2:	ea4f 71e0 	mov.w	r1, r0, asr #31
    ccc6:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
			if (length_mod == LENGTH_HH) {
    ccca:	d105      	bne.n	ccd8 <cbvprintf+0x474>
				value->uint = (unsigned char)value->uint;
    cccc:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
				value->uint = (unsigned short)value->uint;
    ccd0:	930a      	str	r3, [sp, #40]	; 0x28
    ccd2:	2300      	movs	r3, #0
    ccd4:	930b      	str	r3, [sp, #44]	; 0x2c
    ccd6:	e7e0      	b.n	cc9a <cbvprintf+0x436>
			} else if (length_mod == LENGTH_H) {
    ccd8:	2a02      	cmp	r2, #2
    ccda:	d1de      	bne.n	cc9a <cbvprintf+0x436>
				value->sint = (short)value->sint;
    ccdc:	f9bd 0028 	ldrsh.w	r0, [sp, #40]	; 0x28
    cce0:	e7d2      	b.n	cc88 <cbvprintf+0x424>
		} else if (specifier_cat == SPECIFIER_UINT) {
    cce2:	2b02      	cmp	r3, #2
    cce4:	d123      	bne.n	cd2e <cbvprintf+0x4ca>
			switch (length_mod) {
    cce6:	1ed3      	subs	r3, r2, #3
    cce8:	2b04      	cmp	r3, #4
    ccea:	d813      	bhi.n	cd14 <cbvprintf+0x4b0>
    ccec:	e8df f003 	tbb	[pc, r3]
    ccf0:	120a0a03 	.word	0x120a0a03
    ccf4:	12          	.byte	0x12
    ccf5:	00          	.byte	0x00
				if ((!WCHAR_IS_SIGNED)
    ccf6:	2100      	movs	r1, #0
					value->uint = (wchar_t)va_arg(ap,
    ccf8:	6820      	ldr	r0, [r4, #0]
    ccfa:	1d23      	adds	r3, r4, #4
    ccfc:	900a      	str	r0, [sp, #40]	; 0x28
    ccfe:	910b      	str	r1, [sp, #44]	; 0x2c
					(uint_value_type)va_arg(ap, size_t);
    cd00:	461c      	mov	r4, r3
    cd02:	e7ca      	b.n	cc9a <cbvprintf+0x436>
					(uint_value_type)va_arg(ap,
    cd04:	3407      	adds	r4, #7
    cd06:	f024 0307 	bic.w	r3, r4, #7
				value->uint =
    cd0a:	e8f3 0102 	ldrd	r0, r1, [r3], #8
    cd0e:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
				break;
    cd12:	e7f5      	b.n	cd00 <cbvprintf+0x49c>
					(uint_value_type)va_arg(ap, size_t);
    cd14:	f854 3b04 	ldr.w	r3, [r4], #4
			if (length_mod == LENGTH_HH) {
    cd18:	2a01      	cmp	r2, #1
					(uint_value_type)va_arg(ap, size_t);
    cd1a:	930a      	str	r3, [sp, #40]	; 0x28
    cd1c:	f04f 0300 	mov.w	r3, #0
    cd20:	930b      	str	r3, [sp, #44]	; 0x2c
			if (length_mod == LENGTH_HH) {
    cd22:	d0d3      	beq.n	cccc <cbvprintf+0x468>
			} else if (length_mod == LENGTH_H) {
    cd24:	2a02      	cmp	r2, #2
    cd26:	d1b8      	bne.n	cc9a <cbvprintf+0x436>
				value->uint = (unsigned short)value->uint;
    cd28:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
    cd2c:	e7d0      	b.n	ccd0 <cbvprintf+0x46c>
		} else if (specifier_cat == SPECIFIER_FP) {
    cd2e:	2b04      	cmp	r3, #4
    cd30:	d107      	bne.n	cd42 <cbvprintf+0x4de>
			if (length_mod == LENGTH_UPPER_L) {
    cd32:	3407      	adds	r4, #7
    cd34:	f024 0407 	bic.w	r4, r4, #7
    cd38:	e8f4 0102 	ldrd	r0, r1, [r4], #8
				value->ldbl = va_arg(ap, long double);
    cd3c:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
    cd40:	e7ab      	b.n	cc9a <cbvprintf+0x436>
		} else if (specifier_cat == SPECIFIER_PTR) {
    cd42:	2b03      	cmp	r3, #3
			value->ptr = va_arg(ap, void *);
    cd44:	bf04      	itt	eq
    cd46:	f854 3b04 	ldreq.w	r3, [r4], #4
    cd4a:	930a      	streq	r3, [sp, #40]	; 0x28
    cd4c:	e7a5      	b.n	cc9a <cbvprintf+0x436>
		switch (conv->specifier) {
    cd4e:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
    cd52:	2878      	cmp	r0, #120	; 0x78
    cd54:	d8b0      	bhi.n	ccb8 <cbvprintf+0x454>
    cd56:	2862      	cmp	r0, #98	; 0x62
    cd58:	d822      	bhi.n	cda0 <cbvprintf+0x53c>
    cd5a:	2825      	cmp	r0, #37	; 0x25
    cd5c:	f43f ad93 	beq.w	c886 <cbvprintf+0x22>
    cd60:	2858      	cmp	r0, #88	; 0x58
    cd62:	d1a9      	bne.n	ccb8 <cbvprintf+0x454>
			bps = encode_uint(value->uint, conv, buf, bpe);
    cd64:	e9dd 010a 	ldrd	r0, r1, [sp, #40]	; 0x28
    cd68:	f10d 0326 	add.w	r3, sp, #38	; 0x26
    cd6c:	9300      	str	r3, [sp, #0]
    cd6e:	aa0c      	add	r2, sp, #48	; 0x30
    cd70:	ab04      	add	r3, sp, #16
    cd72:	f003 fadd 	bl	10330 <encode_uint>
    cd76:	4682      	mov	sl, r0
			if (precision >= 0) {
    cd78:	f1b8 0f00 	cmp.w	r8, #0
    cd7c:	f10d 0026 	add.w	r0, sp, #38	; 0x26
    cd80:	db0c      	blt.n	cd9c <cbvprintf+0x538>
				conv->flag_zero = false;
    cd82:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
				size_t len = bpe - bps;
    cd86:	eba0 030a 	sub.w	r3, r0, sl
				conv->flag_zero = false;
    cd8a:	f36f 1286 	bfc	r2, #6, #1
				if (len < (size_t)precision) {
    cd8e:	4598      	cmp	r8, r3
				conv->flag_zero = false;
    cd90:	f88d 2030 	strb.w	r2, [sp, #48]	; 0x30
				if (len < (size_t)precision) {
    cd94:	d902      	bls.n	cd9c <cbvprintf+0x538>
					conv->pad0_value = precision - (int)len;
    cd96:	eba8 0303 	sub.w	r3, r8, r3
    cd9a:	930d      	str	r3, [sp, #52]	; 0x34
		const char *bpe = buf + sizeof(buf);
    cd9c:	4680      	mov	r8, r0
    cd9e:	e03d      	b.n	ce1c <cbvprintf+0x5b8>
    cda0:	3863      	subs	r0, #99	; 0x63
    cda2:	2815      	cmp	r0, #21
    cda4:	d888      	bhi.n	ccb8 <cbvprintf+0x454>
    cda6:	a101      	add	r1, pc, #4	; (adr r1, cdac <cbvprintf+0x548>)
    cda8:	f851 f020 	ldr.w	pc, [r1, r0, lsl #2]
    cdac:	0000ce2d 	.word	0x0000ce2d
    cdb0:	0000ce91 	.word	0x0000ce91
    cdb4:	0000ccb9 	.word	0x0000ccb9
    cdb8:	0000ccb9 	.word	0x0000ccb9
    cdbc:	0000ccb9 	.word	0x0000ccb9
    cdc0:	0000ccb9 	.word	0x0000ccb9
    cdc4:	0000ce91 	.word	0x0000ce91
    cdc8:	0000ccb9 	.word	0x0000ccb9
    cdcc:	0000ccb9 	.word	0x0000ccb9
    cdd0:	0000ccb9 	.word	0x0000ccb9
    cdd4:	0000ccb9 	.word	0x0000ccb9
    cdd8:	0000ceef 	.word	0x0000ceef
    cddc:	0000cebd 	.word	0x0000cebd
    cde0:	0000cec1 	.word	0x0000cec1
    cde4:	0000ccb9 	.word	0x0000ccb9
    cde8:	0000ccb9 	.word	0x0000ccb9
    cdec:	0000ce05 	.word	0x0000ce05
    cdf0:	0000ccb9 	.word	0x0000ccb9
    cdf4:	0000cebd 	.word	0x0000cebd
    cdf8:	0000ccb9 	.word	0x0000ccb9
    cdfc:	0000ccb9 	.word	0x0000ccb9
    ce00:	0000cebd 	.word	0x0000cebd
			if (precision >= 0) {
    ce04:	f1b8 0f00 	cmp.w	r8, #0
			bps = (const char *)value->ptr;
    ce08:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
			if (precision >= 0) {
    ce0c:	db0a      	blt.n	ce24 <cbvprintf+0x5c0>
				len = strnlen(bps, precision);
    ce0e:	4641      	mov	r1, r8
    ce10:	4650      	mov	r0, sl
    ce12:	f003 fbd9 	bl	105c8 <strnlen>
		char sign = 0;
    ce16:	2600      	movs	r6, #0
			bpe = bps + len;
    ce18:	eb0a 0800 	add.w	r8, sl, r0
		if (bps == NULL) {
    ce1c:	f1ba 0f00 	cmp.w	sl, #0
    ce20:	d10c      	bne.n	ce3c <cbvprintf+0x5d8>
    ce22:	e749      	b.n	ccb8 <cbvprintf+0x454>
				len = strlen(bps);
    ce24:	4650      	mov	r0, sl
    ce26:	f003 fbc8 	bl	105ba <strlen>
    ce2a:	e7f4      	b.n	ce16 <cbvprintf+0x5b2>
			break;
    ce2c:	2600      	movs	r6, #0
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    ce2e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
			bpe = buf + 1;
    ce30:	f10d 0811 	add.w	r8, sp, #17
			buf[0] = CHAR_IS_SIGNED ? value->sint : value->uint;
    ce34:	f88d 3010 	strb.w	r3, [sp, #16]
			bps = buf;
    ce38:	f10d 0a10 	add.w	sl, sp, #16
		size_t nj_len = (bpe - bps);
    ce3c:	eba8 030a 	sub.w	r3, r8, sl
		if (sign != 0) {
    ce40:	b106      	cbz	r6, ce44 <cbvprintf+0x5e0>
			nj_len += 1U;
    ce42:	3301      	adds	r3, #1
		if (conv->altform_0c) {
    ce44:	f89d 2032 	ldrb.w	r2, [sp, #50]	; 0x32
    ce48:	06d0      	lsls	r0, r2, #27
    ce4a:	d56b      	bpl.n	cf24 <cbvprintf+0x6c0>
			nj_len += 2U;
    ce4c:	3302      	adds	r3, #2
		if (conv->pad_fp) {
    ce4e:	0652      	lsls	r2, r2, #25
		nj_len += conv->pad0_value;
    ce50:	990d      	ldr	r1, [sp, #52]	; 0x34
			nj_len += conv->pad0_pre_exp;
    ce52:	bf48      	it	mi
    ce54:	9a0e      	ldrmi	r2, [sp, #56]	; 0x38
		nj_len += conv->pad0_value;
    ce56:	440b      	add	r3, r1
			nj_len += conv->pad0_pre_exp;
    ce58:	bf48      	it	mi
    ce5a:	189b      	addmi	r3, r3, r2
		if (width > 0) {
    ce5c:	f1b9 0f00 	cmp.w	r9, #0
    ce60:	dd79      	ble.n	cf56 <cbvprintf+0x6f2>
			if (!conv->flag_dash) {
    ce62:	f89d 2030 	ldrb.w	r2, [sp, #48]	; 0x30
			width -= (int)nj_len;
    ce66:	eba9 0903 	sub.w	r9, r9, r3
			if (!conv->flag_dash) {
    ce6a:	f3c2 0380 	ubfx	r3, r2, #2, #1
    ce6e:	9303      	str	r3, [sp, #12]
    ce70:	0753      	lsls	r3, r2, #29
    ce72:	d470      	bmi.n	cf56 <cbvprintf+0x6f2>
				if (conv->flag_zero) {
    ce74:	0650      	lsls	r0, r2, #25
    ce76:	d564      	bpl.n	cf42 <cbvprintf+0x6de>
					if (sign != 0) {
    ce78:	b146      	cbz	r6, ce8c <cbvprintf+0x628>
						OUTC(sign);
    ce7a:	4659      	mov	r1, fp
    ce7c:	4630      	mov	r0, r6
    ce7e:	9b02      	ldr	r3, [sp, #8]
    ce80:	4798      	blx	r3
    ce82:	2800      	cmp	r0, #0
    ce84:	db5a      	blt.n	cf3c <cbvprintf+0x6d8>
						sign = 0;
    ce86:	9b03      	ldr	r3, [sp, #12]
						OUTC(sign);
    ce88:	3501      	adds	r5, #1
						sign = 0;
    ce8a:	461e      	mov	r6, r3
					pad = '0';
    ce8c:	2330      	movs	r3, #48	; 0x30
    ce8e:	e059      	b.n	cf44 <cbvprintf+0x6e0>
			if (conv->flag_plus) {
    ce90:	071e      	lsls	r6, r3, #28
    ce92:	d411      	bmi.n	ceb8 <cbvprintf+0x654>
				sign = ' ';
    ce94:	f013 0610 	ands.w	r6, r3, #16
    ce98:	bf18      	it	ne
    ce9a:	2620      	movne	r6, #32
			if (value->sint < 0) {
    ce9c:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
    cea0:	2a00      	cmp	r2, #0
    cea2:	f173 0100 	sbcs.w	r1, r3, #0
    cea6:	f6bf af5d 	bge.w	cd64 <cbvprintf+0x500>
				value->uint = (uint_value_type)-value->sint;
    ceaa:	4252      	negs	r2, r2
    ceac:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
				sign = '-';
    ceb0:	262d      	movs	r6, #45	; 0x2d
				value->uint = (uint_value_type)-value->sint;
    ceb2:	e9cd 230a 	strd	r2, r3, [sp, #40]	; 0x28
    ceb6:	e755      	b.n	cd64 <cbvprintf+0x500>
				sign = '+';
    ceb8:	262b      	movs	r6, #43	; 0x2b
    ceba:	e7ef      	b.n	ce9c <cbvprintf+0x638>
		switch (conv->specifier) {
    cebc:	2600      	movs	r6, #0
    cebe:	e751      	b.n	cd64 <cbvprintf+0x500>
			if (value->ptr != NULL) {
    cec0:	980a      	ldr	r0, [sp, #40]	; 0x28
    cec2:	b348      	cbz	r0, cf18 <cbvprintf+0x6b4>
				bps = encode_uint((uintptr_t)value->ptr, conv,
    cec4:	f10d 0326 	add.w	r3, sp, #38	; 0x26
    cec8:	9300      	str	r3, [sp, #0]
    ceca:	2100      	movs	r1, #0
    cecc:	ab04      	add	r3, sp, #16
    cece:	aa0c      	add	r2, sp, #48	; 0x30
    ced0:	f003 fa2e 	bl	10330 <encode_uint>
				conv->altform_0c = true;
    ced4:	f8bd 3032 	ldrh.w	r3, [sp, #50]	; 0x32
				bps = encode_uint((uintptr_t)value->ptr, conv,
    ced8:	4682      	mov	sl, r0
				conv->altform_0c = true;
    ceda:	f003 03ef 	and.w	r3, r3, #239	; 0xef
    cede:	f443 43f0 	orr.w	r3, r3, #30720	; 0x7800
    cee2:	f043 0310 	orr.w	r3, r3, #16
		char sign = 0;
    cee6:	2600      	movs	r6, #0
				conv->altform_0c = true;
    cee8:	f8ad 3032 	strh.w	r3, [sp, #50]	; 0x32
				goto prec_int_pad0;
    ceec:	e744      	b.n	cd78 <cbvprintf+0x514>
				store_count(conv, value->ptr, count);
    ceee:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	switch ((enum length_mod_enum)conv->length_mod) {
    cef0:	2a07      	cmp	r2, #7
    cef2:	f63f aee1 	bhi.w	ccb8 <cbvprintf+0x454>
    cef6:	e8df f002 	tbb	[pc, r2]
    cefa:	040d      	.short	0x040d
    cefc:	08080d06 	.word	0x08080d06
    cf00:	0d0d      	.short	0x0d0d
		*(signed char *)dp = (signed char)count;
    cf02:	701d      	strb	r5, [r3, #0]
		break;
    cf04:	e6d8      	b.n	ccb8 <cbvprintf+0x454>
		*(short *)dp = (short)count;
    cf06:	801d      	strh	r5, [r3, #0]
		break;
    cf08:	e6d6      	b.n	ccb8 <cbvprintf+0x454>
		*(intmax_t *)dp = (intmax_t)count;
    cf0a:	4628      	mov	r0, r5
    cf0c:	17e9      	asrs	r1, r5, #31
    cf0e:	e9c3 0100 	strd	r0, r1, [r3]
		break;
    cf12:	e6d1      	b.n	ccb8 <cbvprintf+0x454>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
    cf14:	601d      	str	r5, [r3, #0]
		break;
    cf16:	e6cf      	b.n	ccb8 <cbvprintf+0x454>
			bpe = bps + 5;
    cf18:	f8df 80c4 	ldr.w	r8, [pc, #196]	; cfe0 <cbvprintf+0x77c>
    cf1c:	4606      	mov	r6, r0
			bps = "(nil)";
    cf1e:	f1a8 0a05 	sub.w	sl, r8, #5
    cf22:	e78b      	b.n	ce3c <cbvprintf+0x5d8>
		} else if (conv->altform_0) {
    cf24:	0711      	lsls	r1, r2, #28
			nj_len += 1U;
    cf26:	bf48      	it	mi
    cf28:	3301      	addmi	r3, #1
    cf2a:	e790      	b.n	ce4e <cbvprintf+0x5ea>
					OUTC(pad);
    cf2c:	4618      	mov	r0, r3
    cf2e:	9303      	str	r3, [sp, #12]
    cf30:	4659      	mov	r1, fp
    cf32:	9b02      	ldr	r3, [sp, #8]
    cf34:	4798      	blx	r3
    cf36:	2800      	cmp	r0, #0
    cf38:	9b03      	ldr	r3, [sp, #12]
    cf3a:	da04      	bge.n	cf46 <cbvprintf+0x6e2>
#undef OUTS
#undef OUTC
}
    cf3c:	b011      	add	sp, #68	; 0x44
    cf3e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				char pad = ' ';
    cf42:	2320      	movs	r3, #32
    cf44:	444d      	add	r5, r9
    cf46:	464a      	mov	r2, r9
				while (width-- > 0) {
    cf48:	2a00      	cmp	r2, #0
    cf4a:	eba5 0109 	sub.w	r1, r5, r9
    cf4e:	f109 39ff 	add.w	r9, r9, #4294967295
    cf52:	dceb      	bgt.n	cf2c <cbvprintf+0x6c8>
    cf54:	460d      	mov	r5, r1
		if (sign != 0) {
    cf56:	b136      	cbz	r6, cf66 <cbvprintf+0x702>
			OUTC(sign);
    cf58:	4659      	mov	r1, fp
    cf5a:	4630      	mov	r0, r6
    cf5c:	9b02      	ldr	r3, [sp, #8]
    cf5e:	4798      	blx	r3
    cf60:	2800      	cmp	r0, #0
    cf62:	dbeb      	blt.n	cf3c <cbvprintf+0x6d8>
    cf64:	3501      	adds	r5, #1
			if (conv->altform_0c | conv->altform_0) {
    cf66:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
    cf6a:	06d9      	lsls	r1, r3, #27
    cf6c:	d401      	bmi.n	cf72 <cbvprintf+0x70e>
    cf6e:	071a      	lsls	r2, r3, #28
    cf70:	d506      	bpl.n	cf80 <cbvprintf+0x71c>
				OUTC('0');
    cf72:	4659      	mov	r1, fp
    cf74:	2030      	movs	r0, #48	; 0x30
    cf76:	9b02      	ldr	r3, [sp, #8]
    cf78:	4798      	blx	r3
    cf7a:	2800      	cmp	r0, #0
    cf7c:	dbde      	blt.n	cf3c <cbvprintf+0x6d8>
    cf7e:	3501      	adds	r5, #1
			if (conv->altform_0c) {
    cf80:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
    cf84:	06db      	lsls	r3, r3, #27
    cf86:	d507      	bpl.n	cf98 <cbvprintf+0x734>
				OUTC(conv->specifier);
    cf88:	4659      	mov	r1, fp
    cf8a:	f89d 0033 	ldrb.w	r0, [sp, #51]	; 0x33
    cf8e:	9b02      	ldr	r3, [sp, #8]
    cf90:	4798      	blx	r3
    cf92:	2800      	cmp	r0, #0
    cf94:	dbd2      	blt.n	cf3c <cbvprintf+0x6d8>
    cf96:	3501      	adds	r5, #1
			while (pad_len-- > 0) {
    cf98:	9e0d      	ldr	r6, [sp, #52]	; 0x34
    cf9a:	442e      	add	r6, r5
    cf9c:	1b73      	subs	r3, r6, r5
    cf9e:	2b00      	cmp	r3, #0
    cfa0:	dc16      	bgt.n	cfd0 <cbvprintf+0x76c>
			OUTS(bps, bpe);
    cfa2:	4643      	mov	r3, r8
    cfa4:	4652      	mov	r2, sl
    cfa6:	4659      	mov	r1, fp
    cfa8:	9802      	ldr	r0, [sp, #8]
    cfaa:	f003 fa0c 	bl	103c6 <outs>
    cfae:	2800      	cmp	r0, #0
    cfb0:	dbc4      	blt.n	cf3c <cbvprintf+0x6d8>
    cfb2:	4405      	add	r5, r0
		while (width > 0) {
    cfb4:	44a9      	add	r9, r5
    cfb6:	eba9 0305 	sub.w	r3, r9, r5
    cfba:	2b00      	cmp	r3, #0
    cfbc:	f77f ae7c 	ble.w	ccb8 <cbvprintf+0x454>
			OUTC(' ');
    cfc0:	4659      	mov	r1, fp
    cfc2:	2020      	movs	r0, #32
    cfc4:	9b02      	ldr	r3, [sp, #8]
    cfc6:	4798      	blx	r3
    cfc8:	2800      	cmp	r0, #0
    cfca:	dbb7      	blt.n	cf3c <cbvprintf+0x6d8>
    cfcc:	3501      	adds	r5, #1
			--width;
    cfce:	e7f2      	b.n	cfb6 <cbvprintf+0x752>
				OUTC('0');
    cfd0:	4659      	mov	r1, fp
    cfd2:	2030      	movs	r0, #48	; 0x30
    cfd4:	9b02      	ldr	r3, [sp, #8]
    cfd6:	4798      	blx	r3
    cfd8:	2800      	cmp	r0, #0
    cfda:	dbaf      	blt.n	cf3c <cbvprintf+0x6d8>
    cfdc:	3501      	adds	r5, #1
    cfde:	e7dd      	b.n	cf9c <cbvprintf+0x738>
    cfe0:	00010fc3 	.word	0x00010fc3

0000cfe4 <check_erratum19>:
    #ifndef NRF53_SERIES
        return false;
    #else
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined(NRF_APPLICATION)
                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
    cfe4:	4b09      	ldr	r3, [pc, #36]	; (d00c <check_erratum19+0x28>)
                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
            #endif
        #endif
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined (NRF_APPLICATION)
                if (var1 == 0x07)
    cfe6:	681b      	ldr	r3, [r3, #0]
    cfe8:	2b07      	cmp	r3, #7
    cfea:	d10d      	bne.n	d008 <check_erratum19+0x24>
                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
    cfec:	4b08      	ldr	r3, [pc, #32]	; (d010 <check_erratum19+0x2c>)
    cfee:	681b      	ldr	r3, [r3, #0]
    cff0:	3b02      	subs	r3, #2
    cff2:	2b03      	cmp	r3, #3
    cff4:	d808      	bhi.n	d008 <check_erratum19+0x24>
	!defined(CONFIG_NRF5340_CPUAPP_ERRATUM19)

static int check_erratum19(const struct device *arg)
{
	ARG_UNUSED(arg);
	if (nrf53_errata_19()) {
    cff6:	4a07      	ldr	r2, [pc, #28]	; (d014 <check_erratum19+0x30>)
    cff8:	5cd3      	ldrb	r3, [r2, r3]
    cffa:	b12b      	cbz	r3, d008 <check_erratum19+0x24>
		LOG_ERR("This device is affected by nRF53 Erratum 19,");
		LOG_ERR("but workarounds have not been enabled.");
		LOG_ERR("See CONFIG_NRF5340_CPUAPP_ERRATUM19.");
		k_panic();
    cffc:	4040      	eors	r0, r0
    cffe:	f380 8811 	msr	BASEPRI, r0
    d002:	f04f 0004 	mov.w	r0, #4
    d006:	df02      	svc	2
	}

	return 0;
}
    d008:	2000      	movs	r0, #0
    d00a:	4770      	bx	lr
    d00c:	00ff0130 	.word	0x00ff0130
    d010:	00ff0134 	.word	0x00ff0134
    d014:	00010fc4 	.word	0x00010fc4

0000d018 <nrf_gpio_pin_mcu_select.constprop.0>:
        /* FALLTHROUGH */
        case 0: return NRF_P0;
#endif
#if defined(P1_FEATURE_PINS_PRESENT)
        /* FALLTHROUGH */
        case 1: return NRF_P1;
    d018:	4b09      	ldr	r3, [pc, #36]	; (d040 <nrf_gpio_pin_mcu_select.constprop.0+0x28>)
    d01a:	490a      	ldr	r1, [pc, #40]	; (d044 <nrf_gpio_pin_mcu_select.constprop.0+0x2c>)
}

NRF_STATIC_INLINE uint32_t nrf_gpio_pin_port_number_extract(uint32_t * p_pin)
{
    uint32_t pin_number = *p_pin;
    *p_pin = pin_number & 0x1F;
    d01c:	f000 021f 	and.w	r2, r0, #31

    return pin_number >> 5;
    d020:	0940      	lsrs	r0, r0, #5
        case 1: return NRF_P1;
    d022:	2801      	cmp	r0, #1
    d024:	bf08      	it	eq
    d026:	460b      	moveq	r3, r1
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_MCUSEL_Msk;
    d028:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    d02c:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    d030:	f022 42e0 	bic.w	r2, r2, #1879048192	; 0x70000000
    reg->PIN_CNF[pin_number] = cnf | (mcu << GPIO_PIN_CNF_MCUSEL_Pos);
    d034:	f042 5240 	orr.w	r2, r2, #805306368	; 0x30000000
    d038:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
}
    d03c:	4770      	bx	lr
    d03e:	bf00      	nop
    d040:	50842500 	.word	0x50842500
    d044:	50842800 	.word	0x50842800

0000d048 <nordicsemi_nrf53_init>:
{
    d048:	b570      	push	{r4, r5, r6, lr}
    d04a:	f04f 0320 	mov.w	r3, #32
    d04e:	f3ef 8611 	mrs	r6, BASEPRI
    d052:	f383 8811 	msr	BASEPRI, r3
    d056:	f3bf 8f6f 	isb	sy

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_cache_enable(NRF_CACHE_Type * p_reg)
{
    p_reg->ENABLE = CACHE_ENABLE_ENABLE_Enabled;
    d05a:	2401      	movs	r4, #1
}

NRF_STATIC_INLINE void nrf_oscillators_lfxo_cap_set(NRF_OSCILLATORS_Type *     p_reg,
                                                    nrf_oscillators_lfxo_cap_t cap)
{
    p_reg->XOSC32KI.INTCAP = (uint32_t)cap;
    d05c:	4d0b      	ldr	r5, [pc, #44]	; (d08c <nordicsemi_nrf53_init+0x44>)
    d05e:	4b0c      	ldr	r3, [pc, #48]	; (d090 <nordicsemi_nrf53_init+0x48>)
	nrf_gpio_pin_mcu_select(PIN_XL1, NRF_GPIO_PIN_MCUSEL_PERIPHERAL);
    d060:	2000      	movs	r0, #0
    d062:	f8c3 4500 	str.w	r4, [r3, #1280]	; 0x500
    d066:	f8c5 46d0 	str.w	r4, [r5, #1744]	; 0x6d0
    d06a:	f7ff ffd5 	bl	d018 <nrf_gpio_pin_mcu_select.constprop.0>
	nrf_gpio_pin_mcu_select(PIN_XL2, NRF_GPIO_PIN_MCUSEL_PERIPHERAL);
    d06e:	4620      	mov	r0, r4
    d070:	f7ff ffd2 	bl	d018 <nrf_gpio_pin_mcu_select.constprop.0>
NRF_STATIC_INLINE void nrf_regulators_dcdcen_set(NRF_REGULATORS_Type * p_reg, bool enable)
{
#if defined(REGULATORS_DCDCEN_DCDCEN_Msk)
    p_reg->DCDCEN = (enable ? REGULATORS_DCDCEN_DCDCEN_Msk : 0);
#else
    p_reg->VREGMAIN.DCDCEN = (enable ? REGULATORS_VREGMAIN_DCDCEN_DCDCEN_Msk : 0);
    d074:	f8c5 4704 	str.w	r4, [r5, #1796]	; 0x704
#endif

#if NRF_REGULATORS_HAS_DCDCEN_RADIO
NRF_STATIC_INLINE void nrf_regulators_dcdcen_radio_set(NRF_REGULATORS_Type * p_reg, bool enable)
{
    p_reg->VREGRADIO.DCDCEN = (enable) ? REGULATORS_VREGRADIO_DCDCEN_DCDCEN_Enabled :
    d078:	f8c5 4904 	str.w	r4, [r5, #2308]	; 0x904
    p_reg->VREGH.DCDCEN = (enable) ? REGULATORS_VREGH_DCDCEN_DCDCEN_Enabled :
    d07c:	f8c5 4b00 	str.w	r4, [r5, #2816]	; 0xb00
	__asm__ volatile(
    d080:	f386 8811 	msr	BASEPRI, r6
    d084:	f3bf 8f6f 	isb	sy
}
    d088:	2000      	movs	r0, #0
    d08a:	bd70      	pop	{r4, r5, r6, pc}
    d08c:	50004000 	.word	0x50004000
    d090:	50001000 	.word	0x50001000

0000d094 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
    d094:	b148      	cbz	r0, d0aa <arch_busy_wait+0x16>

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    d096:	4b05      	ldr	r3, [pc, #20]	; (d0ac <arch_busy_wait+0x18>)
    d098:	681a      	ldr	r2, [r3, #0]
    d09a:	4b05      	ldr	r3, [pc, #20]	; (d0b0 <arch_busy_wait+0x1c>)
    d09c:	fbb2 f2f3 	udiv	r2, r2, r3
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    d0a0:	4b04      	ldr	r3, [pc, #16]	; (d0b4 <arch_busy_wait+0x20>)
    delay_cycles(cycles);
    d0a2:	4350      	muls	r0, r2
    d0a4:	f043 0301 	orr.w	r3, r3, #1
    d0a8:	4718      	bx	r3
}
    d0aa:	4770      	bx	lr
    d0ac:	2000003c 	.word	0x2000003c
    d0b0:	000f4240 	.word	0x000f4240
    d0b4:	00010df0 	.word	0x00010df0

0000d0b8 <sys_reboot>:

extern void sys_arch_reboot(int type);
extern void sys_clock_disable(void);

void sys_reboot(int type)
{
    d0b8:	4604      	mov	r4, r0
    d0ba:	b508      	push	{r3, lr}
	__asm__ volatile(
    d0bc:	f04f 0220 	mov.w	r2, #32
    d0c0:	f3ef 8311 	mrs	r3, BASEPRI
    d0c4:	f382 8811 	msr	BASEPRI, r2
    d0c8:	f3bf 8f6f 	isb	sy
	(void)irq_lock();
#ifdef CONFIG_SYS_CLOCK_EXISTS
	sys_clock_disable();
    d0cc:	f003 fa36 	bl	1053c <sys_clock_disable>
#endif

	sys_arch_reboot(type);
    d0d0:	4620      	mov	r0, r4
    d0d2:	f000 fddf 	bl	dc94 <sys_arch_reboot>

	/* should never get here */
	printk("Failed to reboot: spinning endlessly...\n");
    d0d6:	4803      	ldr	r0, [pc, #12]	; (d0e4 <sys_reboot+0x2c>)
    d0d8:	f002 ff8c 	bl	fff4 <printk>
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
    d0dc:	f000 fc60 	bl	d9a0 <arch_cpu_idle>
    d0e0:	e7fc      	b.n	d0dc <sys_reboot+0x24>
    d0e2:	bf00      	nop
    d0e4:	00010fc8 	.word	0x00010fc8

0000d0e8 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
    d0e8:	b510      	push	{r4, lr}
	if (z_syscall_trap()) {
		return (const struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
    d0ea:	4807      	ldr	r0, [pc, #28]	; (d108 <uart_console_init+0x20>)
    d0ec:	f001 fdb8 	bl	ec60 <z_impl_device_get_binding>
	__stdout_hook_install(console_out);
    d0f0:	4c06      	ldr	r4, [pc, #24]	; (d10c <uart_console_init+0x24>)

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
    d0f2:	4b07      	ldr	r3, [pc, #28]	; (d110 <uart_console_init+0x28>)
    d0f4:	6018      	str	r0, [r3, #0]
	__stdout_hook_install(console_out);
    d0f6:	4620      	mov	r0, r4
    d0f8:	f000 ffac 	bl	e054 <__stdout_hook_install>
	__printk_hook_install(console_out);
    d0fc:	4620      	mov	r0, r4
    d0fe:	f7ff fab7 	bl	c670 <__printk_hook_install>

	uart_console_hook_install();

	return 0;
}
    d102:	2000      	movs	r0, #0
    d104:	bd10      	pop	{r4, pc}
    d106:	bf00      	nop
    d108:	00010ff1 	.word	0x00010ff1
    d10c:	0000d115 	.word	0x0000d115
    d110:	20000268 	.word	0x20000268

0000d114 <console_out>:
	if ('\n' == c) {
    d114:	280a      	cmp	r0, #10
{
    d116:	b538      	push	{r3, r4, r5, lr}
    d118:	4604      	mov	r4, r0
    d11a:	4d07      	ldr	r5, [pc, #28]	; (d138 <console_out+0x24>)
	if ('\n' == c) {
    d11c:	d104      	bne.n	d128 <console_out+0x14>
    d11e:	6828      	ldr	r0, [r5, #0]
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
    d120:	6883      	ldr	r3, [r0, #8]
    d122:	210d      	movs	r1, #13
    d124:	685b      	ldr	r3, [r3, #4]
    d126:	4798      	blx	r3
	uart_poll_out(uart_console_dev, c);
    d128:	6828      	ldr	r0, [r5, #0]
    d12a:	6883      	ldr	r3, [r0, #8]
    d12c:	b2e1      	uxtb	r1, r4
    d12e:	685b      	ldr	r3, [r3, #4]
    d130:	4798      	blx	r3
}
    d132:	4620      	mov	r0, r4
    d134:	bd38      	pop	{r3, r4, r5, pc}
    d136:	bf00      	nop
    d138:	20000268 	.word	0x20000268

0000d13c <onoff_stop>:
}

static clock_control_subsys_t get_subsys(struct onoff_manager *mgr)
{
	struct nrf_clock_control_data *data = CLOCK_DEVICE->data;
	size_t offset = (size_t)(mgr - data->mgr);
    d13c:	4a0e      	ldr	r2, [pc, #56]	; (d178 <onoff_stop+0x3c>)
	return (clock_control_subsys_t)offset;
}

static void onoff_stop(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
    d13e:	b570      	push	{r4, r5, r6, lr}
	size_t offset = (size_t)(mgr - data->mgr);
    d140:	1a84      	subs	r4, r0, r2
{
    d142:	4605      	mov	r5, r0
	err = set_off_state(&subdata->flags, ctx);
    d144:	200c      	movs	r0, #12
	size_t offset = (size_t)(mgr - data->mgr);
    d146:	10a3      	asrs	r3, r4, #2
    d148:	4c0c      	ldr	r4, [pc, #48]	; (d17c <onoff_stop+0x40>)
{
    d14a:	460e      	mov	r6, r1
	size_t offset = (size_t)(mgr - data->mgr);
    d14c:	435c      	muls	r4, r3
    d14e:	b2e4      	uxtb	r4, r4
	err = set_off_state(&subdata->flags, ctx);
    d150:	fb00 2004 	mla	r0, r0, r4, r2
    d154:	2140      	movs	r1, #64	; 0x40
    d156:	3078      	adds	r0, #120	; 0x78
    d158:	f003 f957 	bl	1040a <set_off_state>
	if (err < 0) {
    d15c:	1e01      	subs	r1, r0, #0
    d15e:	db05      	blt.n	d16c <onoff_stop+0x30>
	get_sub_config(dev, type)->stop();
    d160:	4b07      	ldr	r3, [pc, #28]	; (d180 <onoff_stop+0x44>)
    d162:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
    d166:	6863      	ldr	r3, [r4, #4]
    d168:	4798      	blx	r3
	return 0;
    d16a:	2100      	movs	r1, #0
	int res;

	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
	notify(mgr, res);
    d16c:	4628      	mov	r0, r5
    d16e:	4633      	mov	r3, r6
}
    d170:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	notify(mgr, res);
    d174:	4718      	bx	r3
    d176:	bf00      	nop
    d178:	2000027c 	.word	0x2000027c
    d17c:	b6db6db7 	.word	0xb6db6db7
    d180:	00010e0c 	.word	0x00010e0c

0000d184 <onoff_start>:
	notify(mgr, 0);
}

static void onoff_start(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
    d184:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	err = set_starting_state(&subdata->flags, ctx);
    d188:	250c      	movs	r5, #12
	size_t offset = (size_t)(mgr - data->mgr);
    d18a:	4e10      	ldr	r6, [pc, #64]	; (d1cc <onoff_start+0x48>)
{
    d18c:	4680      	mov	r8, r0
	size_t offset = (size_t)(mgr - data->mgr);
    d18e:	1b84      	subs	r4, r0, r6
    d190:	10a3      	asrs	r3, r4, #2
    d192:	4c0f      	ldr	r4, [pc, #60]	; (d1d0 <onoff_start+0x4c>)
{
    d194:	460f      	mov	r7, r1
	size_t offset = (size_t)(mgr - data->mgr);
    d196:	435c      	muls	r4, r3
    d198:	b2e4      	uxtb	r4, r4
	err = set_starting_state(&subdata->flags, ctx);
    d19a:	4365      	muls	r5, r4
    d19c:	f105 0078 	add.w	r0, r5, #120	; 0x78
    d1a0:	2140      	movs	r1, #64	; 0x40
    d1a2:	4430      	add	r0, r6
    d1a4:	f003 f94a 	bl	1043c <set_starting_state>
	if (err < 0) {
    d1a8:	1e01      	subs	r1, r0, #0
    d1aa:	db09      	blt.n	d1c0 <onoff_start+0x3c>
	subdata->cb = cb;
    d1ac:	4a09      	ldr	r2, [pc, #36]	; (d1d4 <onoff_start+0x50>)
    d1ae:	1973      	adds	r3, r6, r5
	subdata->user_data = user_data;
    d1b0:	e9c3 271c 	strd	r2, r7, [r3, #112]	; 0x70
	 get_sub_config(dev, type)->start();
    d1b4:	4b08      	ldr	r3, [pc, #32]	; (d1d8 <onoff_start+0x54>)
    d1b6:	f853 3034 	ldr.w	r3, [r3, r4, lsl #3]
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
			  onoff_started_callback, notify, CTX_ONOFF);
	if (err < 0) {
		notify(mgr, err);
	}
}
    d1ba:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	 get_sub_config(dev, type)->start();
    d1be:	4718      	bx	r3
		notify(mgr, err);
    d1c0:	4640      	mov	r0, r8
    d1c2:	463b      	mov	r3, r7
}
    d1c4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		notify(mgr, err);
    d1c8:	4718      	bx	r3
    d1ca:	bf00      	nop
    d1cc:	2000027c 	.word	0x2000027c
    d1d0:	b6db6db7 	.word	0xb6db6db7
    d1d4:	0001049f 	.word	0x0001049f
    d1d8:	00010e0c 	.word	0x00010e0c

0000d1dc <clk_init>:
		break;
	}
}

static int clk_init(const struct device *dev)
{
    d1dc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	static const struct onoff_transitions transitions = {
		.start = onoff_start,
		.stop = onoff_stop
	};

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    d1e0:	2200      	movs	r2, #0
    d1e2:	2101      	movs	r1, #1
{
    d1e4:	4606      	mov	r6, r0
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    d1e6:	2005      	movs	r0, #5
    d1e8:	f000 fb88 	bl	d8fc <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_power_clock_irq_handler, 0);
	irq_enable(DT_INST_IRQN(0));
    d1ec:	2005      	movs	r0, #5
    d1ee:	f000 fb67 	bl	d8c0 <arch_irq_enable>

	nrfx_err = nrfx_clock_init(clock_event_handler);
    d1f2:	4811      	ldr	r0, [pc, #68]	; (d238 <clk_init+0x5c>)
    d1f4:	f001 fb56 	bl	e8a4 <nrfx_clock_init>
	if (nrfx_err != NRFX_SUCCESS) {
    d1f8:	4b10      	ldr	r3, [pc, #64]	; (d23c <clk_init+0x60>)
    d1fa:	4298      	cmp	r0, r3
    d1fc:	d119      	bne.n	d232 <clk_init+0x56>
		struct nrf_clock_control_data *data = dev->data;

		z_nrf_clock_calibration_init(data->mgr);
	}

	nrfx_clock_enable();
    d1fe:	f003 fb5b 	bl	108b8 <nrfx_clock_enable>
    d202:	2400      	movs	r4, #0
	return &data->mgr[type];
    d204:	f04f 081c 	mov.w	r8, #28
					 &transitions);
		if (err < 0) {
			return err;
		}

		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
    d208:	270c      	movs	r7, #12
		err = onoff_manager_init(get_onoff_manager(dev, i),
    d20a:	f8df 9034 	ldr.w	r9, [pc, #52]	; d240 <clk_init+0x64>
						get_sub_data(dev, i);
    d20e:	68f5      	ldr	r5, [r6, #12]
		err = onoff_manager_init(get_onoff_manager(dev, i),
    d210:	4649      	mov	r1, r9
    d212:	fb08 5004 	mla	r0, r8, r4, r5
    d216:	f002 ff49 	bl	100ac <onoff_manager_init>
		if (err < 0) {
    d21a:	2800      	cmp	r0, #0
    d21c:	db07      	blt.n	d22e <clk_init+0x52>
		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
    d21e:	2301      	movs	r3, #1
    d220:	fb07 5504 	mla	r5, r7, r4, r5
    d224:	441c      	add	r4, r3
	for (enum clock_control_nrf_type i = 0;
    d226:	2c04      	cmp	r4, #4
		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
    d228:	67ab      	str	r3, [r5, #120]	; 0x78
	for (enum clock_control_nrf_type i = 0;
    d22a:	d1f0      	bne.n	d20e <clk_init+0x32>
	}

	return 0;
    d22c:	2000      	movs	r0, #0
}
    d22e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return -EIO;
    d232:	f06f 0004 	mvn.w	r0, #4
    d236:	e7fa      	b.n	d22e <clk_init+0x52>
    d238:	0000d279 	.word	0x0000d279
    d23c:	0bad0000 	.word	0x0bad0000
    d240:	00010e2c 	.word	0x00010e2c

0000d244 <clkstarted_handle.constprop.0>:
static void clkstarted_handle(const struct device *dev,
    d244:	4601      	mov	r1, r0
	clock_control_cb_t callback = sub_data->cb;
    d246:	230c      	movs	r3, #12
	sub_data->cb = NULL;
    d248:	2200      	movs	r2, #0
	clock_control_cb_t callback = sub_data->cb;
    d24a:	434b      	muls	r3, r1
    d24c:	4808      	ldr	r0, [pc, #32]	; (d270 <clkstarted_handle.constprop.0+0x2c>)
static void clkstarted_handle(const struct device *dev,
    d24e:	b570      	push	{r4, r5, r6, lr}
	clock_control_cb_t callback = sub_data->cb;
    d250:	18c4      	adds	r4, r0, r3
	set_on_state(&sub_data->flags);
    d252:	3378      	adds	r3, #120	; 0x78
	void *user_data = sub_data->user_data;
    d254:	e9d4 561c 	ldrd	r5, r6, [r4, #112]	; 0x70
	set_on_state(&sub_data->flags);
    d258:	4418      	add	r0, r3
	sub_data->cb = NULL;
    d25a:	6722      	str	r2, [r4, #112]	; 0x70
	set_on_state(&sub_data->flags);
    d25c:	f003 f90c 	bl	10478 <set_on_state>
	if (callback) {
    d260:	b12d      	cbz	r5, d26e <clkstarted_handle.constprop.0+0x2a>
		callback(dev, (clock_control_subsys_t)type, user_data);
    d262:	4632      	mov	r2, r6
    d264:	462b      	mov	r3, r5
}
    d266:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		callback(dev, (clock_control_subsys_t)type, user_data);
    d26a:	4802      	ldr	r0, [pc, #8]	; (d274 <clkstarted_handle.constprop.0+0x30>)
    d26c:	4718      	bx	r3
}
    d26e:	bd70      	pop	{r4, r5, r6, pc}
    d270:	2000027c 	.word	0x2000027c
    d274:	200000a8 	.word	0x200000a8

0000d278 <clock_event_handler>:
	switch (event) {
    d278:	2805      	cmp	r0, #5
    d27a:	d811      	bhi.n	d2a0 <clock_event_handler+0x28>
    d27c:	e8df f000 	tbb	[pc, r0]
    d280:	10100e03 	.word	0x10100e03
    d284:	0a0c      	.short	0x0a0c
		if (GET_STATUS(data->flags) == CLOCK_CONTROL_STATUS_STARTING) {
    d286:	4b07      	ldr	r3, [pc, #28]	; (d2a4 <clock_event_handler+0x2c>)
    d288:	6f98      	ldr	r0, [r3, #120]	; 0x78
    d28a:	f010 0007 	ands.w	r0, r0, #7
    d28e:	d107      	bne.n	d2a0 <clock_event_handler+0x28>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
    d290:	f7ff bfd8 	b.w	d244 <clkstarted_handle.constprop.0>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK192M);
    d294:	2002      	movs	r0, #2
    d296:	e7fb      	b.n	d290 <clock_event_handler+0x18>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLKAUDIO);
    d298:	2003      	movs	r0, #3
    d29a:	e7f9      	b.n	d290 <clock_event_handler+0x18>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
    d29c:	2001      	movs	r0, #1
    d29e:	e7f7      	b.n	d290 <clock_event_handler+0x18>
}
    d2a0:	4770      	bx	lr
    d2a2:	bf00      	nop
    d2a4:	2000027c 	.word	0x2000027c

0000d2a8 <generic_hfclk_start>:
{
    d2a8:	b508      	push	{r3, lr}
    d2aa:	f04f 0320 	mov.w	r3, #32
    d2ae:	f3ef 8111 	mrs	r1, BASEPRI
    d2b2:	f383 8811 	msr	BASEPRI, r3
    d2b6:	f3bf 8f6f 	isb	sy
	hfclk_users |= HF_USER_GENERIC;
    d2ba:	4a12      	ldr	r2, [pc, #72]	; (d304 <generic_hfclk_start+0x5c>)
    d2bc:	6813      	ldr	r3, [r2, #0]
    d2be:	f043 0002 	orr.w	r0, r3, #2
	if (hfclk_users & HF_USER_BT) {
    d2c2:	f013 0301 	ands.w	r3, r3, #1
	hfclk_users |= HF_USER_GENERIC;
    d2c6:	6010      	str	r0, [r2, #0]
	if (hfclk_users & HF_USER_BT) {
    d2c8:	d00c      	beq.n	d2e4 <generic_hfclk_start+0x3c>
            break;
        case NRF_CLOCK_DOMAIN_HFCLK:
            if (p_clk_src != NULL)
            {
                (*(nrf_clock_hfclk_t *)p_clk_src) =
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
    d2ca:	f04f 2250 	mov.w	r2, #1342197760	; 0x50005000
    d2ce:	f8d2 340c 	ldr.w	r3, [r2, #1036]	; 0x40c
                                        >> CLOCK_HFCLKSTAT_SRC_Pos);
            }
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    d2d2:	f8d2 240c 	ldr.w	r2, [r2, #1036]	; 0x40c
		if (type == NRF_CLOCK_HFCLK_HIGH_ACCURACY) {
    d2d6:	f013 0301 	ands.w	r3, r3, #1
    d2da:	d003      	beq.n	d2e4 <generic_hfclk_start+0x3c>
			set_on_state(get_hf_flags());
    d2dc:	480a      	ldr	r0, [pc, #40]	; (d308 <generic_hfclk_start+0x60>)
    d2de:	f003 f8cb 	bl	10478 <set_on_state>
			already_started = true;
    d2e2:	2301      	movs	r3, #1
	__asm__ volatile(
    d2e4:	f381 8811 	msr	BASEPRI, r1
    d2e8:	f3bf 8f6f 	isb	sy
	if (already_started) {
    d2ec:	b123      	cbz	r3, d2f8 <generic_hfclk_start+0x50>
}
    d2ee:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(CLOCK_DEVICE,
    d2f2:	2000      	movs	r0, #0
    d2f4:	f7ff bfa6 	b.w	d244 <clkstarted_handle.constprop.0>
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_start(void)
{
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
    d2f8:	2001      	movs	r0, #1
}
    d2fa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    d2fe:	f001 bae1 	b.w	e8c4 <nrfx_clock_start>
    d302:	bf00      	nop
    d304:	2000031c 	.word	0x2000031c
    d308:	200002f4 	.word	0x200002f4

0000d30c <generic_hfclk_stop>:
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    d30c:	4b07      	ldr	r3, [pc, #28]	; (d32c <generic_hfclk_stop+0x20>)
    d30e:	e8d3 2fef 	ldaex	r2, [r3]
    d312:	f022 0102 	bic.w	r1, r2, #2
    d316:	e8c3 1fe0 	stlex	r0, r1, [r3]
    d31a:	2800      	cmp	r0, #0
    d31c:	d1f7      	bne.n	d30e <generic_hfclk_stop+0x2>
	if (atomic_and(&hfclk_users, ~HF_USER_GENERIC) & HF_USER_BT) {
    d31e:	07d3      	lsls	r3, r2, #31
    d320:	d402      	bmi.n	d328 <generic_hfclk_stop+0x1c>
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_stop(void)
{
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
    d322:	2001      	movs	r0, #1
    d324:	f001 bb22 	b.w	e96c <nrfx_clock_stop>
}
    d328:	4770      	bx	lr
    d32a:	bf00      	nop
    d32c:	2000031c 	.word	0x2000031c

0000d330 <api_blocking_start>:
{
    d330:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
    d332:	2200      	movs	r2, #0
    d334:	2301      	movs	r3, #1
    d336:	e9cd 2302 	strd	r2, r3, [sp, #8]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
    d33a:	466b      	mov	r3, sp
    d33c:	4a08      	ldr	r2, [pc, #32]	; (d360 <api_blocking_start+0x30>)
	struct k_sem sem = Z_SEM_INITIALIZER(sem, 0, 1);
    d33e:	f8cd d000 	str.w	sp, [sp]
    d342:	f8cd d004 	str.w	sp, [sp, #4]
	err = api_start(dev, subsys, blocking_start_callback, &sem);
    d346:	f003 f8dc 	bl	10502 <api_start>
	if (err < 0) {
    d34a:	2800      	cmp	r0, #0
    d34c:	db05      	blt.n	d35a <api_blocking_start+0x2a>
		parm0.val = timeout;
		return (int) arch_syscall_invoke3(*(uintptr_t *)&sem, parm0.split.lo, parm0.split.hi, K_SYSCALL_K_SEM_TAKE);
	}
#endif
	compiler_barrier();
	return z_impl_k_sem_take(sem, timeout);
    d34e:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    d352:	2300      	movs	r3, #0
    d354:	4668      	mov	r0, sp
    d356:	f002 fa79 	bl	f84c <z_impl_k_sem_take>
}
    d35a:	b005      	add	sp, #20
    d35c:	f85d fb04 	ldr.w	pc, [sp], #4
    d360:	000104d5 	.word	0x000104d5

0000d364 <z_nrf_clock_control_lf_on>:
{
    d364:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    d368:	2201      	movs	r2, #1
    d36a:	4606      	mov	r6, r0
    d36c:	4939      	ldr	r1, [pc, #228]	; (d454 <z_nrf_clock_control_lf_on+0xf0>)
    d36e:	e8d1 3fef 	ldaex	r3, [r1]
    d372:	e8c1 2fe0 	stlex	r0, r2, [r1]
    d376:	2800      	cmp	r0, #0
    d378:	d1f9      	bne.n	d36e <z_nrf_clock_control_lf_on+0xa>
	if (atomic_set(&on, 1) == 0) {
    d37a:	b933      	cbnz	r3, d38a <z_nrf_clock_control_lf_on+0x26>
 */
static inline void sys_notify_init_spinwait(struct sys_notify *notify)
{
	__ASSERT_NO_MSG(notify != NULL);

	*notify = (struct sys_notify){
    d37c:	4936      	ldr	r1, [pc, #216]	; (d458 <z_nrf_clock_control_lf_on+0xf4>)
		err = onoff_request(mgr, &cli);
    d37e:	4837      	ldr	r0, [pc, #220]	; (d45c <z_nrf_clock_control_lf_on+0xf8>)
    d380:	604b      	str	r3, [r1, #4]
    d382:	60cb      	str	r3, [r1, #12]
    d384:	608a      	str	r2, [r1, #8]
    d386:	f002 fea4 	bl	100d2 <onoff_request>
	switch (start_mode) {
    d38a:	1e73      	subs	r3, r6, #1
    d38c:	2b01      	cmp	r3, #1
    d38e:	d832      	bhi.n	d3f6 <z_nrf_clock_control_lf_on+0x92>
	if ((mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE) &&
    d390:	2e01      	cmp	r6, #1
    d392:	d107      	bne.n	d3a4 <z_nrf_clock_control_lf_on+0x40>
    return clk_src;
}

NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
    d394:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    d398:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
	    (target_type == NRF_CLOCK_LFCLK_Xtal) &&
    d39c:	f003 0303 	and.w	r3, r3, #3
    d3a0:	2b02      	cmp	r3, #2
    d3a2:	d028      	beq.n	d3f6 <z_nrf_clock_control_lf_on+0x92>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
    d3a4:	f003 fb83 	bl	10aae <k_is_in_isr>
    d3a8:	4604      	mov	r4, r0
    d3aa:	b918      	cbnz	r0, d3b4 <z_nrf_clock_control_lf_on+0x50>
	return !z_sys_post_kernel;
    d3ac:	4b2c      	ldr	r3, [pc, #176]	; (d460 <z_nrf_clock_control_lf_on+0xfc>)
	int key = isr_mode ? irq_lock() : 0;
    d3ae:	781b      	ldrb	r3, [r3, #0]
    d3b0:	2b00      	cmp	r3, #0
    d3b2:	d147      	bne.n	d444 <z_nrf_clock_control_lf_on+0xe0>
	__asm__ volatile(
    d3b4:	f04f 0320 	mov.w	r3, #32
    d3b8:	f3ef 8511 	mrs	r5, BASEPRI
    d3bc:	f383 8811 	msr	BASEPRI, r3
    d3c0:	f3bf 8f6f 	isb	sy
    d3c4:	2401      	movs	r4, #1
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    d3c6:	4f27      	ldr	r7, [pc, #156]	; (d464 <z_nrf_clock_control_lf_on+0x100>)
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    d3c8:	f8df 809c 	ldr.w	r8, [pc, #156]	; d468 <z_nrf_clock_control_lf_on+0x104>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    d3cc:	f8df 909c 	ldr.w	r9, [pc, #156]	; d46c <z_nrf_clock_control_lf_on+0x108>
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    d3d0:	f04f 2250 	mov.w	r2, #1342197760	; 0x50005000
    d3d4:	f8d2 3418 	ldr.w	r3, [r2, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    d3d8:	f8d2 2418 	ldr.w	r2, [r2, #1048]	; 0x418
    d3dc:	03d2      	lsls	r2, r2, #15
    d3de:	d50c      	bpl.n	d3fa <z_nrf_clock_control_lf_on+0x96>
	while (!(nrfx_clock_is_running(d, (void *)&type)
    d3e0:	f003 0303 	and.w	r3, r3, #3
    d3e4:	2b02      	cmp	r3, #2
    d3e6:	d001      	beq.n	d3ec <z_nrf_clock_control_lf_on+0x88>
		     || (mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE)))) {
    d3e8:	2e01      	cmp	r6, #1
    d3ea:	d106      	bne.n	d3fa <z_nrf_clock_control_lf_on+0x96>
	if (isr_mode) {
    d3ec:	b324      	cbz	r4, d438 <z_nrf_clock_control_lf_on+0xd4>
	__asm__ volatile(
    d3ee:	f385 8811 	msr	BASEPRI, r5
    d3f2:	f3bf 8f6f 	isb	sy
}
    d3f6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if (isr_mode) {
    d3fa:	b1c4      	cbz	r4, d42e <z_nrf_clock_control_lf_on+0xca>
 *
 * @return N/A
 */
static inline void k_cpu_atomic_idle(unsigned int key)
{
	arch_cpu_atomic_idle(key);
    d3fc:	4628      	mov	r0, r5
    d3fe:	f000 fadd 	bl	d9bc <arch_cpu_atomic_idle>
    return (nrf_clock_lfclk_t)(p_reg->LFCLKSRC);
    d402:	f04f 2250 	mov.w	r2, #1342197760	; 0x50005000
    d406:	f8d2 3518 	ldr.w	r3, [r2, #1304]	; 0x518
		if ((target_type ==  NRF_CLOCK_LFCLK_Xtal)
    d40a:	b2db      	uxtb	r3, r3
    d40c:	2b01      	cmp	r3, #1
    d40e:	d1df      	bne.n	d3d0 <z_nrf_clock_control_lf_on+0x6c>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    d410:	6839      	ldr	r1, [r7, #0]
		    && nrf_clock_event_check(NRF_CLOCK,
    d412:	2900      	cmp	r1, #0
    d414:	d0dc      	beq.n	d3d0 <z_nrf_clock_control_lf_on+0x6c>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    d416:	2100      	movs	r1, #0
    d418:	6039      	str	r1, [r7, #0]
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_event_readback(void * p_event_reg)
{
#if NRFX_CHECK(NRFX_EVENT_READBACK_ENABLED) && !defined(NRF51)
    (void)*((volatile uint32_t *)(p_event_reg));
    d41a:	6839      	ldr	r1, [r7, #0]
    p_reg->LFCLKSRC = (uint32_t)(source);
    d41c:	2102      	movs	r1, #2
    d41e:	f8c2 1518 	str.w	r1, [r2, #1304]	; 0x518
    d422:	2220      	movs	r2, #32
    d424:	f8c8 2180 	str.w	r2, [r8, #384]	; 0x180
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    d428:	f8c9 3000 	str.w	r3, [r9]
}
    d42c:	e7d0      	b.n	d3d0 <z_nrf_clock_control_lf_on+0x6c>
	return z_impl_k_sleep(timeout);
    d42e:	2100      	movs	r1, #0
    d430:	2021      	movs	r0, #33	; 0x21
    d432:	f002 f9c3 	bl	f7bc <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
    d436:	e7e4      	b.n	d402 <z_nrf_clock_control_lf_on+0x9e>
    p_reg->INTENSET = mask;
    d438:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    d43c:	2202      	movs	r2, #2
    d43e:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
    d442:	e7d8      	b.n	d3f6 <z_nrf_clock_control_lf_on+0x92>
    p_reg->INTENCLR = mask;
    d444:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    d448:	2202      	movs	r2, #2
	int key = isr_mode ? irq_lock() : 0;
    d44a:	4605      	mov	r5, r0
    d44c:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
}
    d450:	e7b9      	b.n	d3c6 <z_nrf_clock_control_lf_on+0x62>
    d452:	bf00      	nop
    d454:	20000320 	.word	0x20000320
    d458:	2000026c 	.word	0x2000026c
    d45c:	20000298 	.word	0x20000298
    d460:	20000966 	.word	0x20000966
    d464:	50005104 	.word	0x50005104
    d468:	e000e100 	.word	0xe000e100
    d46c:	50005008 	.word	0x50005008

0000d470 <sys_clock_timeout_handler>:

static void sys_clock_timeout_handler(uint32_t chan,
				      uint32_t cc_value,
				      void *user_data)
{
	uint32_t dticks = counter_sub(cc_value, last_count) / CYC_PER_TICK;
    d470:	4a04      	ldr	r2, [pc, #16]	; (d484 <sys_clock_timeout_handler+0x14>)
    d472:	6813      	ldr	r3, [r2, #0]
	return (a - b) & COUNTER_MAX;
    d474:	1ac8      	subs	r0, r1, r3
    d476:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000

	last_count += dticks * CYC_PER_TICK;
    d47a:	4403      	add	r3, r0
    d47c:	6013      	str	r3, [r2, #0]
		 */
		compare_set(chan, last_count + CYC_PER_TICK,
					  sys_clock_timeout_handler, NULL);
	}

	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
    d47e:	f002 bbb5 	b.w	fbec <z_clock_announce>
    d482:	bf00      	nop
    d484:	20000330 	.word	0x20000330

0000d488 <set_absolute_alarm>:
{
    d488:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
    d48c:	f44f 3780 	mov.w	r7, #65536	; 0x10000
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
}

NRF_STATIC_INLINE void nrf_rtc_event_clear(NRF_RTC_Type * p_reg, nrf_rtc_event_t event)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    d490:	f04f 0900 	mov.w	r9, #0
    d494:	0086      	lsls	r6, r0, #2
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
    d496:	f100 0450 	add.w	r4, r0, #80	; 0x50
    d49a:	f106 2650 	add.w	r6, r6, #1342197760	; 0x50005000
    d49e:	00a4      	lsls	r4, r4, #2
    d4a0:	f506 3680 	add.w	r6, r6, #65536	; 0x10000
    d4a4:	b2a4      	uxth	r4, r4
    d4a6:	f104 2450 	add.w	r4, r4, #1342197760	; 0x50005000
    return p_reg->CC[ch];
    d4aa:	f8d6 3540 	ldr.w	r3, [r6, #1344]	; 0x540
    nrf_event_readback((uint8_t *)p_reg + (uint32_t)event);
}

NRF_STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type const * p_reg)
{
     return p_reg->COUNTER;
    d4ae:	f8df 806c 	ldr.w	r8, [pc, #108]	; d51c <set_absolute_alarm+0x94>
	uint32_t cc_val = abs_val & COUNTER_MAX;
    d4b2:	f021 457f 	bic.w	r5, r1, #4278190080	; 0xff000000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    d4b6:	f504 3480 	add.w	r4, r4, #65536	; 0x10000
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
    d4ba:	4087      	lsls	r7, r0
     return p_reg->COUNTER;
    d4bc:	f8d8 a504 	ldr.w	sl, [r8, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
    d4c0:	eba3 030a 	sub.w	r3, r3, sl
    d4c4:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
    d4c8:	f02a 427f 	bic.w	r2, sl, #4278190080	; 0xff000000
		if (counter_sub(prev_cc, now) == 1) {
    d4cc:	2b01      	cmp	r3, #1
    p_reg->CC[ch] = cc_val;
    d4ce:	f8c6 2540 	str.w	r2, [r6, #1344]	; 0x540
    d4d2:	d102      	bne.n	d4da <set_absolute_alarm+0x52>
	z_impl_k_busy_wait(usec_to_wait);
    d4d4:	2013      	movs	r0, #19
    d4d6:	f003 faf0 	bl	10aba <z_impl_k_busy_wait>
		if (counter_sub(cc_val, now + 2) > COUNTER_HALF_SPAN) {
    d4da:	f10a 0202 	add.w	r2, sl, #2
	return (a - b) & COUNTER_MAX;
    d4de:	1aab      	subs	r3, r5, r2
    d4e0:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
			cc_val = now + 2;
    d4e4:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
    d4e8:	bf88      	it	hi
    d4ea:	4615      	movhi	r5, r2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    d4ec:	f8c4 9000 	str.w	r9, [r4]
    d4f0:	6823      	ldr	r3, [r4, #0]
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
    d4f2:	f025 437f 	bic.w	r3, r5, #4278190080	; 0xff000000
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
    d4f6:	f8c8 7344 	str.w	r7, [r8, #836]	; 0x344
    p_reg->CC[ch] = cc_val;
    d4fa:	f8c6 3540 	str.w	r3, [r6, #1344]	; 0x540
     return p_reg->COUNTER;
    d4fe:	f8d8 3504 	ldr.w	r3, [r8, #1284]	; 0x504
		 (counter_sub(cc_val, now2 + 2) > COUNTER_HALF_SPAN));
    d502:	459a      	cmp	sl, r3
    d504:	d006      	beq.n	d514 <set_absolute_alarm+0x8c>
	return (a - b) & COUNTER_MAX;
    d506:	1aeb      	subs	r3, r5, r3
    d508:	3b02      	subs	r3, #2
    d50a:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	} while ((now2 != now) &&
    d50e:	f5b3 0f00 	cmp.w	r3, #8388608	; 0x800000
    d512:	d801      	bhi.n	d518 <set_absolute_alarm+0x90>
}
    d514:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		prev_cc = cc_val;
    d518:	462b      	mov	r3, r5
    d51a:	e7cf      	b.n	d4bc <set_absolute_alarm+0x34>
    d51c:	50015000 	.word	0x50015000

0000d520 <rtc_nrf_isr>:
 * probably better abstract that at some point (e.g. query and reset
 * it by pointer at runtime, maybe?) so we don't have this leaky
 * symbol.
 */
void rtc_nrf_isr(const void *arg)
{
    d520:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	ARG_UNUSED(arg);

	for (uint32_t chan = 0; chan < CHAN_COUNT; chan++) {
    d522:	2400      	movs	r4, #0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    d524:	4627      	mov	r7, r4
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    d526:	4e0f      	ldr	r6, [pc, #60]	; (d564 <rtc_nrf_isr+0x44>)
    d528:	4b0f      	ldr	r3, [pc, #60]	; (d568 <rtc_nrf_isr+0x48>)
    return p_reg->INTENSET & mask;
    d52a:	4a10      	ldr	r2, [pc, #64]	; (d56c <rtc_nrf_isr+0x4c>)
    d52c:	4618      	mov	r0, r3
    d52e:	681d      	ldr	r5, [r3, #0]
    d530:	b104      	cbz	r4, d534 <rtc_nrf_isr+0x14>
				handler(chan, cc_val,
					cc_data[chan].user_context);
			}
		}
	}
}
    d532:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    d534:	f8d2 1304 	ldr.w	r1, [r2, #772]	; 0x304
		if (nrf_rtc_int_enable_check(RTC, RTC_CHANNEL_INT_MASK(chan)) &&
    d538:	03c9      	lsls	r1, r1, #15
    d53a:	d5fa      	bpl.n	d532 <rtc_nrf_isr+0x12>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    d53c:	6831      	ldr	r1, [r6, #0]
    d53e:	2900      	cmp	r1, #0
    d540:	d0f7      	beq.n	d532 <rtc_nrf_isr+0x12>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    d542:	6034      	str	r4, [r6, #0]
    d544:	6831      	ldr	r1, [r6, #0]
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
    d546:	f44f 3180 	mov.w	r1, #65536	; 0x10000
    d54a:	f8c2 1348 	str.w	r1, [r2, #840]	; 0x348
	for (uint32_t chan = 0; chan < CHAN_COUNT; chan++) {
    d54e:	2401      	movs	r4, #1
    return p_reg->CC[ch];
    d550:	f8d2 1540 	ldr.w	r1, [r2, #1344]	; 0x540
			if (handler) {
    d554:	b125      	cbz	r5, d560 <rtc_nrf_isr+0x40>
				handler(chan, cc_val,
    d556:	2000      	movs	r0, #0
    d558:	685a      	ldr	r2, [r3, #4]
    d55a:	601f      	str	r7, [r3, #0]
    d55c:	47a8      	blx	r5
    d55e:	e7e3      	b.n	d528 <rtc_nrf_isr+0x8>
    d560:	6005      	str	r5, [r0, #0]
}
    d562:	e7e6      	b.n	d532 <rtc_nrf_isr+0x12>
    d564:	50015140 	.word	0x50015140
    d568:	20000324 	.word	0x20000324
    d56c:	50015000 	.word	0x50015000

0000d570 <z_clock_driver_init>:

	atomic_or(&alloc_mask, BIT(chan));
}

int z_clock_driver_init(const struct device *device)
{
    d570:	b538      	push	{r3, r4, r5, lr}
    p_reg->PRESCALER = val;
    d572:	2400      	movs	r4, #0
    p_reg->INTENSET = mask;
    d574:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    d578:	f44f 1200 	mov.w	r2, #2097152	; 0x200000
    p_reg->PRESCALER = val;
    d57c:	4d0d      	ldr	r5, [pc, #52]	; (d5b4 <z_clock_driver_init+0x44>)
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
	}

	NVIC_ClearPendingIRQ(RTC_IRQn);

	IRQ_CONNECT(RTC_IRQn, DT_IRQ(DT_NODELABEL(RTC_LABEL), priority),
    d57e:	2101      	movs	r1, #1
    d580:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
    p_reg->INTENSET = mask;
    d584:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    d588:	4b0b      	ldr	r3, [pc, #44]	; (d5b8 <z_clock_driver_init+0x48>)
    d58a:	2015      	movs	r0, #21
    d58c:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    d590:	4622      	mov	r2, r4
    d592:	f000 f9b3 	bl	d8fc <z_arm_irq_priority_set>
		    rtc_nrf_isr, 0, 0);
	irq_enable(RTC_IRQn);
    d596:	2015      	movs	r0, #21
    d598:	f000 f992 	bl	d8c0 <arch_irq_enable>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
    d59c:	2301      	movs	r3, #1
    d59e:	4a07      	ldr	r2, [pc, #28]	; (d5bc <z_clock_driver_init+0x4c>)
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		compare_set(0, counter() + CYC_PER_TICK,
			    sys_clock_timeout_handler, NULL);
	}

	z_nrf_clock_control_lf_on(mode);
    d5a0:	2002      	movs	r0, #2
    d5a2:	6013      	str	r3, [r2, #0]
	int_mask = BIT_MASK(CHAN_COUNT);
    d5a4:	4a06      	ldr	r2, [pc, #24]	; (d5c0 <z_clock_driver_init+0x50>)
    d5a6:	602b      	str	r3, [r5, #0]
    d5a8:	6013      	str	r3, [r2, #0]
	z_nrf_clock_control_lf_on(mode);
    d5aa:	f7ff fedb 	bl	d364 <z_nrf_clock_control_lf_on>

	return 0;
}
    d5ae:	4620      	mov	r0, r4
    d5b0:	bd38      	pop	{r3, r4, r5, pc}
    d5b2:	bf00      	nop
    d5b4:	50015000 	.word	0x50015000
    d5b8:	e000e100 	.word	0xe000e100
    d5bc:	50015008 	.word	0x50015008
    d5c0:	2000032c 	.word	0x2000032c

0000d5c4 <z_clock_set_timeout>:

	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return;
	}

	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
    d5c4:	4b13      	ldr	r3, [pc, #76]	; (d614 <z_clock_set_timeout+0x50>)
    d5c6:	f1b0 3fff 	cmp.w	r0, #4294967295
    d5ca:	bf08      	it	eq
    d5cc:	4618      	moveq	r0, r3
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
    d5ce:	3801      	subs	r0, #1
    d5d0:	2800      	cmp	r0, #0
    d5d2:	dd1c      	ble.n	d60e <z_clock_set_timeout+0x4a>
    d5d4:	4298      	cmp	r0, r3
    d5d6:	bfa8      	it	ge
    d5d8:	4618      	movge	r0, r3
     return p_reg->COUNTER;
    d5da:	4b0f      	ldr	r3, [pc, #60]	; (d618 <z_clock_set_timeout+0x54>)
    d5dc:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504

	uint32_t unannounced = counter_sub(counter(), last_count);
    d5e0:	4b0e      	ldr	r3, [pc, #56]	; (d61c <z_clock_set_timeout+0x58>)
    d5e2:	6819      	ldr	r1, [r3, #0]
	return (a - b) & COUNTER_MAX;
    d5e4:	1a52      	subs	r2, r2, r1
	 * duration, then force an announce to avoid loss of a wrap
	 * event.  This can happen if new timeouts keep being set
	 * before the existing one triggers the interrupt.
	 */
	if (unannounced >= COUNTER_HALF_SPAN) {
		ticks = 0;
    d5e6:	f412 0f00 	tst.w	r2, #8388608	; 0x800000
    d5ea:	bf18      	it	ne
    d5ec:	2000      	movne	r0, #0
	return (a - b) & COUNTER_MAX;
    d5ee:	f022 437f 	bic.w	r3, r2, #4278190080	; 0xff000000
	}

	/* Get the cycles from last_count to the tick boundary after
	 * the requested ticks have passed starting now.
	 */
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
    d5f2:	3301      	adds	r3, #1
	cc_data[chan].callback = handler;
    d5f4:	4a0a      	ldr	r2, [pc, #40]	; (d620 <z_clock_set_timeout+0x5c>)
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
    d5f6:	4403      	add	r3, r0
	cc_data[chan].callback = handler;
    d5f8:	480a      	ldr	r0, [pc, #40]	; (d624 <z_clock_set_timeout+0x60>)
    d5fa:	6010      	str	r0, [r2, #0]
	cc_data[chan].user_context = user_data;
    d5fc:	2000      	movs	r0, #0
    d5fe:	6050      	str	r0, [r2, #4]
	set_absolute_alarm(chan, cc_value);
    d600:	4a04      	ldr	r2, [pc, #16]	; (d614 <z_clock_set_timeout+0x50>)
    d602:	4293      	cmp	r3, r2
    d604:	bf94      	ite	ls
    d606:	18c9      	addls	r1, r1, r3
    d608:	1889      	addhi	r1, r1, r2
    d60a:	f7ff bf3d 	b.w	d488 <set_absolute_alarm>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
    d60e:	2000      	movs	r0, #0
    d610:	e7e3      	b.n	d5da <z_clock_set_timeout+0x16>
    d612:	bf00      	nop
    d614:	007fffff 	.word	0x007fffff
    d618:	50015000 	.word	0x50015000
    d61c:	20000330 	.word	0x20000330
    d620:	20000324 	.word	0x20000324
    d624:	0000d471 	.word	0x0000d471

0000d628 <z_clock_elapsed>:
	__asm__ volatile(
    d628:	f04f 0220 	mov.w	r2, #32
    d62c:	f3ef 8311 	mrs	r3, BASEPRI
    d630:	f382 8811 	msr	BASEPRI, r2
    d634:	f3bf 8f6f 	isb	sy
    d638:	4a06      	ldr	r2, [pc, #24]	; (d654 <z_clock_elapsed+0x2c>)
    d63a:	f8d2 0504 	ldr.w	r0, [r2, #1284]	; 0x504
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t ret = counter_sub(counter(), last_count) / CYC_PER_TICK;
    d63e:	4a06      	ldr	r2, [pc, #24]	; (d658 <z_clock_elapsed+0x30>)
	return (a - b) & COUNTER_MAX;
    d640:	6812      	ldr	r2, [r2, #0]
    d642:	1a80      	subs	r0, r0, r2
    d644:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	__asm__ volatile(
    d648:	f383 8811 	msr	BASEPRI, r3
    d64c:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
    d650:	4770      	bx	lr
    d652:	bf00      	nop
    d654:	50015000 	.word	0x50015000
    d658:	20000330 	.word	0x20000330

0000d65c <nrf_cc3xx_platform_abort_init>:

/** @brief Function to initialize the nrf_cc3xx_platform abort APIs.
 */
void nrf_cc3xx_platform_abort_init(void)
{
	nrf_cc3xx_platform_set_abort(&apis);
    d65c:	4801      	ldr	r0, [pc, #4]	; (d664 <nrf_cc3xx_platform_abort_init+0x8>)
    d65e:	f002 bba9 	b.w	fdb4 <nrf_cc3xx_platform_set_abort>
    d662:	bf00      	nop
    d664:	00010e38 	.word	0x00010e38

0000d668 <mutex_unlock_platform>:
    }
}

/** @brief Static function to unlock a mutex
 */
static int32_t mutex_unlock_platform(nrf_cc3xx_platform_mutex_t *mutex) {
    d668:	b508      	push	{r3, lr}
    struct k_mutex * p_mutex;

    /* Ensure that the mutex param is valid (not NULL) */
    if(mutex == NULL) {
    d66a:	b308      	cbz	r0, d6b0 <mutex_unlock_platform+0x48>
        return NRF_CC3XX_PLATFORM_ERROR_PARAM_NULL;
    }

    switch (mutex->flags)
    d66c:	6843      	ldr	r3, [r0, #4]
    d66e:	2b04      	cmp	r3, #4
    d670:	d007      	beq.n	d682 <mutex_unlock_platform+0x1a>
    d672:	2b08      	cmp	r3, #8
    d674:	d013      	beq.n	d69e <mutex_unlock_platform+0x36>

#endif /* defined(NRF5340_XXAA_APPLICATION) */

    default:
        /* Ensure that the mutex has been initialized */
        if (mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID) {
    d676:	b1f3      	cbz	r3, d6b6 <mutex_unlock_platform+0x4e>
            return NRF_CC3XX_PLATFORM_ERROR_MUTEX_NOT_INITIALIZED;
        }

        p_mutex = (struct k_mutex *)mutex->mutex;
    d678:	6800      	ldr	r0, [r0, #0]
	return z_impl_k_mutex_unlock(mutex);
    d67a:	f001 fce3 	bl	f044 <z_impl_k_mutex_unlock>

        k_mutex_unlock(p_mutex);
        return NRF_CC3XX_PLATFORM_SUCCESS;
    d67e:	2000      	movs	r0, #0
    d680:	e00c      	b.n	d69c <mutex_unlock_platform+0x34>
	return __atomic_compare_exchange_n(target, &old_value, new_value,
    d682:	2200      	movs	r2, #0
    d684:	6803      	ldr	r3, [r0, #0]
    d686:	e8d3 1fef 	ldaex	r1, [r3]
    d68a:	2901      	cmp	r1, #1
    d68c:	d103      	bne.n	d696 <mutex_unlock_platform+0x2e>
    d68e:	e8c3 2fe0 	stlex	r0, r2, [r3]
    d692:	2800      	cmp	r0, #0
    d694:	d1f7      	bne.n	d686 <mutex_unlock_platform+0x1e>
                       NRF_CC3XX_PLATFORM_SUCCESS :
    d696:	4809      	ldr	r0, [pc, #36]	; (d6bc <mutex_unlock_platform+0x54>)
    d698:	bf08      	it	eq
    d69a:	4610      	moveq	r0, r2
    }
}
    d69c:	bd08      	pop	{r3, pc}
        nrf_mutex_unlock(NRF_MUTEX, *((uint8_t *)mutex->mutex));
    d69e:	6803      	ldr	r3, [r0, #0]
    return (p_reg->MUTEX[mutex] == MUTEX_MUTEX_MUTEX_Unlocked);
}

NRF_STATIC_INLINE void nrf_mutex_unlock(NRF_MUTEX_Type * p_reg, uint8_t mutex)
{
    p_reg->MUTEX[mutex] = MUTEX_MUTEX_MUTEX_Unlocked;
    d6a0:	2000      	movs	r0, #0
    d6a2:	781b      	ldrb	r3, [r3, #0]
    d6a4:	4a06      	ldr	r2, [pc, #24]	; (d6c0 <mutex_unlock_platform+0x58>)
    d6a6:	f503 7380 	add.w	r3, r3, #256	; 0x100
    d6aa:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
        return NRF_CC3XX_PLATFORM_SUCCESS;
    d6ae:	e7f5      	b.n	d69c <mutex_unlock_platform+0x34>
        return NRF_CC3XX_PLATFORM_ERROR_PARAM_NULL;
    d6b0:	f46f 40e0 	mvn.w	r0, #28672	; 0x7000
    d6b4:	e7f2      	b.n	d69c <mutex_unlock_platform+0x34>
            return NRF_CC3XX_PLATFORM_ERROR_MUTEX_NOT_INITIALIZED;
    d6b6:	4803      	ldr	r0, [pc, #12]	; (d6c4 <mutex_unlock_platform+0x5c>)
    d6b8:	e7f0      	b.n	d69c <mutex_unlock_platform+0x34>
    d6ba:	bf00      	nop
    d6bc:	ffff8fe9 	.word	0xffff8fe9
    d6c0:	50030000 	.word	0x50030000
    d6c4:	ffff8fea 	.word	0xffff8fea

0000d6c8 <mutex_free_platform>:
static void mutex_free_platform(nrf_cc3xx_platform_mutex_t *mutex) {
    d6c8:	b510      	push	{r4, lr}
    if (mutex == NULL) {
    d6ca:	4604      	mov	r4, r0
    d6cc:	b918      	cbnz	r0, d6d6 <mutex_free_platform+0xe>
        platform_abort_apis.abort_fn(
    d6ce:	4b0d      	ldr	r3, [pc, #52]	; (d704 <mutex_free_platform+0x3c>)
    d6d0:	480d      	ldr	r0, [pc, #52]	; (d708 <mutex_free_platform+0x40>)
    d6d2:	685b      	ldr	r3, [r3, #4]
    d6d4:	4798      	blx	r3
    if (mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_IS_ATOMIC ||
    d6d6:	6861      	ldr	r1, [r4, #4]
    d6d8:	2908      	cmp	r1, #8
    d6da:	d00d      	beq.n	d6f8 <mutex_free_platform+0x30>
    if (mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID) {
    d6dc:	f031 0304 	bics.w	r3, r1, #4
    d6e0:	d00a      	beq.n	d6f8 <mutex_free_platform+0x30>
    if ((mutex->flags & NRF_CC3XX_PLATFORM_MUTEX_MASK_IS_ALLOCATED) != 0) {
    d6e2:	f011 0102 	ands.w	r1, r1, #2
    d6e6:	d008      	beq.n	d6fa <mutex_free_platform+0x32>
        k_mem_slab_free(&mutex_slab, &mutex->mutex);
    d6e8:	4621      	mov	r1, r4
    d6ea:	4808      	ldr	r0, [pc, #32]	; (d70c <mutex_free_platform+0x44>)
    d6ec:	f001 fc08 	bl	ef00 <k_mem_slab_free>
        mutex->mutex = NULL;
    d6f0:	2300      	movs	r3, #0
    d6f2:	6023      	str	r3, [r4, #0]
    mutex->flags = NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID;
    d6f4:	2300      	movs	r3, #0
    d6f6:	6063      	str	r3, [r4, #4]
}
    d6f8:	bd10      	pop	{r4, pc}
        memset(mutex->mutex, 0, sizeof(struct k_mutex));
    d6fa:	2214      	movs	r2, #20
    d6fc:	6820      	ldr	r0, [r4, #0]
    d6fe:	f002 ffa3 	bl	10648 <memset>
    d702:	e7f7      	b.n	d6f4 <mutex_free_platform+0x2c>
    d704:	20000048 	.word	0x20000048
    d708:	00011008 	.word	0x00011008
    d70c:	20000334 	.word	0x20000334

0000d710 <mutex_init_platform>:
static void mutex_init_platform(nrf_cc3xx_platform_mutex_t *mutex) {
    d710:	b510      	push	{r4, lr}
    if (mutex == NULL) {
    d712:	4604      	mov	r4, r0
    d714:	b918      	cbnz	r0, d71e <mutex_init_platform+0xe>
        platform_abort_apis.abort_fn(
    d716:	4b16      	ldr	r3, [pc, #88]	; (d770 <mutex_init_platform+0x60>)
    d718:	4816      	ldr	r0, [pc, #88]	; (d774 <mutex_init_platform+0x64>)
    d71a:	685b      	ldr	r3, [r3, #4]
    d71c:	4798      	blx	r3
    if (mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_IS_ATOMIC ||
    d71e:	6863      	ldr	r3, [r4, #4]
    d720:	2b04      	cmp	r3, #4
    d722:	d023      	beq.n	d76c <mutex_init_platform+0x5c>
    d724:	2b08      	cmp	r3, #8
    d726:	d021      	beq.n	d76c <mutex_init_platform+0x5c>
    if (mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID &&
    d728:	b9cb      	cbnz	r3, d75e <mutex_init_platform+0x4e>
    d72a:	6823      	ldr	r3, [r4, #0]
    d72c:	b9bb      	cbnz	r3, d75e <mutex_init_platform+0x4e>
        ret = k_mem_slab_alloc(&mutex_slab, &mutex->mutex, K_FOREVER);
    d72e:	f04f 32ff 	mov.w	r2, #4294967295
    d732:	f04f 33ff 	mov.w	r3, #4294967295
    d736:	4621      	mov	r1, r4
    d738:	480f      	ldr	r0, [pc, #60]	; (d778 <mutex_init_platform+0x68>)
    d73a:	f001 fbaf 	bl	ee9c <k_mem_slab_alloc>
        if(ret != 0 || mutex->mutex == NULL)
    d73e:	b908      	cbnz	r0, d744 <mutex_init_platform+0x34>
    d740:	6823      	ldr	r3, [r4, #0]
    d742:	b91b      	cbnz	r3, d74c <mutex_init_platform+0x3c>
            platform_abort_apis.abort_fn(
    d744:	4b0a      	ldr	r3, [pc, #40]	; (d770 <mutex_init_platform+0x60>)
    d746:	480d      	ldr	r0, [pc, #52]	; (d77c <mutex_init_platform+0x6c>)
    d748:	685b      	ldr	r3, [r3, #4]
    d74a:	4798      	blx	r3
        memset(mutex->mutex, 0, sizeof(struct k_mutex));
    d74c:	2214      	movs	r2, #20
    d74e:	2100      	movs	r1, #0
    d750:	6820      	ldr	r0, [r4, #0]
    d752:	f002 ff79 	bl	10648 <memset>
        mutex->flags |= NRF_CC3XX_PLATFORM_MUTEX_MASK_IS_ALLOCATED;
    d756:	6863      	ldr	r3, [r4, #4]
    d758:	f043 0302 	orr.w	r3, r3, #2
    d75c:	6063      	str	r3, [r4, #4]
    p_mutex = (struct k_mutex *)mutex->mutex;
    d75e:	6820      	ldr	r0, [r4, #0]
	return z_impl_k_mutex_init(mutex);
    d760:	f003 f8f2 	bl	10948 <z_impl_k_mutex_init>
    mutex->flags |= NRF_CC3XX_PLATFORM_MUTEX_MASK_IS_VALID;
    d764:	6863      	ldr	r3, [r4, #4]
    d766:	f043 0301 	orr.w	r3, r3, #1
    d76a:	6063      	str	r3, [r4, #4]
}
    d76c:	bd10      	pop	{r4, pc}
    d76e:	bf00      	nop
    d770:	20000048 	.word	0x20000048
    d774:	00011008 	.word	0x00011008
    d778:	20000334 	.word	0x20000334
    d77c:	0001102e 	.word	0x0001102e

0000d780 <mutex_lock_platform>:
static int32_t mutex_lock_platform(nrf_cc3xx_platform_mutex_t *mutex) {
    d780:	b508      	push	{r3, lr}
    if(mutex == NULL) {
    d782:	b340      	cbz	r0, d7d6 <mutex_lock_platform+0x56>
    switch (mutex->flags) {
    d784:	6843      	ldr	r3, [r0, #4]
    d786:	2b04      	cmp	r3, #4
    d788:	d00b      	beq.n	d7a2 <mutex_lock_platform+0x22>
    d78a:	2b08      	cmp	r3, #8
    d78c:	d016      	beq.n	d7bc <mutex_lock_platform+0x3c>
        if (mutex->flags == NRF_CC3XX_PLATFORM_MUTEX_MASK_INVALID) {
    d78e:	b303      	cbz	r3, d7d2 <mutex_lock_platform+0x52>
        p_mutex = (struct k_mutex *)mutex->mutex;
    d790:	6800      	ldr	r0, [r0, #0]
	return z_impl_k_mutex_lock(mutex, timeout);
    d792:	f04f 32ff 	mov.w	r2, #4294967295
    d796:	f04f 33ff 	mov.w	r3, #4294967295
    d79a:	f001 fbdb 	bl	ef54 <z_impl_k_mutex_lock>
        if (ret == 0) {
    d79e:	b158      	cbz	r0, d7b8 <mutex_lock_platform+0x38>
    d7a0:	e015      	b.n	d7ce <mutex_lock_platform+0x4e>
    d7a2:	2201      	movs	r2, #1
    d7a4:	6803      	ldr	r3, [r0, #0]
    d7a6:	e8d3 1fef 	ldaex	r1, [r3]
    d7aa:	2900      	cmp	r1, #0
    d7ac:	d103      	bne.n	d7b6 <mutex_lock_platform+0x36>
    d7ae:	e8c3 2fe0 	stlex	r0, r2, [r3]
    d7b2:	2800      	cmp	r0, #0
    d7b4:	d1f7      	bne.n	d7a6 <mutex_lock_platform+0x26>
                       NRF_CC3XX_PLATFORM_SUCCESS :
    d7b6:	d10a      	bne.n	d7ce <mutex_lock_platform+0x4e>
    d7b8:	2000      	movs	r0, #0
}
    d7ba:	bd08      	pop	{r3, pc}
        return nrf_mutex_lock(NRF_MUTEX, *((uint8_t *)mutex->mutex)) ?
    d7bc:	6803      	ldr	r3, [r0, #0]
    return (p_reg->MUTEX[mutex] == MUTEX_MUTEX_MUTEX_Unlocked);
    d7be:	4a07      	ldr	r2, [pc, #28]	; (d7dc <mutex_lock_platform+0x5c>)
    d7c0:	781b      	ldrb	r3, [r3, #0]
    d7c2:	f503 7380 	add.w	r3, r3, #256	; 0x100
    d7c6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
                       NRF_CC3XX_PLATFORM_SUCCESS :
    d7ca:	2b00      	cmp	r3, #0
    d7cc:	d0f4      	beq.n	d7b8 <mutex_lock_platform+0x38>
                       NRF_CC3XX_PLATFORM_SUCCESS :
    d7ce:	4804      	ldr	r0, [pc, #16]	; (d7e0 <mutex_lock_platform+0x60>)
    d7d0:	e7f3      	b.n	d7ba <mutex_lock_platform+0x3a>
            return NRF_CC3XX_PLATFORM_ERROR_MUTEX_NOT_INITIALIZED;
    d7d2:	4804      	ldr	r0, [pc, #16]	; (d7e4 <mutex_lock_platform+0x64>)
    d7d4:	e7f1      	b.n	d7ba <mutex_lock_platform+0x3a>
        return NRF_CC3XX_PLATFORM_ERROR_PARAM_NULL;
    d7d6:	f46f 40e0 	mvn.w	r0, #28672	; 0x7000
    d7da:	e7ee      	b.n	d7ba <mutex_lock_platform+0x3a>
    d7dc:	50030000 	.word	0x50030000
    d7e0:	ffff8fe9 	.word	0xffff8fe9
    d7e4:	ffff8fea 	.word	0xffff8fea

0000d7e8 <nrf_cc3xx_platform_mutex_init>:
};

/** @brief Function to initialize the nrf_cc3xx_platform mutex APIs
 */
void nrf_cc3xx_platform_mutex_init(void)
{
    d7e8:	b508      	push	{r3, lr}
    k_mem_slab_init(&mutex_slab,
    d7ea:	4906      	ldr	r1, [pc, #24]	; (d804 <nrf_cc3xx_platform_mutex_init+0x1c>)
    d7ec:	2340      	movs	r3, #64	; 0x40
    d7ee:	2214      	movs	r2, #20
    d7f0:	4805      	ldr	r0, [pc, #20]	; (d808 <nrf_cc3xx_platform_mutex_init+0x20>)
    d7f2:	f003 f88e 	bl	10912 <k_mem_slab_init>
                mutex_slab_buffer,
                sizeof(struct k_mutex),
                NUM_MUTEXES);

    nrf_cc3xx_platform_set_mutexes(&mutex_apis, &mutexes);
}
    d7f6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    nrf_cc3xx_platform_set_mutexes(&mutex_apis, &mutexes);
    d7fa:	4904      	ldr	r1, [pc, #16]	; (d80c <nrf_cc3xx_platform_mutex_init+0x24>)
    d7fc:	4804      	ldr	r0, [pc, #16]	; (d810 <nrf_cc3xx_platform_mutex_init+0x28>)
    d7fe:	f002 bb2b 	b.w	fe58 <nrf_cc3xx_platform_set_mutexes>
    d802:	bf00      	nop
    d804:	20000350 	.word	0x20000350
    d808:	20000334 	.word	0x20000334
    d80c:	00010e50 	.word	0x00010e50
    d810:	00010e40 	.word	0x00010e40

0000d814 <arch_swap>:
 * as BASEPRI is not available.
 */
int arch_swap(unsigned int key)
{
	/* store off key and return value */
	_current->arch.basepri = key;
    d814:	4a09      	ldr	r2, [pc, #36]	; (d83c <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
    d816:	490a      	ldr	r1, [pc, #40]	; (d840 <arch_swap+0x2c>)
	_current->arch.basepri = key;
    d818:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
    d81a:	6809      	ldr	r1, [r1, #0]
	_current->arch.basepri = key;
    d81c:	6798      	str	r0, [r3, #120]	; 0x78
	_current->arch.swap_return_value = _k_neg_eagain;
    d81e:	67d9      	str	r1, [r3, #124]	; 0x7c

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    d820:	4908      	ldr	r1, [pc, #32]	; (d844 <arch_swap+0x30>)
    d822:	684b      	ldr	r3, [r1, #4]
    d824:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    d828:	604b      	str	r3, [r1, #4]
    d82a:	2300      	movs	r3, #0
    d82c:	f383 8811 	msr	BASEPRI, r3
    d830:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
    d834:	6893      	ldr	r3, [r2, #8]
}
    d836:	6fd8      	ldr	r0, [r3, #124]	; 0x7c
    d838:	4770      	bx	lr
    d83a:	bf00      	nop
    d83c:	20000908 	.word	0x20000908
    d840:	00010f04 	.word	0x00010f04
    d844:	e000ed00 	.word	0xe000ed00

0000d848 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_TRACING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
    d848:	4913      	ldr	r1, [pc, #76]	; (d898 <z_arm_pendsv+0x50>)
    ldr r2, [r1, #_kernel_offset_to_current]
    d84a:	688a      	ldr	r2, [r1, #8]

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
    d84c:	f04f 0038 	mov.w	r0, #56	; 0x38
    add r0, r2
    d850:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
    d852:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
    d856:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    d85a:	2020      	movs	r0, #32
    msr BASEPRI, r0
    d85c:	f380 8811 	msr	BASEPRI, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
    d860:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
    d864:	4f0d      	ldr	r7, [pc, #52]	; (d89c <z_arm_pendsv+0x54>)
    ldr v3, =_SCS_ICSR_UNPENDSV
    d866:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
    d86a:	6a8a      	ldr	r2, [r1, #40]	; 0x28

    str r2, [r1, #_kernel_offset_to_current]
    d86c:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
    d86e:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
    d870:	6f90      	ldr	r0, [r2, #120]	; 0x78
    movs r3, #0
    d872:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
    d874:	6793      	str	r3, [r2, #120]	; 0x78
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
    d876:	f380 8811 	msr	BASEPRI, r0
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
    d87a:	f102 0038 	add.w	r0, r2, #56	; 0x38
    ldmia r0, {v1-v8, ip}
    d87e:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
    d882:	f38c 8809 	msr	PSP, ip
#endif

#ifdef CONFIG_BUILTIN_STACK_GUARD
    /* r2 contains k_thread */
    add r0, r2, #0
    d886:	f102 0000 	add.w	r0, r2, #0
    push {r2, lr}
    d88a:	b504      	push	{r2, lr}
    bl configure_builtin_stack_guard
    d88c:	f002 fe5e 	bl	1054c <configure_builtin_stack_guard>
    pop {r2, lr}
    d890:	e8bd 4004 	ldmia.w	sp!, {r2, lr}

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (_IntExit or z_arm_svc)
     */
    bx lr
    d894:	4770      	bx	lr
    d896:	0000      	.short	0x0000
    ldr r1, =_kernel
    d898:	20000908 	.word	0x20000908
    ldr v4, =_SCS_ICSR
    d89c:	e000ed04 	.word	0xe000ed04

0000d8a0 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #0x4    /* did we come from thread mode ? */
    d8a0:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
    d8a4:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
    d8a6:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
    d8aa:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
    d8ae:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
    d8b0:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
    d8b4:	2902      	cmp	r1, #2
    beq _oops
    d8b6:	d0ff      	beq.n	d8b8 <_oops>

0000d8b8 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
    d8b8:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
    d8ba:	f002 fe4d 	bl	10558 <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
    d8be:	bd01      	pop	{r0, pc}

0000d8c0 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
    d8c0:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
    d8c2:	2b00      	cmp	r3, #0
    d8c4:	db08      	blt.n	d8d8 <arch_irq_enable+0x18>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    d8c6:	2201      	movs	r2, #1
    d8c8:	f000 001f 	and.w	r0, r0, #31
    d8cc:	fa02 f000 	lsl.w	r0, r2, r0
    d8d0:	4a02      	ldr	r2, [pc, #8]	; (d8dc <arch_irq_enable+0x1c>)
    d8d2:	095b      	lsrs	r3, r3, #5
    d8d4:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
    d8d8:	4770      	bx	lr
    d8da:	bf00      	nop
    d8dc:	e000e100 	.word	0xe000e100

0000d8e0 <arch_irq_is_enabled>:
	NVIC_DisableIRQ((IRQn_Type)irq);
}

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
    d8e0:	4b05      	ldr	r3, [pc, #20]	; (d8f8 <arch_irq_is_enabled+0x18>)
    d8e2:	0942      	lsrs	r2, r0, #5
    d8e4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    d8e8:	2301      	movs	r3, #1
    d8ea:	f000 001f 	and.w	r0, r0, #31
    d8ee:	fa03 f000 	lsl.w	r0, r3, r0
}
    d8f2:	4010      	ands	r0, r2
    d8f4:	4770      	bx	lr
    d8f6:	bf00      	nop
    d8f8:	e000e100 	.word	0xe000e100

0000d8fc <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
    d8fc:	b243      	sxtb	r3, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
    d8fe:	2b00      	cmp	r3, #0
	prio += _IRQ_PRIO_OFFSET;
    d900:	f101 0101 	add.w	r1, r1, #1
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    d904:	bfac      	ite	ge
    d906:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    d90a:	4b06      	ldrlt	r3, [pc, #24]	; (d924 <z_arm_irq_priority_set+0x28>)
    d90c:	ea4f 1141 	mov.w	r1, r1, lsl #5
    d910:	b2c9      	uxtb	r1, r1
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    d912:	bfab      	itete	ge
    d914:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    d918:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    d91c:	f883 1300 	strbge.w	r1, [r3, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    d920:	5419      	strblt	r1, [r3, r0]
}
    d922:	4770      	bx	lr
    d924:	e000ed14 	.word	0xe000ed14

0000d928 <arch_new_thread>:

#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	iframe->pc &= 0xfffffffe;
#endif
	iframe->a1 = (uint32_t)entry;
    d928:	f842 3c20 	str.w	r3, [r2, #-32]
	iframe->a2 = (uint32_t)p1;
    d92c:	9b00      	ldr	r3, [sp, #0]
	iframe->pc &= 0xfffffffe;
    d92e:	490b      	ldr	r1, [pc, #44]	; (d95c <arch_new_thread+0x34>)
	iframe->a2 = (uint32_t)p1;
    d930:	f842 3c1c 	str.w	r3, [r2, #-28]
	iframe->a3 = (uint32_t)p2;
    d934:	9b01      	ldr	r3, [sp, #4]
	iframe->pc &= 0xfffffffe;
    d936:	f021 0101 	bic.w	r1, r1, #1
	iframe->a3 = (uint32_t)p2;
    d93a:	f842 3c18 	str.w	r3, [r2, #-24]
	iframe->a4 = (uint32_t)p3;
    d93e:	9b02      	ldr	r3, [sp, #8]
	iframe->pc &= 0xfffffffe;
    d940:	f842 1c08 	str.w	r1, [r2, #-8]
	iframe->a4 = (uint32_t)p3;
    d944:	f842 3c14 	str.w	r3, [r2, #-20]

#if defined(CONFIG_CPU_CORTEX_M)
	iframe->xpsr =
    d948:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
    d94c:	f842 3c04 	str.w	r3, [r2, #-4]
	iframe->xpsr |= T_BIT;
#endif /* CONFIG_COMPILER_ISA_THUMB2 */
#endif /* CONFIG_CPU_CORTEX_M */

	thread->callee_saved.psp = (uint32_t)iframe;
	thread->arch.basepri = 0;
    d950:	2300      	movs	r3, #0
	iframe = Z_STACK_PTR_TO_FRAME(struct __basic_sf, stack_ptr);
    d952:	3a20      	subs	r2, #32
	thread->callee_saved.psp = (uint32_t)iframe;
    d954:	6582      	str	r2, [r0, #88]	; 0x58
	thread->arch.basepri = 0;
    d956:	6783      	str	r3, [r0, #120]	; 0x78
#endif
	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
    d958:	4770      	bx	lr
    d95a:	bf00      	nop
    d95c:	00010165 	.word	0x00010165

0000d960 <arch_switch_to_main_thread>:
#endif
}

void arch_switch_to_main_thread(struct k_thread *main_thread, char *stack_ptr,
				k_thread_entry_t _main)
{
    d960:	4604      	mov	r4, r0
    d962:	b508      	push	{r3, lr}
    d964:	460e      	mov	r6, r1
    d966:	4615      	mov	r5, r2
	z_arm_configure_static_mpu_regions();
    d968:	f000 fa0a 	bl	dd80 <z_arm_configure_static_mpu_regions>
	z_arm_prepare_switch_to_main();

	_current = main_thread;
    d96c:	4b08      	ldr	r3, [pc, #32]	; (d990 <arch_switch_to_main_thread+0x30>)
    d96e:	609c      	str	r4, [r3, #8]
#if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
    (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
  // without main extensions, the non-secure PSPLIM is RAZ/WI
  (void)ProcStackPtrLimit;
#else
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
    d970:	6ea3      	ldr	r3, [r4, #104]	; 0x68
    d972:	f383 880b 	msr	PSPLIM, r3

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
    d976:	4628      	mov	r0, r5
    d978:	f386 8809 	msr	PSP, r6
    d97c:	2100      	movs	r1, #0
    d97e:	b663      	cpsie	if
    d980:	f381 8811 	msr	BASEPRI, r1
    d984:	f3bf 8f6f 	isb	sy
    d988:	2200      	movs	r2, #0
    d98a:	2300      	movs	r3, #0
    d98c:	f002 fbea 	bl	10164 <z_thread_entry>
	:
	: "r" (_main), "r" (stack_ptr)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
    d990:	20000908 	.word	0x20000908

0000d994 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
    d994:	4901      	ldr	r1, [pc, #4]	; (d99c <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
    d996:	2210      	movs	r2, #16
	str	r2, [r1]
    d998:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
    d99a:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
    d99c:	e000ed10 	.word	0xe000ed10

0000d9a0 <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
    d9a0:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
    d9a2:	4040      	eors	r0, r0
	msr	BASEPRI, r0
    d9a4:	f380 8811 	msr	BASEPRI, r0
	isb
    d9a8:	f3bf 8f6f 	isb	sy

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
    d9ac:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
    d9b0:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
    d9b2:	b662      	cpsie	i
	isb
    d9b4:	f3bf 8f6f 	isb	sy

	bx	lr
    d9b8:	4770      	bx	lr
    d9ba:	bf00      	nop

0000d9bc <arch_cpu_atomic_idle>:

	/*
	 * Lock PRIMASK while sleeping: wfe will still get interrupted by
	 * incoming interrupts but the CPU will not service them right away.
	 */
	cpsid	i
    d9bc:	b672      	cpsid	i
	cpsie	i
_irq_disabled:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* r1: zero, for setting BASEPRI (needs a register) */
	eors.n	r1, r1
    d9be:	4049      	eors	r1, r1

	/* unlock BASEPRI so wfe gets interrupted by incoming interrupts */
	msr	BASEPRI, r1
    d9c0:	f381 8811 	msr	BASEPRI, r1

	wfe
    d9c4:	bf20      	wfe

	msr	BASEPRI, r0
    d9c6:	f380 8811 	msr	BASEPRI, r0
	cpsie	i
    d9ca:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	bx	lr
    d9cc:	4770      	bx	lr
    d9ce:	bf00      	nop

0000d9d0 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
    d9d0:	bf30      	wfi
    b z_SysNmiOnReset
    d9d2:	f7ff bffd 	b.w	d9d0 <z_SysNmiOnReset>
    d9d6:	bf00      	nop

0000d9d8 <z_arm_prep_c>:
#else
#define VECTOR_ADDRESS CONFIG_SRAM_BASE_ADDRESS
#endif
static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    d9d8:	4a0e      	ldr	r2, [pc, #56]	; (da14 <z_arm_prep_c+0x3c>)
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
    d9da:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    d9dc:	4b0e      	ldr	r3, [pc, #56]	; (da18 <z_arm_prep_c+0x40>)
    d9de:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
    d9e2:	609a      	str	r2, [r3, #8]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
    d9e4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    d9e8:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
    d9ec:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    d9f0:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
    d9f4:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  __ASM volatile ("MRS %0, control" : "=r" (result) );
    d9f8:	f3ef 8314 	mrs	r3, CONTROL
	__set_CONTROL(__get_CONTROL() & (~(CONTROL_FPCA_Msk)));
    d9fc:	f023 0304 	bic.w	r3, r3, #4
  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
    da00:	f383 8814 	msr	CONTROL, r3
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
    da04:	f001 f984 	bl	ed10 <z_bss_zero>
	z_data_copy();
    da08:	f001 fff8 	bl	f9fc <z_data_copy>
#if defined(CONFIG_ARMV7_R) && defined(CONFIG_INIT_STACKS)
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
    da0c:	f000 f98a 	bl	dd24 <z_arm_interrupt_init>
	z_cstart();
    da10:	f001 f9a2 	bl	ed58 <z_cstart>
    da14:	0000c200 	.word	0x0000c200
    da18:	e000ed00 	.word	0xe000ed00

0000da1c <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
    da1c:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
    da1e:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
    da20:	4a0b      	ldr	r2, [pc, #44]	; (da50 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
    da22:	6a50      	ldr	r0, [r2, #36]	; 0x24
	cmp r0, #0
    da24:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_pm_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
    da26:	bf1e      	ittt	ne
	movne	r1, #0
    da28:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
    da2a:	6251      	strne	r1, [r2, #36]	; 0x24
		blne	z_pm_save_idle_exit
    da2c:	f002 ff6f 	blne	1090e <z_pm_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
    da30:	b662      	cpsie	i
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
    da32:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
    da36:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
    da3a:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	 * interface function.
	 */
	cpsie i
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
    da3e:	4905      	ldr	r1, [pc, #20]	; (da54 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
    da40:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
    da42:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
    da44:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
    da46:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
    da4a:	4903      	ldr	r1, [pc, #12]	; (da58 <_isr_wrapper+0x3c>)
	bx r1
    da4c:	4708      	bx	r1
    da4e:	0000      	.short	0x0000
	ldr r2, =_kernel
    da50:	20000908 	.word	0x20000908
	ldr r1, =_sw_isr_table
    da54:	00010bc4 	.word	0x00010bc4
	ldr r1, =z_arm_int_exit
    da58:	0000dc79 	.word	0x0000dc79

0000da5c <__start>:
 */
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
    /* Reset CONTROL register */
    movs.n r0, #0
    da5c:	2000      	movs	r0, #0
    msr CONTROL, r0
    da5e:	f380 8814 	msr	CONTROL, r0
    isb
    da62:	f3bf 8f6f 	isb	sy
#if defined(CONFIG_CPU_CORTEX_M_HAS_SPLIM)
    /* Clear SPLIM registers */
    movs.n r0, #0
    da66:	2000      	movs	r0, #0
    msr MSPLIM, r0
    da68:	f380 880a 	msr	MSPLIM, r0
    msr PSPLIM, r0
    da6c:	f380 880b 	msr	PSPLIM, r0
#endif /* CONFIG_CPU_CORTEX_M_HAS_SPLIM */

#endif /* CONFIG_INIT_ARCH_HW_AT_BOOT */

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_platform_init
    da70:	f002 fcc0 	bl	103f4 <z_platform_init>
#endif

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
#if defined(CONFIG_CPU_HAS_ARM_MPU)
    /* Disable MPU */
    movs.n r0, #0
    da74:	2000      	movs	r0, #0
    ldr r1, =_SCS_MPU_CTRL
    da76:	490e      	ldr	r1, [pc, #56]	; (dab0 <__start+0x54>)
    str r0, [r1]
    da78:	6008      	str	r0, [r1, #0]
    dsb
    da7a:	f3bf 8f4f 	dsb	sy
#endif /* CONFIG_CPU_HAS_ARM_MPU */
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
    da7e:	480d      	ldr	r0, [pc, #52]	; (dab4 <__start+0x58>)
    msr msp, r0
    da80:	f380 8808 	msr	MSP, r0

    /* Initialize core architecture registers and system blocks */
    bl z_arm_init_arch_hw_at_boot
    da84:	f000 f928 	bl	dcd8 <z_arm_init_arch_hw_at_boot>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    da88:	2020      	movs	r0, #32
    msr BASEPRI, r0
    da8a:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
    da8e:	480a      	ldr	r0, [pc, #40]	; (dab8 <__start+0x5c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
    da90:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
    da94:	1840      	adds	r0, r0, r1
    msr PSP, r0
    da96:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
    da9a:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
    da9e:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
    daa0:	4308      	orrs	r0, r1
    msr CONTROL, r0
    daa2:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
    daa6:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
    daaa:	f7ff ff95 	bl	d9d8 <z_arm_prep_c>
    daae:	0000      	.short	0x0000
    ldr r1, =_SCS_MPU_CTRL
    dab0:	e000ed94 	.word	0xe000ed94
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
    dab4:	20000d68 	.word	0x20000d68
    ldr r0, =z_interrupt_stacks
    dab8:	20000ea8 	.word	0x20000ea8

0000dabc <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
    dabc:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
    dac0:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
    dac4:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
    dac6:	4672      	mov	r2, lr
	bl z_arm_fault
    dac8:	f000 f856 	bl	db78 <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
    dacc:	bd01      	pop	{r0, pc}
    dace:	bf00      	nop

0000dad0 <mem_manage_fault.isra.0>:
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	uint32_t mmfar = -EINVAL;

	PR_FAULT_INFO("***** MPU FAULT *****");

	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    dad0:	4b0e      	ldr	r3, [pc, #56]	; (db0c <mem_manage_fault.isra.0+0x3c>)
    dad2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Stacking error (context area might be"
			" not valid)");
	}
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
    dad4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Unstacking error");
	}
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
    dad6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    dad8:	0792      	lsls	r2, r2, #30
    dada:	d508      	bpl.n	daee <mem_manage_fault.isra.0+0x1e>
		 * The MMFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another higher
		 * priority exception might change the MMFAR value.
		 */
		uint32_t temp = SCB->MMFAR;
    dadc:	6b5a      	ldr	r2, [r3, #52]	; 0x34

		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
    dade:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    dae0:	0612      	lsls	r2, r2, #24
    dae2:	d504      	bpl.n	daee <mem_manage_fault.isra.0+0x1e>
			mmfar = temp;
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
			if (from_hard_fault) {
    dae4:	b118      	cbz	r0, daee <mem_manage_fault.isra.0+0x1e>
				/* clear SCB_MMAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
    dae6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    dae8:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    daec:	629a      	str	r2, [r3, #40]	; 0x28

	/* clear MMFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;

	/* Assess whether system shall ignore/recover from this MPU fault. */
	*recoverable = memory_fault_recoverable(esf);
    daee:	2000      	movs	r0, #0
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
    daf0:	4b06      	ldr	r3, [pc, #24]	; (db0c <mem_manage_fault.isra.0+0x3c>)
    daf2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
    daf4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
    daf6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    daf8:	06d2      	lsls	r2, r2, #27
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
    dafa:	bf58      	it	pl
    dafc:	6a9a      	ldrpl	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
    dafe:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    db00:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
    db04:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    db06:	7008      	strb	r0, [r1, #0]

	return reason;
}
    db08:	4770      	bx	lr
    db0a:	bf00      	nop
    db0c:	e000ed00 	.word	0xe000ed00

0000db10 <bus_fault.isra.0>:
{
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** BUS FAULT *****");

	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
    db10:	4b0d      	ldr	r3, [pc, #52]	; (db48 <bus_fault.isra.0+0x38>)
    db12:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Stacking error");
	}
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
    db14:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Unstacking error");
	}
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
    db16:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    db18:	0592      	lsls	r2, r2, #22
    db1a:	d508      	bpl.n	db2e <bus_fault.isra.0+0x1e>
		 * The BFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another
		 * higher priority exception might change the BFAR value.
		 */
		STORE_xFAR(bfar, SCB->BFAR);
    db1c:	6b9a      	ldr	r2, [r3, #56]	; 0x38

		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
    db1e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    db20:	0412      	lsls	r2, r2, #16
    db22:	d504      	bpl.n	db2e <bus_fault.isra.0+0x1e>
			PR_EXC("  BFAR Address: 0x%x", bfar);
			if (from_hard_fault) {
    db24:	b118      	cbz	r0, db2e <bus_fault.isra.0+0x1e>
				/* clear SCB_CFSR_BFAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
    db26:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    db28:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    db2c:	629a      	str	r2, [r3, #40]	; 0x28
#endif /* defined(CONFIG_ARM_MPU) && defined(CONFIG_CPU_HAS_NXP_MPU) */

	/* clear BFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;

	*recoverable = memory_fault_recoverable(esf);
    db2e:	2000      	movs	r0, #0
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
    db30:	4b05      	ldr	r3, [pc, #20]	; (db48 <bus_fault.isra.0+0x38>)
    db32:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
    db34:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    db36:	05d2      	lsls	r2, r2, #23
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
    db38:	bf58      	it	pl
    db3a:	6a9a      	ldrpl	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    db3c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    db3e:	f442 427f 	orr.w	r2, r2, #65280	; 0xff00
    db42:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
    db44:	7008      	strb	r0, [r1, #0]

	return reason;
}
    db46:	4770      	bx	lr
    db48:	e000ed00 	.word	0xe000ed00

0000db4c <usage_fault.isra.0>:
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    db4c:	4b09      	ldr	r3, [pc, #36]	; (db74 <usage_fault.isra.0+0x28>)
    db4e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Division by zero");
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
    db50:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Unaligned memory access");
	}
#if defined(CONFIG_ARMV8_M_MAINLINE)
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
    db52:	6a98      	ldr	r0, [r3, #40]	; 0x28
		 */
		reason = K_ERR_STACK_CHK_FAIL;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
    db54:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  No coprocessor instructions");
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
    db56:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
    db58:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Illegal use of the EPSR");
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
    db5a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    db5c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
    db5e:	f410 1080 	ands.w	r0, r0, #1048576	; 0x100000
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    db62:	ea6f 4202 	mvn.w	r2, r2, lsl #16
    db66:	ea6f 4212 	mvn.w	r2, r2, lsr #16

	return reason;
}
    db6a:	bf18      	it	ne
    db6c:	2002      	movne	r0, #2
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    db6e:	629a      	str	r2, [r3, #40]	; 0x28
}
    db70:	4770      	bx	lr
    db72:	bf00      	nop
    db74:	e000ed00 	.word	0xe000ed00

0000db78 <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
    db78:	b570      	push	{r4, r5, r6, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    db7a:	4b36      	ldr	r3, [pc, #216]	; (dc54 <z_arm_fault+0xdc>)
{
    db7c:	460e      	mov	r6, r1
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    db7e:	685b      	ldr	r3, [r3, #4]
    db80:	2500      	movs	r5, #0
{
    db82:	b08a      	sub	sp, #40	; 0x28
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    db84:	f3c3 0308 	ubfx	r3, r3, #0, #9
    db88:	f385 8811 	msr	BASEPRI, r5
    db8c:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
    db90:	f002 417f 	and.w	r1, r2, #4278190080	; 0xff000000
    db94:	f1b1 4f7f 	cmp.w	r1, #4278190080	; 0xff000000
    db98:	d111      	bne.n	dbbe <z_arm_fault+0x46>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
    db9a:	f002 010c 	and.w	r1, r2, #12
    db9e:	2908      	cmp	r1, #8
    dba0:	d00d      	beq.n	dbbe <z_arm_fault+0x46>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
    dba2:	0711      	lsls	r1, r2, #28
    dba4:	d401      	bmi.n	dbaa <z_arm_fault+0x32>
			ptr_esf = (z_arch_esf_t *)msp;
    dba6:	4606      	mov	r6, r0
			*nested_exc = true;
    dba8:	2501      	movs	r5, #1
	*recoverable = false;
    dbaa:	2200      	movs	r2, #0
    dbac:	3b03      	subs	r3, #3
    dbae:	f88d 2007 	strb.w	r2, [sp, #7]
	switch (fault) {
    dbb2:	2b03      	cmp	r3, #3
    dbb4:	d847      	bhi.n	dc46 <z_arm_fault+0xce>
    dbb6:	e8df f003 	tbb	[pc, r3]
    dbba:	3e04      	.short	0x3e04
    dbbc:	3b42      	.short	0x3b42
		return NULL;
    dbbe:	462e      	mov	r6, r5
    dbc0:	e7f3      	b.n	dbaa <z_arm_fault+0x32>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    dbc2:	4b24      	ldr	r3, [pc, #144]	; (dc54 <z_arm_fault+0xdc>)
    dbc4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    dbc6:	0792      	lsls	r2, r2, #30
    dbc8:	d43d      	bmi.n	dc46 <z_arm_fault+0xce>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
    dbca:	6adc      	ldr	r4, [r3, #44]	; 0x2c
    dbcc:	f014 4480 	ands.w	r4, r4, #1073741824	; 0x40000000
    dbd0:	d008      	beq.n	dbe4 <z_arm_fault+0x6c>
		if (SCB_MMFSR != 0) {
    dbd2:	3328      	adds	r3, #40	; 0x28
    dbd4:	781b      	ldrb	r3, [r3, #0]
    dbd6:	b1eb      	cbz	r3, dc14 <z_arm_fault+0x9c>
			reason = mem_manage_fault(esf, 1, recoverable);
    dbd8:	2001      	movs	r0, #1
    dbda:	f10d 0107 	add.w	r1, sp, #7
		reason = mem_manage_fault(esf, 0, recoverable);
    dbde:	f7ff ff77 	bl	dad0 <mem_manage_fault.isra.0>
		reason = usage_fault(esf);
    dbe2:	4604      	mov	r4, r0
#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
    dbe4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    dbe8:	b993      	cbnz	r3, dc10 <z_arm_fault+0x98>
		return;
	}

	/* Copy ESF */
#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
    dbea:	2220      	movs	r2, #32
    dbec:	4631      	mov	r1, r6
    dbee:	a802      	add	r0, sp, #8
    dbf0:	f002 fcff 	bl	105f2 <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
    dbf4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    dbf6:	b345      	cbz	r5, dc4a <z_arm_fault+0xd2>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
    dbf8:	f3c3 0208 	ubfx	r2, r3, #0, #9
    dbfc:	b922      	cbnz	r2, dc08 <z_arm_fault+0x90>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
    dbfe:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    dc02:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    dc06:	9309      	str	r3, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
    dc08:	4620      	mov	r0, r4
    dc0a:	a902      	add	r1, sp, #8
    dc0c:	f002 fca2 	bl	10554 <z_arm_fatal_error>
}
    dc10:	b00a      	add	sp, #40	; 0x28
    dc12:	bd70      	pop	{r4, r5, r6, pc}
		} else if (SCB_BFSR != 0) {
    dc14:	4b10      	ldr	r3, [pc, #64]	; (dc58 <z_arm_fault+0xe0>)
    dc16:	781b      	ldrb	r3, [r3, #0]
    dc18:	b12b      	cbz	r3, dc26 <z_arm_fault+0xae>
			reason = bus_fault(esf, 1, recoverable);
    dc1a:	2001      	movs	r0, #1
    dc1c:	f10d 0107 	add.w	r1, sp, #7
		reason = bus_fault(esf, 0, recoverable);
    dc20:	f7ff ff76 	bl	db10 <bus_fault.isra.0>
    dc24:	e7dd      	b.n	dbe2 <z_arm_fault+0x6a>
		} else if (SCB_UFSR != 0) {
    dc26:	4b0d      	ldr	r3, [pc, #52]	; (dc5c <z_arm_fault+0xe4>)
    dc28:	8818      	ldrh	r0, [r3, #0]
    dc2a:	b284      	uxth	r4, r0
    dc2c:	2c00      	cmp	r4, #0
    dc2e:	d0d9      	beq.n	dbe4 <z_arm_fault+0x6c>
		reason = usage_fault(esf);
    dc30:	f7ff ff8c 	bl	db4c <usage_fault.isra.0>
    dc34:	e7d5      	b.n	dbe2 <z_arm_fault+0x6a>
		reason = mem_manage_fault(esf, 0, recoverable);
    dc36:	2000      	movs	r0, #0
    dc38:	f10d 0107 	add.w	r1, sp, #7
    dc3c:	e7cf      	b.n	dbde <z_arm_fault+0x66>
		reason = bus_fault(esf, 0, recoverable);
    dc3e:	2000      	movs	r0, #0
    dc40:	f10d 0107 	add.w	r1, sp, #7
    dc44:	e7ec      	b.n	dc20 <z_arm_fault+0xa8>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    dc46:	2400      	movs	r4, #0
    dc48:	e7cc      	b.n	dbe4 <z_arm_fault+0x6c>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    dc4a:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
    dc4e:	f023 0301 	bic.w	r3, r3, #1
    dc52:	e7d8      	b.n	dc06 <z_arm_fault+0x8e>
    dc54:	e000ed00 	.word	0xe000ed00
    dc58:	e000ed29 	.word	0xe000ed29
    dc5c:	e000ed2a 	.word	0xe000ed2a

0000dc60 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
    dc60:	4b04      	ldr	r3, [pc, #16]	; (dc74 <z_arm_fault_init+0x14>)
    dc62:	695a      	ldr	r2, [r3, #20]
    dc64:	f042 0210 	orr.w	r2, r2, #16
    dc68:	615a      	str	r2, [r3, #20]
	 *
	 * For Non-Secure Firmware this could allow the Non-Secure Main
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
    dc6a:	695a      	ldr	r2, [r3, #20]
    dc6c:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    dc70:	615a      	str	r2, [r3, #20]
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
    dc72:	4770      	bx	lr
    dc74:	e000ed00 	.word	0xe000ed00

0000dc78 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
    dc78:	4b04      	ldr	r3, [pc, #16]	; (dc8c <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
    dc7a:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
    dc7c:	6a98      	ldr	r0, [r3, #40]	; 0x28
	cmp r0, r1
    dc7e:	4288      	cmp	r0, r1
	beq _EXIT_EXC
    dc80:	d003      	beq.n	dc8a <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
    dc82:	4903      	ldr	r1, [pc, #12]	; (dc90 <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
    dc84:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
    dc88:	600a      	str	r2, [r1, #0]

0000dc8a <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
    dc8a:	4770      	bx	lr
	ldr r3, =_kernel
    dc8c:	20000908 	.word	0x20000908
	ldr r1, =_SCS_ICSR
    dc90:	e000ed04 	.word	0xe000ed04

0000dc94 <sys_arch_reboot>:
  __ASM volatile ("dsb 0xF":::"memory");
    dc94:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    dc98:	4905      	ldr	r1, [pc, #20]	; (dcb0 <sys_arch_reboot+0x1c>)
    dc9a:	4b06      	ldr	r3, [pc, #24]	; (dcb4 <sys_arch_reboot+0x20>)
    dc9c:	68ca      	ldr	r2, [r1, #12]
    dc9e:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    dca2:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    dca4:	60cb      	str	r3, [r1, #12]
    dca6:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
    dcaa:	bf00      	nop
  for(;;)                                                           /* wait until reset */
    dcac:	e7fd      	b.n	dcaa <sys_arch_reboot+0x16>
    dcae:	bf00      	nop
    dcb0:	e000ed00 	.word	0xe000ed00
    dcb4:	05fa0004 	.word	0x05fa0004

0000dcb8 <z_arm_clear_arm_mpu_config>:
	int i;

	int num_regions =
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);

	for (i = 0; i < num_regions; i++) {
    dcb8:	2300      	movs	r3, #0
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegionEx(MPU_Type* mpu, uint32_t rnr)
{
  mpu->RNR = rnr;
  mpu->RLAR = 0U;
    dcba:	4618      	mov	r0, r3
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);
    dcbc:	4a05      	ldr	r2, [pc, #20]	; (dcd4 <z_arm_clear_arm_mpu_config+0x1c>)
    dcbe:	6811      	ldr	r1, [r2, #0]
	int num_regions =
    dcc0:	f3c1 2107 	ubfx	r1, r1, #8, #8
	for (i = 0; i < num_regions; i++) {
    dcc4:	428b      	cmp	r3, r1
    dcc6:	d100      	bne.n	dcca <z_arm_clear_arm_mpu_config+0x12>
		ARM_MPU_ClrRegion(i);
	}
}
    dcc8:	4770      	bx	lr
  mpu->RNR = rnr;
    dcca:	6093      	str	r3, [r2, #8]
  mpu->RLAR = 0U;
    dccc:	6110      	str	r0, [r2, #16]
	for (i = 0; i < num_regions; i++) {
    dcce:	3301      	adds	r3, #1
    dcd0:	e7f8      	b.n	dcc4 <z_arm_clear_arm_mpu_config+0xc>
    dcd2:	bf00      	nop
    dcd4:	e000ed90 	.word	0xe000ed90

0000dcd8 <z_arm_init_arch_hw_at_boot>:
 * components and core registers.
 *
 * @return N/A
 */
void z_arm_init_arch_hw_at_boot(void)
{
    dcd8:	b510      	push	{r4, lr}
  __ASM volatile ("cpsid i" : : : "memory");
    dcda:	b672      	cpsid	i
  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
    dcdc:	2400      	movs	r4, #0
    dcde:	f384 8813 	msr	FAULTMASK, r4

	/* Initialize System Control Block components */

#if defined(CONFIG_CPU_HAS_ARM_MPU)
	/* Clear MPU region configuration */
	z_arm_clear_arm_mpu_config();
    dce2:	f7ff ffe9 	bl	dcb8 <z_arm_clear_arm_mpu_config>
#endif /* CONFIG_CPU_HAS_ARM_MPU */

	/* Disable NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
		NVIC->ICER[i] = 0xFFFFFFFF;
    dce6:	4a0e      	ldr	r2, [pc, #56]	; (dd20 <z_arm_init_arch_hw_at_boot+0x48>)
	z_arm_clear_arm_mpu_config();
    dce8:	4623      	mov	r3, r4
    dcea:	4611      	mov	r1, r2
		NVIC->ICER[i] = 0xFFFFFFFF;
    dcec:	f04f 34ff 	mov.w	r4, #4294967295
    dcf0:	f103 0020 	add.w	r0, r3, #32
    dcf4:	3301      	adds	r3, #1
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
    dcf6:	2b10      	cmp	r3, #16
		NVIC->ICER[i] = 0xFFFFFFFF;
    dcf8:	f842 4020 	str.w	r4, [r2, r0, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
    dcfc:	d1f8      	bne.n	dcf0 <z_arm_init_arch_hw_at_boot+0x18>
    dcfe:	2300      	movs	r3, #0
	}
	/* Clear pending NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
		NVIC->ICPR[i] = 0xFFFFFFFF;
    dd00:	f04f 30ff 	mov.w	r0, #4294967295
    dd04:	f103 0260 	add.w	r2, r3, #96	; 0x60
    dd08:	3301      	adds	r3, #1
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
    dd0a:	2b10      	cmp	r3, #16
		NVIC->ICPR[i] = 0xFFFFFFFF;
    dd0c:	f841 0022 	str.w	r0, [r1, r2, lsl #2]
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
    dd10:	d1f8      	bne.n	dd04 <z_arm_init_arch_hw_at_boot+0x2c>
  __ASM volatile ("cpsie i" : : : "memory");
    dd12:	b662      	cpsie	i
  __ASM volatile ("dsb 0xF":::"memory");
    dd14:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    dd18:	f3bf 8f6f 	isb	sy
	/* Restore Interrupts */
	__enable_irq();

	__DSB();
	__ISB();
}
    dd1c:	bd10      	pop	{r4, pc}
    dd1e:	bf00      	nop
    dd20:	e000e100 	.word	0xe000e100

0000dd24 <z_arm_interrupt_init>:
 * @return N/A
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
    dd24:	2300      	movs	r3, #0
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    dd26:	2120      	movs	r1, #32
    dd28:	4803      	ldr	r0, [pc, #12]	; (dd38 <z_arm_interrupt_init+0x14>)
    dd2a:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
    dd2c:	3301      	adds	r3, #1
    dd2e:	2b45      	cmp	r3, #69	; 0x45
    dd30:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
    dd34:	d1f9      	bne.n	dd2a <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
    dd36:	4770      	bx	lr
    dd38:	e000e100 	.word	0xe000e100

0000dd3c <z_impl_k_thread_abort>:
#include <kswap.h>
#include <wait_q.h>
#include <sys/__assert.h>

void z_impl_k_thread_abort(k_tid_t thread)
{
    dd3c:	b508      	push	{r3, lr}
	if (_current == thread) {
    dd3e:	4b0e      	ldr	r3, [pc, #56]	; (dd78 <z_impl_k_thread_abort+0x3c>)
    dd40:	689b      	ldr	r3, [r3, #8]
    dd42:	4283      	cmp	r3, r0
    dd44:	d107      	bne.n	dd56 <z_impl_k_thread_abort+0x1a>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    dd46:	f3ef 8305 	mrs	r3, IPSR
		if (arch_is_in_isr()) {
    dd4a:	b193      	cbz	r3, dd72 <z_impl_k_thread_abort+0x36>
			 * should no longer run after we return, so
			 * Trigger PendSV, in case we are in one of the
			 * situations where the isr check is true but there
			 * is not an implicit scheduler invocation.
			 */
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
    dd4c:	4a0b      	ldr	r2, [pc, #44]	; (dd7c <z_impl_k_thread_abort+0x40>)
    dd4e:	6853      	ldr	r3, [r2, #4]
    dd50:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    dd54:	6053      	str	r3, [r2, #4]
		} else {
			z_self_abort(); /* Never returns */
		}
	}

	z_thread_single_abort(thread);
    dd56:	f001 fb83 	bl	f460 <z_thread_single_abort>
	__asm__ volatile(
    dd5a:	f04f 0320 	mov.w	r3, #32
    dd5e:	f3ef 8011 	mrs	r0, BASEPRI
    dd62:	f383 8811 	msr	BASEPRI, r3
    dd66:	f3bf 8f6f 	isb	sy

	/* The abort handler might have altered the ready queue. */
	z_reschedule_unlocked();
}
    dd6a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void) z_pend_curr_irqlock(arch_irq_lock(), wait_q, timeout);
}

static inline void z_reschedule_unlocked(void)
{
	(void) z_reschedule_irqlock(arch_irq_lock());
    dd6e:	f002 bdf2 	b.w	10956 <z_reschedule_irqlock>
			z_self_abort(); /* Never returns */
    dd72:	f001 fe23 	bl	f9bc <z_self_abort>
    dd76:	bf00      	nop
    dd78:	20000908 	.word	0x20000908
    dd7c:	e000ed00 	.word	0xe000ed00

0000dd80 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
    dd80:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    dd82:	4c09      	ldr	r4, [pc, #36]	; (dda8 <z_arm_configure_static_mpu_regions+0x28>)
    dd84:	4a09      	ldr	r2, [pc, #36]	; (ddac <z_arm_configure_static_mpu_regions+0x2c>)
    dd86:	4623      	mov	r3, r4
    dd88:	2101      	movs	r1, #1
    dd8a:	4809      	ldr	r0, [pc, #36]	; (ddb0 <z_arm_configure_static_mpu_regions+0x30>)
    dd8c:	f000 f902 	bl	df94 <arm_core_mpu_configure_static_mpu_regions>
	/* Define a constant array of z_arm_mpu_partition objects that holds the
	 * boundaries of the areas, inside which dynamic region programming
	 * is allowed. The information is passed to the underlying driver at
	 * initialization.
	 */
	const struct z_arm_mpu_partition dyn_region_areas[] = {
    dd90:	2300      	movs	r3, #0
    dd92:	9303      	str	r3, [sp, #12]
		{
		.start = _MPU_DYNAMIC_REGIONS_AREA_START,
    dd94:	4b07      	ldr	r3, [pc, #28]	; (ddb4 <z_arm_configure_static_mpu_regions+0x34>)
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
		}
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
    dd96:	2101      	movs	r1, #1
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
    dd98:	1ae4      	subs	r4, r4, r3
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
    dd9a:	a801      	add	r0, sp, #4
	const struct z_arm_mpu_partition dyn_region_areas[] = {
    dd9c:	9301      	str	r3, [sp, #4]
    dd9e:	9402      	str	r4, [sp, #8]
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
    dda0:	f000 f902 	bl	dfa8 <arm_core_mpu_mark_areas_for_dynamic_regions>
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
    dda4:	b004      	add	sp, #16
    dda6:	bd10      	pop	{r4, pc}
    dda8:	2007e000 	.word	0x2007e000
    ddac:	20000000 	.word	0x20000000
    ddb0:	00010e64 	.word	0x00010e64
    ddb4:	20000160 	.word	0x20000160

0000ddb8 <region_init>:
 * Note:
 *   The caller must provide a valid region index.
 */
static void region_init(const uint32_t index,
	const struct arm_mpu_region *region_conf)
{
    ddb8:	b510      	push	{r4, lr}
	ARM_MPU_SetRegion(
		/* RNR */
		index,
		/* RBAR */
		(region_conf->base & MPU_RBAR_BASE_Msk)
    ddba:	680b      	ldr	r3, [r1, #0]
		| (region_conf->attr.rbar &
    ddbc:	7a0c      	ldrb	r4, [r1, #8]
		(region_conf->base & MPU_RBAR_BASE_Msk)
    ddbe:	f023 021f 	bic.w	r2, r3, #31
		| (region_conf->attr.rbar &
    ddc2:	f004 031f 	and.w	r3, r4, #31
    ddc6:	431a      	orrs	r2, r3
			(MPU_RBAR_XN_Msk | MPU_RBAR_AP_Msk | MPU_RBAR_SH_Msk)),
		/* RLAR */
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
    ddc8:	68cb      	ldr	r3, [r1, #12]
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
    ddca:	0964      	lsrs	r4, r4, #5
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
    ddcc:	f023 031f 	bic.w	r3, r3, #31
* \param rbar Value for RBAR register.
* \param rlar Value for RLAR register.
*/   
__STATIC_INLINE void ARM_MPU_SetRegionEx(MPU_Type* mpu, uint32_t rnr, uint32_t rbar, uint32_t rlar)
{
  mpu->RNR = rnr;
    ddd0:	4904      	ldr	r1, [pc, #16]	; (dde4 <region_init+0x2c>)
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
    ddd2:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
			& MPU_RLAR_AttrIndx_Msk)
		| MPU_RLAR_EN_Msk
    ddd6:	f043 0301 	orr.w	r3, r3, #1
    ddda:	6088      	str	r0, [r1, #8]
  mpu->RBAR = rbar;
    dddc:	60ca      	str	r2, [r1, #12]
  mpu->RLAR = rlar;
    ddde:	610b      	str	r3, [r1, #16]
	);

	LOG_DBG("[%d] 0x%08x 0x%08x 0x%08x 0x%08x",
			index, region_conf->base, region_conf->attr.rbar,
			region_conf->attr.mair_idx, region_conf->attr.r_limit);
}
    dde0:	bd10      	pop	{r4, pc}
    dde2:	bf00      	nop
    dde4:	e000ed90 	.word	0xe000ed90

0000dde8 <mpu_configure_regions_and_partition.constprop.0>:
 * sanity check of the memory regions to be programmed.
 *
 * The function performs a full partition of the background memory
 * area, effectively, leaving no space in this area uncovered by MPU.
 */
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
    dde8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    ddec:	4688      	mov	r8, r1
    ddee:	4614      	mov	r4, r2
	bool do_sanity_check)
{
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
    ddf0:	4606      	mov	r6, r0
    ddf2:	f04f 0900 	mov.w	r9, #0
	MPU->RNR = index;
    ddf6:	4d4a      	ldr	r5, [pc, #296]	; (df20 <mpu_configure_regions_and_partition.constprop.0+0x138>)
static int mpu_configure_regions_and_partition(const struct z_arm_mpu_partition
    ddf8:	b085      	sub	sp, #20
	for (i = 0; i < regions_num; i++) {
    ddfa:	45c1      	cmp	r9, r8
    ddfc:	da05      	bge.n	de0a <mpu_configure_regions_and_partition.constprop.0+0x22>
		if (regions[i].size == 0U) {
    ddfe:	6877      	ldr	r7, [r6, #4]
    de00:	b3bf      	cbz	r7, de72 <mpu_configure_regions_and_partition.constprop.0+0x8a>
		&&
    de02:	2f1f      	cmp	r7, #31
    de04:	d805      	bhi.n	de12 <mpu_configure_regions_and_partition.constprop.0+0x2a>

			reg_index =
				mpu_configure_region(reg_index, &regions[i]);

			if (reg_index == -EINVAL) {
				return reg_index;
    de06:	f06f 0415 	mvn.w	r4, #21
			reg_index++;
		}
	}

	return reg_index;
}
    de0a:	4620      	mov	r0, r4
    de0c:	b005      	add	sp, #20
    de0e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		&&
    de12:	06fb      	lsls	r3, r7, #27
    de14:	d1f7      	bne.n	de06 <mpu_configure_regions_and_partition.constprop.0+0x1e>
		((part->start &
    de16:	f8d6 a000 	ldr.w	sl, [r6]
		&&
    de1a:	f01a 0f1f 	tst.w	sl, #31
    de1e:	d1f2      	bne.n	de06 <mpu_configure_regions_and_partition.constprop.0+0x1e>
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
    de20:	4650      	mov	r0, sl
    de22:	f002 fbc1 	bl	105a8 <arm_cmse_mpu_region_get>
    de26:	4683      	mov	fp, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
    de28:	eb07 000a 	add.w	r0, r7, sl
    de2c:	3801      	subs	r0, #1
    de2e:	f002 fbbb 	bl	105a8 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
    de32:	4583      	cmp	fp, r0
    de34:	d1e7      	bne.n	de06 <mpu_configure_regions_and_partition.constprop.0+0x1e>
		if ((u_reg_index == -EINVAL) ||
    de36:	f11b 0f16 	cmn.w	fp, #22
    de3a:	d0e4      	beq.n	de06 <mpu_configure_regions_and_partition.constprop.0+0x1e>
			(u_reg_index > (reg_index - 1))) {
    de3c:	1e63      	subs	r3, r4, #1
		if ((u_reg_index == -EINVAL) ||
    de3e:	455b      	cmp	r3, fp
    de40:	dbe1      	blt.n	de06 <mpu_configure_regions_and_partition.constprop.0+0x1e>
	MPU->RNR = index;
    de42:	f8c5 b008 	str.w	fp, [r5, #8]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
    de46:	68e9      	ldr	r1, [r5, #12]
	MPU->RNR = index;
    de48:	f8c5 b008 	str.w	fp, [r5, #8]
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
    de4c:	692f      	ldr	r7, [r5, #16]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
    de4e:	f021 011f 	bic.w	r1, r1, #31
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
    de52:	e9d6 3200 	ldrd	r3, r2, [r6]
    de56:	441a      	add	r2, r3
		if ((regions[i].start == u_reg_base) &&
    de58:	4299      	cmp	r1, r3
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
    de5a:	f047 071f 	orr.w	r7, r7, #31
		uint32_t reg_last = regions[i].start + regions[i].size - 1;
    de5e:	f102 3aff 	add.w	sl, r2, #4294967295
		if ((regions[i].start == u_reg_base) &&
    de62:	d11c      	bne.n	de9e <mpu_configure_regions_and_partition.constprop.0+0xb6>
    de64:	4557      	cmp	r7, sl
    de66:	d108      	bne.n	de7a <mpu_configure_regions_and_partition.constprop.0+0x92>
			mpu_configure_region(u_reg_index, &regions[i]);
    de68:	4631      	mov	r1, r6
    de6a:	fa5f f08b 	uxtb.w	r0, fp
    de6e:	f002 fb7e 	bl	1056e <mpu_configure_region>
	for (i = 0; i < regions_num; i++) {
    de72:	f109 0901 	add.w	r9, r9, #1
    de76:	360c      	adds	r6, #12
    de78:	e7bf      	b.n	ddfa <mpu_configure_regions_and_partition.constprop.0+0x12>
				mpu_configure_region(reg_index, &regions[i]);
    de7a:	4631      	mov	r1, r6
	MPU->RNR = index;
    de7c:	f8c5 b008 	str.w	fp, [r5, #8]
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
    de80:	68eb      	ldr	r3, [r5, #12]
		| (base & MPU_RBAR_BASE_Msk);
    de82:	f022 021f 	bic.w	r2, r2, #31
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
    de86:	f003 031f 	and.w	r3, r3, #31
		| (base & MPU_RBAR_BASE_Msk);
    de8a:	431a      	orrs	r2, r3
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
    de8c:	60ea      	str	r2, [r5, #12]
				mpu_configure_region(reg_index, &regions[i]);
    de8e:	b2e0      	uxtb	r0, r4
				mpu_configure_region(reg_index, &regions[i]);
    de90:	f002 fb6d 	bl	1056e <mpu_configure_region>
			if (reg_index == -EINVAL) {
    de94:	f110 0f16 	cmn.w	r0, #22
    de98:	d0b5      	beq.n	de06 <mpu_configure_regions_and_partition.constprop.0+0x1e>
			reg_index++;
    de9a:	1c44      	adds	r4, r0, #1
    de9c:	e7e9      	b.n	de72 <mpu_configure_regions_and_partition.constprop.0+0x8a>
		} else if (reg_last == u_reg_last) {
    de9e:	3b01      	subs	r3, #1
    dea0:	4557      	cmp	r7, sl
    dea2:	b2e0      	uxtb	r0, r4
    dea4:	f023 031f 	bic.w	r3, r3, #31
	MPU->RNR = index;
    dea8:	f8c5 b008 	str.w	fp, [r5, #8]
		} else if (reg_last == u_reg_last) {
    deac:	d106      	bne.n	debc <mpu_configure_regions_and_partition.constprop.0+0xd4>
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
    deae:	692a      	ldr	r2, [r5, #16]
				mpu_configure_region(reg_index, &regions[i]);
    deb0:	4631      	mov	r1, r6
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
    deb2:	f002 021f 	and.w	r2, r2, #31
		| (limit & MPU_RLAR_LIMIT_Msk);
    deb6:	4313      	orrs	r3, r2
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
    deb8:	612b      	str	r3, [r5, #16]
			reg_index =
    deba:	e7e9      	b.n	de90 <mpu_configure_regions_and_partition.constprop.0+0xa8>
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
    debc:	6929      	ldr	r1, [r5, #16]
    debe:	f001 011f 	and.w	r1, r1, #31
		| (limit & MPU_RLAR_LIMIT_Msk);
    dec2:	430b      	orrs	r3, r1
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
    dec4:	612b      	str	r3, [r5, #16]
				mpu_configure_region(reg_index, &regions[i]);
    dec6:	4631      	mov	r1, r6
    dec8:	f002 fb51 	bl	1056e <mpu_configure_region>
			if (reg_index == -EINVAL) {
    decc:	f110 0f16 	cmn.w	r0, #22
    ded0:	d099      	beq.n	de06 <mpu_configure_regions_and_partition.constprop.0+0x1e>
	MPU->RNR = index;
    ded2:	f8c5 b008 	str.w	fp, [r5, #8]
	attr->rbar = MPU->RBAR &
    ded6:	68ea      	ldr	r2, [r5, #12]
    ded8:	f89d 3008 	ldrb.w	r3, [sp, #8]
			REGION_LIMIT_ADDR((regions[i].start +
    dedc:	3f01      	subs	r7, #1
	attr->rbar = MPU->RBAR &
    dede:	f362 0304 	bfi	r3, r2, #0, #5
    dee2:	f88d 3008 	strb.w	r3, [sp, #8]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
    dee6:	692b      	ldr	r3, [r5, #16]
    dee8:	f89d 2008 	ldrb.w	r2, [sp, #8]
    deec:	085b      	lsrs	r3, r3, #1
    deee:	f363 1247 	bfi	r2, r3, #5, #3
    def2:	f88d 2008 	strb.w	r2, [sp, #8]
			fill_region.base = regions[i].start +
    def6:	e9d6 3200 	ldrd	r3, r2, [r6]
    defa:	4413      	add	r3, r2
    defc:	9300      	str	r3, [sp, #0]
			REGION_LIMIT_ADDR((regions[i].start +
    defe:	f023 031f 	bic.w	r3, r3, #31
    df02:	443b      	add	r3, r7
			reg_index++;
    df04:	1c44      	adds	r4, r0, #1
			REGION_LIMIT_ADDR((regions[i].start +
    df06:	eba3 0a0a 	sub.w	sl, r3, sl
    df0a:	b2e0      	uxtb	r0, r4
    df0c:	f02a 031f 	bic.w	r3, sl, #31

static int region_allocate_and_init(const uint8_t index,
	const struct arm_mpu_region *region_conf)
{
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1U)) {
    df10:	2807      	cmp	r0, #7
			fill_region.attr.r_limit =
    df12:	9303      	str	r3, [sp, #12]
    df14:	f63f af77 	bhi.w	de06 <mpu_configure_regions_and_partition.constprop.0+0x1e>
	}

	LOG_DBG("Program MPU region at index 0x%x", index);

	/* Program region */
	region_init(index, region_conf);
    df18:	4669      	mov	r1, sp
    df1a:	f7ff ff4d 	bl	ddb8 <region_init>
    df1e:	e7bc      	b.n	de9a <mpu_configure_regions_and_partition.constprop.0+0xb2>
    df20:	e000ed90 	.word	0xe000ed90

0000df24 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
    df24:	2205      	movs	r2, #5
    df26:	4b03      	ldr	r3, [pc, #12]	; (df34 <arm_core_mpu_enable+0x10>)
    df28:	605a      	str	r2, [r3, #4]
  __ASM volatile ("dsb 0xF":::"memory");
    df2a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    df2e:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
    df32:	4770      	bx	lr
    df34:	e000ed90 	.word	0xe000ed90

0000df38 <arm_core_mpu_disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
    df38:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
    df3c:	2200      	movs	r2, #0
    df3e:	4b01      	ldr	r3, [pc, #4]	; (df44 <arm_core_mpu_disable+0xc>)
    df40:	605a      	str	r2, [r3, #4]
}
    df42:	4770      	bx	lr
    df44:	e000ed90 	.word	0xe000ed90

0000df48 <arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
static int arm_mpu_init(const struct device *arg)
{
    df48:	b538      	push	{r3, r4, r5, lr}
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
    df4a:	4c0e      	ldr	r4, [pc, #56]	; (df84 <arm_mpu_init+0x3c>)
    df4c:	6825      	ldr	r5, [r4, #0]
    df4e:	2d08      	cmp	r5, #8
    df50:	d814      	bhi.n	df7c <arm_mpu_init+0x34>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
    df52:	f7ff fff1 	bl	df38 <arm_core_mpu_disable>

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    df56:	2000      	movs	r0, #0
	MPU->MAIR0 =
    df58:	4b0b      	ldr	r3, [pc, #44]	; (df88 <arm_mpu_init+0x40>)
    df5a:	4a0c      	ldr	r2, [pc, #48]	; (df8c <arm_mpu_init+0x44>)
    df5c:	631a      	str	r2, [r3, #48]	; 0x30
    df5e:	4285      	cmp	r5, r0
    df60:	d105      	bne.n	df6e <arm_mpu_init+0x26>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
    df62:	4b0b      	ldr	r3, [pc, #44]	; (df90 <arm_mpu_init+0x48>)
    df64:	701d      	strb	r5, [r3, #0]


	arm_core_mpu_enable();
    df66:	f7ff ffdd 	bl	df24 <arm_core_mpu_enable>
	__ASSERT(
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */
	return 0;
    df6a:	2000      	movs	r0, #0
}
    df6c:	bd38      	pop	{r3, r4, r5, pc}
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
    df6e:	6861      	ldr	r1, [r4, #4]
    df70:	eb01 1100 	add.w	r1, r1, r0, lsl #4
    df74:	f7ff ff20 	bl	ddb8 <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    df78:	3001      	adds	r0, #1
    df7a:	e7f0      	b.n	df5e <arm_mpu_init+0x16>
		return -1;
    df7c:	f04f 30ff 	mov.w	r0, #4294967295
    df80:	e7f4      	b.n	df6c <arm_mpu_init+0x24>
    df82:	bf00      	nop
    df84:	00010e70 	.word	0x00010e70
    df88:	e000ed90 	.word	0xe000ed90
    df8c:	0044ffaa 	.word	0x0044ffaa
    df90:	20000964 	.word	0x20000964

0000df94 <arm_core_mpu_configure_static_mpu_regions>:
{
    df94:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
    df96:	4c03      	ldr	r4, [pc, #12]	; (dfa4 <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * given boundaries.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions_and_partition(static_regions,
    df98:	7822      	ldrb	r2, [r4, #0]
    df9a:	f7ff ff25 	bl	dde8 <mpu_configure_regions_and_partition.constprop.0>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
    df9e:	7020      	strb	r0, [r4, #0]
}
    dfa0:	bd10      	pop	{r4, pc}
    dfa2:	bf00      	nop
    dfa4:	20000964 	.word	0x20000964

0000dfa8 <arm_core_mpu_mark_areas_for_dynamic_regions>:
{
    dfa8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    dfac:	4d26      	ldr	r5, [pc, #152]	; (e048 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa0>)
    dfae:	468a      	mov	sl, r1
{
	/* In ARMv8-M architecture we need to store the index values
	 * and the default configuration of the MPU regions, inside
	 * which dynamic memory regions may be programmed at run-time.
	 */
	for (int i = 0; i < dyn_region_areas_num; i++) {
    dfb0:	4606      	mov	r6, r0
    dfb2:	f04f 0800 	mov.w	r8, #0
    dfb6:	46ab      	mov	fp, r5
	MPU->RNR = index;
    dfb8:	4f24      	ldr	r7, [pc, #144]	; (e04c <arm_core_mpu_mark_areas_for_dynamic_regions+0xa4>)
	for (int i = 0; i < dyn_region_areas_num; i++) {
    dfba:	45d0      	cmp	r8, sl
    dfbc:	da1b      	bge.n	dff6 <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
		if (dyn_region_areas[i].size == 0U) {
    dfbe:	f8d6 9004 	ldr.w	r9, [r6, #4]
    dfc2:	f1b9 0f00 	cmp.w	r9, #0
    dfc6:	d039      	beq.n	e03c <arm_core_mpu_mark_areas_for_dynamic_regions+0x94>
		}
		/* Non-empty area */

		/* Retrieve HW MPU region index */
		dyn_reg_info[i].index =
			get_region_index(dyn_region_areas[i].start,
    dfc8:	6831      	ldr	r1, [r6, #0]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
    dfca:	4608      	mov	r0, r1
    dfcc:	9101      	str	r1, [sp, #4]
    dfce:	f002 faeb 	bl	105a8 <arm_cmse_mpu_region_get>
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
    dfd2:	9901      	ldr	r1, [sp, #4]
	uint32_t region_start_addr = arm_cmse_mpu_region_get(start);
    dfd4:	4604      	mov	r4, r0
	uint32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
    dfd6:	eb09 0001 	add.w	r0, r9, r1
    dfda:	3801      	subs	r0, #1
    dfdc:	f002 fae4 	bl	105a8 <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
    dfe0:	4284      	cmp	r4, r0
    dfe2:	f04f 0214 	mov.w	r2, #20
    dfe6:	4b1a      	ldr	r3, [pc, #104]	; (e050 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa8>)
    dfe8:	d008      	beq.n	dffc <arm_core_mpu_mark_areas_for_dynamic_regions+0x54>
		dyn_reg_info[i].index =
    dfea:	f06f 0315 	mvn.w	r3, #21
    dfee:	fb02 f808 	mul.w	r8, r2, r8
    dff2:	f84b 3008 	str.w	r3, [fp, r8]
}
    dff6:	b003      	add	sp, #12
    dff8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					dyn_region_areas[i].size);

		if (dyn_reg_info[i].index == -EINVAL) {
    dffc:	f114 0f16 	cmn.w	r4, #22
		dyn_reg_info[i].index =
    e000:	602c      	str	r4, [r5, #0]
		if (dyn_reg_info[i].index == -EINVAL) {
    e002:	d0f8      	beq.n	dff6 <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>

			return -EINVAL;
		}

		if (dyn_reg_info[i].index >= static_regions_num) {
    e004:	7819      	ldrb	r1, [r3, #0]
    e006:	42a1      	cmp	r1, r4
    e008:	ddf5      	ble.n	dff6 <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
	attr->rbar = MPU->RBAR &
    e00a:	fb02 b008 	mla	r0, r2, r8, fp
	MPU->RNR = index;
    e00e:	60bc      	str	r4, [r7, #8]
	MPU->RNR = index;
    e010:	60bc      	str	r4, [r7, #8]
	attr->rbar = MPU->RBAR &
    e012:	68fc      	ldr	r4, [r7, #12]
    e014:	f100 0108 	add.w	r1, r0, #8
    e018:	7b00      	ldrb	r0, [r0, #12]
    e01a:	f364 0004 	bfi	r0, r4, #0, #5
    e01e:	7108      	strb	r0, [r1, #4]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
    e020:	6938      	ldr	r0, [r7, #16]
    e022:	790c      	ldrb	r4, [r1, #4]
    e024:	0840      	lsrs	r0, r0, #1
    e026:	f360 1447 	bfi	r4, r0, #5, #3
    e02a:	710c      	strb	r4, [r1, #4]
	region_conf->base = (MPU->RBAR & MPU_RBAR_BASE_Msk);
    e02c:	68f9      	ldr	r1, [r7, #12]
    e02e:	f021 011f 	bic.w	r1, r1, #31
    e032:	6069      	str	r1, [r5, #4]
	region_conf->attr.r_limit = MPU->RLAR & MPU_RLAR_LIMIT_Msk;
    e034:	6939      	ldr	r1, [r7, #16]
    e036:	f021 011f 	bic.w	r1, r1, #31
    e03a:	6129      	str	r1, [r5, #16]
	for (int i = 0; i < dyn_region_areas_num; i++) {
    e03c:	f108 0801 	add.w	r8, r8, #1
    e040:	3514      	adds	r5, #20
    e042:	360c      	adds	r6, #12
    e044:	e7b9      	b.n	dfba <arm_core_mpu_mark_areas_for_dynamic_regions+0x12>
    e046:	bf00      	nop
    e048:	20000850 	.word	0x20000850
    e04c:	e000ed90 	.word	0xe000ed90
    e050:	20000964 	.word	0x20000964

0000e054 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
    e054:	4b01      	ldr	r3, [pc, #4]	; (e05c <__stdout_hook_install+0x8>)
    e056:	6018      	str	r0, [r3, #0]
}
    e058:	4770      	bx	lr
    e05a:	bf00      	nop
    e05c:	20000024 	.word	0x20000024

0000e060 <gpio_nrfx_init>:
}

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(const struct device *port)
{
    e060:	b508      	push	{r3, lr}
	static bool gpio_initialized;

	if (!gpio_initialized) {
    e062:	4b09      	ldr	r3, [pc, #36]	; (e088 <gpio_nrfx_init+0x28>)
    e064:	781a      	ldrb	r2, [r3, #0]
    e066:	b96a      	cbnz	r2, e084 <gpio_nrfx_init+0x24>
		gpio_initialized = true;
    e068:	2101      	movs	r1, #1
		IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
    e06a:	200d      	movs	r0, #13
		gpio_initialized = true;
    e06c:	7019      	strb	r1, [r3, #0]
		IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
    e06e:	2105      	movs	r1, #5
    e070:	f7ff fc44 	bl	d8fc <z_arm_irq_priority_set>
			    gpiote_event_handler, NULL, 0);

		irq_enable(DT_IRQN(GPIOTE_NODE));
    e074:	200d      	movs	r0, #13
    e076:	f7ff fc23 	bl	d8c0 <arch_irq_enable>
    return ((uint32_t)p_reg + event);
}

NRF_STATIC_INLINE void nrf_gpiote_int_enable(NRF_GPIOTE_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
    e07a:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    e07e:	4b03      	ldr	r3, [pc, #12]	; (e08c <gpio_nrfx_init+0x2c>)
    e080:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		nrf_gpiote_int_enable(NRF_GPIOTE, NRF_GPIOTE_INT_PORT_MASK);
	}

	return 0;
}
    e084:	2000      	movs	r0, #0
    e086:	bd08      	pop	{r3, pc}
    e088:	20000965 	.word	0x20000965
    e08c:	5000d000 	.word	0x5000d000

0000e090 <gpio_nrfx_config>:
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    e090:	4b2a      	ldr	r3, [pc, #168]	; (e13c <gpio_nrfx_config+0xac>)
{
    e092:	b5f0      	push	{r4, r5, r6, r7, lr}
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    e094:	6844      	ldr	r4, [r0, #4]
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    e096:	482a      	ldr	r0, [pc, #168]	; (e140 <gpio_nrfx_config+0xb0>)
    e098:	4013      	ands	r3, r2
    e09a:	4283      	cmp	r3, r0
    e09c:	d03f      	beq.n	e11e <gpio_nrfx_config+0x8e>
    e09e:	d80d      	bhi.n	e0bc <gpio_nrfx_config+0x2c>
    e0a0:	2b06      	cmp	r3, #6
    e0a2:	d015      	beq.n	e0d0 <gpio_nrfx_config+0x40>
    e0a4:	d805      	bhi.n	e0b2 <gpio_nrfx_config+0x22>
    e0a6:	b19b      	cbz	r3, e0d0 <gpio_nrfx_config+0x40>
    e0a8:	2b02      	cmp	r3, #2
    e0aa:	d03a      	beq.n	e122 <gpio_nrfx_config+0x92>
    e0ac:	f06f 0015 	mvn.w	r0, #21
    e0b0:	e034      	b.n	e11c <gpio_nrfx_config+0x8c>
    e0b2:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
    e0b6:	d1f9      	bne.n	e0ac <gpio_nrfx_config+0x1c>
		drive = NRF_GPIO_PIN_H0S1;
    e0b8:	2301      	movs	r3, #1
    e0ba:	e009      	b.n	e0d0 <gpio_nrfx_config+0x40>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
    e0bc:	4821      	ldr	r0, [pc, #132]	; (e144 <gpio_nrfx_config+0xb4>)
    e0be:	4283      	cmp	r3, r0
    e0c0:	d031      	beq.n	e126 <gpio_nrfx_config+0x96>
    e0c2:	f5b3 0fa0 	cmp.w	r3, #5242880	; 0x500000
    e0c6:	d030      	beq.n	e12a <gpio_nrfx_config+0x9a>
    e0c8:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
    e0cc:	d1ee      	bne.n	e0ac <gpio_nrfx_config+0x1c>
		drive = NRF_GPIO_PIN_S0H1;
    e0ce:	2302      	movs	r3, #2
	if ((flags & GPIO_PULL_UP) != 0) {
    e0d0:	06d0      	lsls	r0, r2, #27
		pull = NRF_GPIO_PIN_PULLUP;
    e0d2:	bf4c      	ite	mi
    e0d4:	2603      	movmi	r6, #3
		pull = NRF_GPIO_PIN_NOPULL;
    e0d6:	f3c2 1640 	ubfxpl	r6, r2, #5, #1
		: NRF_GPIO_PIN_INPUT_DISCONNECT;
    e0da:	f482 7580 	eor.w	r5, r2, #256	; 0x100
	if ((flags & GPIO_OUTPUT) != 0) {
    e0de:	0597      	lsls	r7, r2, #22
	dir = ((flags & GPIO_OUTPUT) != 0)
    e0e0:	f3c2 2040 	ubfx	r0, r2, #9, #1
		: NRF_GPIO_PIN_INPUT_DISCONNECT;
    e0e4:	f3c5 2500 	ubfx	r5, r5, #8, #1
	if ((flags & GPIO_OUTPUT) != 0) {
    e0e8:	d506      	bpl.n	e0f8 <gpio_nrfx_config+0x68>
		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
    e0ea:	f412 6f00 	tst.w	r2, #2048	; 0x800
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
    e0ee:	6867      	ldr	r7, [r4, #4]
		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
    e0f0:	d01d      	beq.n	e12e <gpio_nrfx_config+0x9e>
			nrf_gpio_port_out_set(reg, BIT(pin));
    e0f2:	2201      	movs	r2, #1
    e0f4:	408a      	lsls	r2, r1
    p_reg->OUTSET = set_mask;
    e0f6:	60ba      	str	r2, [r7, #8]
    return pin_number >> 5;
    e0f8:	7a27      	ldrb	r7, [r4, #8]
        case 1: return NRF_P1;
    e0fa:	4a13      	ldr	r2, [pc, #76]	; (e148 <gpio_nrfx_config+0xb8>)
    e0fc:	4c13      	ldr	r4, [pc, #76]	; (e14c <gpio_nrfx_config+0xbc>)
    *p_pin = pin_number & 0x1F;
    e0fe:	f001 011f 	and.w	r1, r1, #31
        case 1: return NRF_P1;
    e102:	2f01      	cmp	r7, #1
    e104:	bf08      	it	eq
    e106:	4614      	moveq	r4, r2
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
    e108:	ea40 0245 	orr.w	r2, r0, r5, lsl #1
	return 0;
    e10c:	2000      	movs	r0, #0
    e10e:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
    e112:	ea43 0386 	orr.w	r3, r3, r6, lsl #2
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    e116:	3180      	adds	r1, #128	; 0x80
    e118:	f844 3021 	str.w	r3, [r4, r1, lsl #2]
}
    e11c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		drive = NRF_GPIO_PIN_H0D1;
    e11e:	2307      	movs	r3, #7
    e120:	e7d6      	b.n	e0d0 <gpio_nrfx_config+0x40>
		drive = NRF_GPIO_PIN_D0S1;
    e122:	2304      	movs	r3, #4
    e124:	e7d4      	b.n	e0d0 <gpio_nrfx_config+0x40>
		drive = NRF_GPIO_PIN_D0H1;
    e126:	2305      	movs	r3, #5
    e128:	e7d2      	b.n	e0d0 <gpio_nrfx_config+0x40>
		drive = NRF_GPIO_PIN_H0H1;
    e12a:	2303      	movs	r3, #3
    e12c:	e7d0      	b.n	e0d0 <gpio_nrfx_config+0x40>
		} else if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
    e12e:	0552      	lsls	r2, r2, #21
			nrf_gpio_port_out_clear(reg, BIT(pin));
    e130:	bf42      	ittt	mi
    e132:	2201      	movmi	r2, #1
    e134:	408a      	lslmi	r2, r1
    p_reg->OUTCLR = clr_mask;
    e136:	60fa      	strmi	r2, [r7, #12]
}
    e138:	e7de      	b.n	e0f8 <gpio_nrfx_config+0x68>
    e13a:	bf00      	nop
    e13c:	00f00006 	.word	0x00f00006
    e140:	00100006 	.word	0x00100006
    e144:	00400002 	.word	0x00400002
    e148:	50842800 	.word	0x50842800
    e14c:	50842500 	.word	0x50842500

0000e150 <nrf_gpio_cfg_sense_set>:
{
    e150:	b510      	push	{r4, lr}
        case 1: return NRF_P1;
    e152:	4b09      	ldr	r3, [pc, #36]	; (e178 <nrf_gpio_cfg_sense_set+0x28>)
    e154:	4c09      	ldr	r4, [pc, #36]	; (e17c <nrf_gpio_cfg_sense_set+0x2c>)
    *p_pin = pin_number & 0x1F;
    e156:	f000 021f 	and.w	r2, r0, #31
    return pin_number >> 5;
    e15a:	0940      	lsrs	r0, r0, #5
        case 1: return NRF_P1;
    e15c:	2801      	cmp	r0, #1
    e15e:	bf08      	it	eq
    e160:	4623      	moveq	r3, r4
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
    e162:	eb03 0382 	add.w	r3, r3, r2, lsl #2
    e166:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    e16a:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
    e16e:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
    e172:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
}
    e176:	bd10      	pop	{r4, pc}
    e178:	50842500 	.word	0x50842500
    e17c:	50842800 	.word	0x50842800

0000e180 <gpio_nrfx_pin_interrupt_configure>:
{
    e180:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    e182:	460e      	mov	r6, r1
	uint32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
    e184:	6841      	ldr	r1, [r0, #4]
    e186:	f006 051f 	and.w	r5, r6, #31
    e18a:	7a09      	ldrb	r1, [r1, #8]
	if ((mode == GPIO_INT_MODE_EDGE) &&
    e18c:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
	struct gpio_nrfx_data *data = get_port_data(port);
    e190:	68c7      	ldr	r7, [r0, #12]
	if ((mode == GPIO_INT_MODE_EDGE) &&
    e192:	ea45 1541 	orr.w	r5, r5, r1, lsl #5
    e196:	d111      	bne.n	e1bc <gpio_nrfx_pin_interrupt_configure+0x3c>
        case 1: return NRF_P1;
    e198:	4c5f      	ldr	r4, [pc, #380]	; (e318 <gpio_nrfx_pin_interrupt_configure+0x198>)
    e19a:	f8df c188 	ldr.w	ip, [pc, #392]	; e324 <gpio_nrfx_pin_interrupt_configure+0x1a4>
    return pin_number >> 5;
    e19e:	0968      	lsrs	r0, r5, #5
        case 1: return NRF_P1;
    e1a0:	2801      	cmp	r0, #1
    e1a2:	bf14      	ite	ne
    e1a4:	4620      	movne	r0, r4
    e1a6:	4660      	moveq	r0, ip
    *p_pin = pin_number & 0x1F;
    e1a8:	f005 011f 	and.w	r1, r5, #31
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
    e1ac:	3180      	adds	r1, #128	; 0x80
    e1ae:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
    e1b2:	07c8      	lsls	r0, r1, #31
    e1b4:	d507      	bpl.n	e1c6 <gpio_nrfx_pin_interrupt_configure+0x46>
		return -ENOTSUP;
    e1b6:	f06f 0022 	mvn.w	r0, #34	; 0x22
    e1ba:	e093      	b.n	e2e4 <gpio_nrfx_pin_interrupt_configure+0x164>
	WRITE_BIT(data->pin_int_en, pin, mode != GPIO_INT_MODE_DISABLED);
    e1bc:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
    e1c0:	68f9      	ldr	r1, [r7, #12]
    e1c2:	f000 8091 	beq.w	e2e8 <gpio_nrfx_pin_interrupt_configure+0x168>
    e1c6:	2101      	movs	r1, #1
    e1c8:	68f8      	ldr	r0, [r7, #12]
    e1ca:	40b1      	lsls	r1, r6
    e1cc:	4301      	orrs	r1, r0
    e1ce:	60f9      	str	r1, [r7, #12]
	WRITE_BIT(data->trig_edge, pin, mode == GPIO_INT_MODE_EDGE);
    e1d0:	2101      	movs	r1, #1
    e1d2:	6978      	ldr	r0, [r7, #20]
    e1d4:	40b1      	lsls	r1, r6
    e1d6:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
    e1da:	bf0c      	ite	eq
    e1dc:	4308      	orreq	r0, r1
    e1de:	4388      	bicne	r0, r1
    e1e0:	6178      	str	r0, [r7, #20]
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    e1e2:	2000      	movs	r0, #0
    e1e4:	69ba      	ldr	r2, [r7, #24]
	WRITE_BIT(data->double_edge, pin, trig == GPIO_INT_TRIG_BOTH);
    e1e6:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
    e1ea:	bf0c      	ite	eq
    e1ec:	430a      	orreq	r2, r1
    e1ee:	438a      	bicne	r2, r1
    e1f0:	61ba      	str	r2, [r7, #24]
	WRITE_BIT(data->int_active_level, pin, trig == GPIO_INT_TRIG_HIGH);
    e1f2:	693a      	ldr	r2, [r7, #16]
    e1f4:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
    e1f8:	bf0c      	ite	eq
    e1fa:	4311      	orreq	r1, r2
    e1fc:	ea22 0101 	bicne.w	r1, r2, r1
    p_reg->INTENCLR = mask;
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_int_enable_check(NRF_GPIOTE_Type const * p_reg, uint32_t mask)
{
    return p_reg->INTENSET & mask;
    e200:	4a46      	ldr	r2, [pc, #280]	; (e31c <gpio_nrfx_pin_interrupt_configure+0x19c>)
    e202:	6139      	str	r1, [r7, #16]
    e204:	f8d2 3304 	ldr.w	r3, [r2, #772]	; 0x304
    e208:	b2db      	uxtb	r3, r3
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_event_pin_get(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    e20a:	f500 71a2 	add.w	r1, r0, #324	; 0x144
    e20e:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
    e212:	f3c1 2105 	ubfx	r1, r1, #8, #6
		if ((nrf_gpiote_event_pin_get(NRF_GPIOTE, i) == abs_pin)
    e216:	428d      	cmp	r5, r1
    e218:	d16b      	bne.n	e2f2 <gpio_nrfx_pin_interrupt_configure+0x172>
		    && (intenset & BIT(i))) {
    e21a:	fa23 f100 	lsr.w	r1, r3, r0
    e21e:	07c9      	lsls	r1, r1, #31
    e220:	d567      	bpl.n	e2f2 <gpio_nrfx_pin_interrupt_configure+0x172>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Event;
    e222:	0083      	lsls	r3, r0, #2
    e224:	f103 43a0 	add.w	r3, r3, #1342177280	; 0x50000000
    e228:	f503 4350 	add.w	r3, r3, #53248	; 0xd000
    e22c:	f8d3 1510 	ldr.w	r1, [r3, #1296]	; 0x510
    e230:	f021 0101 	bic.w	r1, r1, #1
    e234:	f8c3 1510 	str.w	r1, [r3, #1296]	; 0x510
			nrf_gpiote_int_disable(NRF_GPIOTE, BIT(i));
    e238:	2301      	movs	r3, #1
    e23a:	4083      	lsls	r3, r0
    p_reg->INTENCLR = mask;
    e23c:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
			nrfx_gpiote_channel_free(i);
    e240:	b2c0      	uxtb	r0, r0
    e242:	f000 fc75 	bl	eb30 <nrfx_gpiote_channel_free>
	nrf_gpio_cfg_sense_set(abs_pin, NRF_GPIO_PIN_NOSENSE);
    e246:	4628      	mov	r0, r5
    e248:	2100      	movs	r1, #0
    e24a:	f7ff ff81 	bl	e150 <nrf_gpio_cfg_sense_set>
	if (data->pin_int_en & BIT(pin)) {
    e24e:	68f8      	ldr	r0, [r7, #12]
    e250:	40f0      	lsrs	r0, r6
    e252:	f010 0001 	ands.w	r0, r0, #1
    e256:	d045      	beq.n	e2e4 <gpio_nrfx_pin_interrupt_configure+0x164>
		if (data->trig_edge & BIT(pin)) {
    e258:	6978      	ldr	r0, [r7, #20]
    e25a:	40f0      	lsrs	r0, r6
    e25c:	f010 0401 	ands.w	r4, r0, #1
    e260:	d04e      	beq.n	e300 <gpio_nrfx_pin_interrupt_configure+0x180>
			if (data->double_edge & BIT(pin)) {
    e262:	69bb      	ldr	r3, [r7, #24]
	if (nrfx_gpiote_channel_alloc(&channel) != NRFX_SUCCESS) {
    e264:	f10d 0007 	add.w	r0, sp, #7
			if (data->double_edge & BIT(pin)) {
    e268:	40f3      	lsrs	r3, r6
    e26a:	07db      	lsls	r3, r3, #31
			} else if ((data->int_active_level & BIT(pin)) != 0U) {
    e26c:	bf57      	itett	pl
    e26e:	6939      	ldrpl	r1, [r7, #16]
				pol = NRF_GPIOTE_POLARITY_TOGGLE;
    e270:	2603      	movmi	r6, #3
			} else if ((data->int_active_level & BIT(pin)) != 0U) {
    e272:	fa21 f606 	lsrpl.w	r6, r1, r6
    e276:	f006 0601 	andpl.w	r6, r6, #1
    e27a:	bf5c      	itt	pl
    e27c:	f1c6 0602 	rsbpl	r6, r6, #2
    e280:	b2f6      	uxtbpl	r6, r6
	if (nrfx_gpiote_channel_alloc(&channel) != NRFX_SUCCESS) {
    e282:	f000 fc77 	bl	eb74 <nrfx_gpiote_channel_alloc>
    e286:	4b26      	ldr	r3, [pc, #152]	; (e320 <gpio_nrfx_pin_interrupt_configure+0x1a0>)
    e288:	4298      	cmp	r0, r3
    e28a:	d136      	bne.n	e2fa <gpio_nrfx_pin_interrupt_configure+0x17a>
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    e28c:	2000      	movs	r0, #0
	nrf_gpiote_event_t evt = offsetof(NRF_GPIOTE_Type, EVENTS_IN[channel]);
    e28e:	f89d 1007 	ldrb.w	r1, [sp, #7]
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    e292:	022d      	lsls	r5, r5, #8
    e294:	008b      	lsls	r3, r1, #2
    e296:	f103 43a0 	add.w	r3, r3, #1342177280	; 0x50000000
    e29a:	f503 4350 	add.w	r3, r3, #53248	; 0xd000
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
    e29e:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    e2a2:	f405 557c 	and.w	r5, r5, #16128	; 0x3f00
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
    e2a6:	f422 324f 	bic.w	r2, r2, #211968	; 0x33c00
    e2aa:	f422 7240 	bic.w	r2, r2, #768	; 0x300
    e2ae:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    e2b2:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
    e2b6:	4315      	orrs	r5, r2
    return ((uint32_t)p_reg + event);
    e2b8:	008a      	lsls	r2, r1, #2
    e2ba:	f102 42a0 	add.w	r2, r2, #1342177280	; 0x50000000
    e2be:	f502 4251 	add.w	r2, r2, #53504	; 0xd100
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
    e2c2:	ea45 4606 	orr.w	r6, r5, r6, lsl #16
    e2c6:	f8c3 6510 	str.w	r6, [r3, #1296]	; 0x510
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    e2ca:	6010      	str	r0, [r2, #0]
    e2cc:	6812      	ldr	r2, [r2, #0]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
    e2ce:	f8d3 2510 	ldr.w	r2, [r3, #1296]	; 0x510
    e2d2:	f042 0201 	orr.w	r2, r2, #1
    e2d6:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
	nrf_gpiote_int_enable(NRF_GPIOTE, BIT(channel));
    e2da:	2301      	movs	r3, #1
    p_reg->INTENSET = mask;
    e2dc:	4a0f      	ldr	r2, [pc, #60]	; (e31c <gpio_nrfx_pin_interrupt_configure+0x19c>)
    e2de:	408b      	lsls	r3, r1
    e2e0:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
    e2e4:	b003      	add	sp, #12
    e2e6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	WRITE_BIT(data->pin_int_en, pin, mode != GPIO_INT_MODE_DISABLED);
    e2e8:	2001      	movs	r0, #1
    e2ea:	40b0      	lsls	r0, r6
    e2ec:	ea21 0100 	bic.w	r1, r1, r0
    e2f0:	e76d      	b.n	e1ce <gpio_nrfx_pin_interrupt_configure+0x4e>
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    e2f2:	3001      	adds	r0, #1
    e2f4:	2808      	cmp	r0, #8
    e2f6:	d188      	bne.n	e20a <gpio_nrfx_pin_interrupt_configure+0x8a>
    e2f8:	e7a5      	b.n	e246 <gpio_nrfx_pin_interrupt_configure+0xc6>
		return -ENODEV;
    e2fa:	f06f 0012 	mvn.w	r0, #18
    e2fe:	e7f1      	b.n	e2e4 <gpio_nrfx_pin_interrupt_configure+0x164>
	if ((BIT(pin) & data->int_active_level) != 0U) {
    e300:	6939      	ldr	r1, [r7, #16]
			nrf_gpio_cfg_sense_set(abs_pin, sense);
    e302:	4628      	mov	r0, r5
	if ((BIT(pin) & data->int_active_level) != 0U) {
    e304:	40f1      	lsrs	r1, r6
    e306:	f001 0101 	and.w	r1, r1, #1
    e30a:	f1c1 0103 	rsb	r1, r1, #3
			nrf_gpio_cfg_sense_set(abs_pin, sense);
    e30e:	b2c9      	uxtb	r1, r1
    e310:	f7ff ff1e 	bl	e150 <nrf_gpio_cfg_sense_set>
	int res = 0;
    e314:	4620      	mov	r0, r4
    e316:	e7e5      	b.n	e2e4 <gpio_nrfx_pin_interrupt_configure+0x164>
    e318:	50842500 	.word	0x50842500
    e31c:	5000d000 	.word	0x5000d000
    e320:	0bad0000 	.word	0x0bad0000
    e324:	50842800 	.word	0x50842800

0000e328 <gpiote_event_handler>:
{
    e328:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	uint32_t fired_triggers[GPIO_COUNT] = {0};
    e32a:	2600      	movs	r6, #0
    e32c:	e9cd 6600 	strd	r6, r6, [sp]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    e330:	4d26      	ldr	r5, [pc, #152]	; (e3cc <gpiote_event_handler+0xa4>)
    e332:	682c      	ldr	r4, [r5, #0]
	if (port_event) {
    e334:	b14c      	cbz	r4, e34a <gpiote_event_handler+0x22>
			check_level_trigger_pins(DEVICE_DT_GET(GPIO(0)));
    e336:	4826      	ldr	r0, [pc, #152]	; (e3d0 <gpiote_event_handler+0xa8>)
    e338:	f002 fa0f 	bl	1075a <check_level_trigger_pins>
		fired_triggers[0] =
    e33c:	9000      	str	r0, [sp, #0]
			check_level_trigger_pins(DEVICE_DT_GET(GPIO(1)));
    e33e:	4825      	ldr	r0, [pc, #148]	; (e3d4 <gpiote_event_handler+0xac>)
    e340:	f002 fa0b 	bl	1075a <check_level_trigger_pins>
		fired_triggers[1] =
    e344:	9001      	str	r0, [sp, #4]
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    e346:	602e      	str	r6, [r5, #0]
    e348:	682b      	ldr	r3, [r5, #0]
{
    e34a:	2200      	movs	r2, #0
		if (nrf_gpiote_int_enable_check(NRF_GPIOTE, BIT(i)) &&
    e34c:	2601      	movs	r6, #1
    e34e:	4694      	mov	ip, r2
    return p_reg->INTENSET & mask;
    e350:	4d21      	ldr	r5, [pc, #132]	; (e3d8 <gpiote_event_handler+0xb0>)
    e352:	f8d5 3304 	ldr.w	r3, [r5, #772]	; 0x304
    e356:	fa06 f102 	lsl.w	r1, r6, r2
    e35a:	4219      	tst	r1, r3
    e35c:	d01b      	beq.n	e396 <gpiote_event_handler+0x6e>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    e35e:	0091      	lsls	r1, r2, #2
    e360:	f101 41a0 	add.w	r1, r1, #1342177280	; 0x50000000
    e364:	f501 4151 	add.w	r1, r1, #53504	; 0xd100
    e368:	680b      	ldr	r3, [r1, #0]
    e36a:	b1a3      	cbz	r3, e396 <gpiote_event_handler+0x6e>
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
    e36c:	f502 73a2 	add.w	r3, r2, #324	; 0x144
    e370:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
			fired_triggers[abs_pin / 32U] |= BIT(abs_pin % 32);
    e374:	af02      	add	r7, sp, #8
    e376:	f3c3 3040 	ubfx	r0, r3, #13, #1
    e37a:	eb07 0080 	add.w	r0, r7, r0, lsl #2
    e37e:	f850 7c08 	ldr.w	r7, [r0, #-8]
    e382:	f3c3 2304 	ubfx	r3, r3, #8, #5
    e386:	fa06 f303 	lsl.w	r3, r6, r3
    e38a:	433b      	orrs	r3, r7
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
    e38c:	f8c1 c000 	str.w	ip, [r1]
    e390:	f840 3c08 	str.w	r3, [r0, #-8]
    e394:	680b      	ldr	r3, [r1, #0]
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
    e396:	3201      	adds	r2, #1
    e398:	2a08      	cmp	r2, #8
    e39a:	d1da      	bne.n	e352 <gpiote_event_handler+0x2a>
	if (fired_triggers[0]) {
    e39c:	9a00      	ldr	r2, [sp, #0]
    e39e:	b11a      	cbz	r2, e3a8 <gpiote_event_handler+0x80>
	gpio_fire_callbacks(list, port, pins);
    e3a0:	490b      	ldr	r1, [pc, #44]	; (e3d0 <gpiote_event_handler+0xa8>)
    e3a2:	480e      	ldr	r0, [pc, #56]	; (e3dc <gpiote_event_handler+0xb4>)
    e3a4:	f002 f976 	bl	10694 <gpio_fire_callbacks>
	if (fired_triggers[1]) {
    e3a8:	9a01      	ldr	r2, [sp, #4]
    e3aa:	b11a      	cbz	r2, e3b4 <gpiote_event_handler+0x8c>
	gpio_fire_callbacks(list, port, pins);
    e3ac:	4909      	ldr	r1, [pc, #36]	; (e3d4 <gpiote_event_handler+0xac>)
    e3ae:	480c      	ldr	r0, [pc, #48]	; (e3e0 <gpiote_event_handler+0xb8>)
    e3b0:	f002 f970 	bl	10694 <gpio_fire_callbacks>
	if (port_event) {
    e3b4:	b144      	cbz	r4, e3c8 <gpiote_event_handler+0xa0>
		cfg_level_pins(DEVICE_DT_GET(GPIO(0)));
    e3b6:	4806      	ldr	r0, [pc, #24]	; (e3d0 <gpiote_event_handler+0xa8>)
    e3b8:	f002 f9f7 	bl	107aa <cfg_level_pins>
		cfg_level_pins(DEVICE_DT_GET(GPIO(1)));
    e3bc:	4805      	ldr	r0, [pc, #20]	; (e3d4 <gpiote_event_handler+0xac>)
}
    e3be:	b003      	add	sp, #12
    e3c0:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		cfg_level_pins(DEVICE_DT_GET(GPIO(1)));
    e3c4:	f002 b9f1 	b.w	107aa <cfg_level_pins>
}
    e3c8:	b003      	add	sp, #12
    e3ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
    e3cc:	5000d17c 	.word	0x5000d17c
    e3d0:	200000d8 	.word	0x200000d8
    e3d4:	200000e8 	.word	0x200000e8
    e3d8:	5000d000 	.word	0x5000d000
    e3dc:	20000868 	.word	0x20000868
    e3e0:	20000884 	.word	0x20000884

0000e3e4 <uarte_nrfx_configure>:
	return 0;
}

static int uarte_nrfx_configure(const struct device *dev,
				const struct uart_config *cfg)
{
    e3e4:	b5f0      	push	{r4, r5, r6, r7, lr}
	nrf_uarte_config_t uarte_cfg;

#if defined(UARTE_CONFIG_STOP_Msk)
	switch (cfg->stop_bits) {
    e3e6:	794b      	ldrb	r3, [r1, #5]
    e3e8:	2b01      	cmp	r3, #1
    e3ea:	d02b      	beq.n	e444 <uarte_nrfx_configure+0x60>
    e3ec:	2b03      	cmp	r3, #3
    e3ee:	d126      	bne.n	e43e <uarte_nrfx_configure+0x5a>
	case UART_CFG_STOP_BITS_1:
		uarte_cfg.stop = NRF_UARTE_STOP_ONE;
		break;
	case UART_CFG_STOP_BITS_2:
		uarte_cfg.stop = NRF_UARTE_STOP_TWO;
    e3f0:	2710      	movs	r7, #16
	if (cfg->stop_bits != UART_CFG_STOP_BITS_1) {
		return -ENOTSUP;
	}
#endif

	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
    e3f2:	798b      	ldrb	r3, [r1, #6]
    e3f4:	2b03      	cmp	r3, #3
    e3f6:	d122      	bne.n	e43e <uarte_nrfx_configure+0x5a>
		return -ENOTSUP;
	}

	switch (cfg->flow_ctrl) {
    e3f8:	79cd      	ldrb	r5, [r1, #7]
    e3fa:	b125      	cbz	r5, e406 <uarte_nrfx_configure+0x22>
    e3fc:	2d01      	cmp	r5, #1
    e3fe:	d11e      	bne.n	e43e <uarte_nrfx_configure+0x5a>
	case UART_CFG_FLOW_CTRL_NONE:
		uarte_cfg.hwfc = NRF_UARTE_HWFC_DISABLED;
		break;
	case UART_CFG_FLOW_CTRL_RTS_CTS:
		if (get_dev_config(dev)->rts_cts_pins_set) {
    e400:	6843      	ldr	r3, [r0, #4]
    e402:	791b      	ldrb	r3, [r3, #4]
    e404:	b1db      	cbz	r3, e43e <uarte_nrfx_configure+0x5a>
	}

#if defined(UARTE_CONFIG_PARITYTYPE_Msk)
	uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_EVEN;
#endif
	switch (cfg->parity) {
    e406:	790a      	ldrb	r2, [r1, #4]
    e408:	2a01      	cmp	r2, #1
    e40a:	d01d      	beq.n	e448 <uarte_nrfx_configure+0x64>
    e40c:	2a02      	cmp	r2, #2
    e40e:	d01f      	beq.n	e450 <uarte_nrfx_configure+0x6c>
    e410:	b9aa      	cbnz	r2, e43e <uarte_nrfx_configure+0x5a>
    e412:	4614      	mov	r4, r2
#endif
	default:
		return -ENOTSUP;
	}

	if (baudrate_set(dev, cfg->baudrate) != 0) {
    e414:	680b      	ldr	r3, [r1, #0]
	return config->uarte_regs;
    e416:	6846      	ldr	r6, [r0, #4]
	switch (baudrate) {
    e418:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
	return config->uarte_regs;
    e41c:	6836      	ldr	r6, [r6, #0]
	switch (baudrate) {
    e41e:	d06e      	beq.n	e4fe <uarte_nrfx_configure+0x11a>
    e420:	d833      	bhi.n	e48a <uarte_nrfx_configure+0xa6>
    e422:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
    e426:	d06d      	beq.n	e504 <uarte_nrfx_configure+0x120>
    e428:	d81c      	bhi.n	e464 <uarte_nrfx_configure+0x80>
    e42a:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
    e42e:	d06b      	beq.n	e508 <uarte_nrfx_configure+0x124>
    e430:	d810      	bhi.n	e454 <uarte_nrfx_configure+0x70>
    e432:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
    e436:	d06a      	beq.n	e50e <uarte_nrfx_configure+0x12a>
    e438:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
    e43c:	d06a      	beq.n	e514 <uarte_nrfx_configure+0x130>
    e43e:	f06f 0022 	mvn.w	r0, #34	; 0x22
    e442:	e05b      	b.n	e4fc <uarte_nrfx_configure+0x118>
	switch (cfg->stop_bits) {
    e444:	2700      	movs	r7, #0
    e446:	e7d4      	b.n	e3f2 <uarte_nrfx_configure+0xe>
		uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_ODD;
    e448:	f44f 7480 	mov.w	r4, #256	; 0x100
		uarte_cfg.parity = NRF_UARTE_PARITY_INCLUDED;
    e44c:	220e      	movs	r2, #14
    e44e:	e7e1      	b.n	e414 <uarte_nrfx_configure+0x30>
	uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_EVEN;
    e450:	2400      	movs	r4, #0
    e452:	e7fb      	b.n	e44c <uarte_nrfx_configure+0x68>
	switch (baudrate) {
    e454:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
    e458:	d05f      	beq.n	e51a <uarte_nrfx_configure+0x136>
    e45a:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
    e45e:	d1ee      	bne.n	e43e <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_4800;
    e460:	4b38      	ldr	r3, [pc, #224]	; (e544 <uarte_nrfx_configure+0x160>)
    e462:	e03e      	b.n	e4e2 <uarte_nrfx_configure+0xfe>
	switch (baudrate) {
    e464:	f5b3 4fe1 	cmp.w	r3, #28800	; 0x7080
    e468:	d05a      	beq.n	e520 <uarte_nrfx_configure+0x13c>
    e46a:	d807      	bhi.n	e47c <uarte_nrfx_configure+0x98>
    e46c:	f5b3 5f61 	cmp.w	r3, #14400	; 0x3840
    e470:	d058      	beq.n	e524 <uarte_nrfx_configure+0x140>
    e472:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
    e476:	d1e2      	bne.n	e43e <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_19200;
    e478:	4b33      	ldr	r3, [pc, #204]	; (e548 <uarte_nrfx_configure+0x164>)
    e47a:	e032      	b.n	e4e2 <uarte_nrfx_configure+0xfe>
	switch (baudrate) {
    e47c:	f647 2c12 	movw	ip, #31250	; 0x7a12
    e480:	4563      	cmp	r3, ip
    e482:	d1dc      	bne.n	e43e <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_31250;
    e484:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
    e488:	e02b      	b.n	e4e2 <uarte_nrfx_configure+0xfe>
	switch (baudrate) {
    e48a:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
    e48e:	d04b      	beq.n	e528 <uarte_nrfx_configure+0x144>
    e490:	d813      	bhi.n	e4ba <uarte_nrfx_configure+0xd6>
    e492:	f5b3 3f96 	cmp.w	r3, #76800	; 0x12c00
    e496:	d04a      	beq.n	e52e <uarte_nrfx_configure+0x14a>
    e498:	d809      	bhi.n	e4ae <uarte_nrfx_configure+0xca>
    e49a:	f64d 2cc0 	movw	ip, #56000	; 0xdac0
    e49e:	4563      	cmp	r3, ip
    e4a0:	d047      	beq.n	e532 <uarte_nrfx_configure+0x14e>
    e4a2:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
    e4a6:	d1ca      	bne.n	e43e <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_57600;
    e4a8:	f44f 036b 	mov.w	r3, #15400960	; 0xeb0000
    e4ac:	e019      	b.n	e4e2 <uarte_nrfx_configure+0xfe>
	switch (baudrate) {
    e4ae:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
    e4b2:	d1c4      	bne.n	e43e <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_115200;
    e4b4:	f04f 73eb 	mov.w	r3, #30801920	; 0x1d60000
    e4b8:	e013      	b.n	e4e2 <uarte_nrfx_configure+0xfe>
	switch (baudrate) {
    e4ba:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
    e4be:	d03b      	beq.n	e538 <uarte_nrfx_configure+0x154>
    e4c0:	d809      	bhi.n	e4d6 <uarte_nrfx_configure+0xf2>
    e4c2:	f8df c098 	ldr.w	ip, [pc, #152]	; e55c <uarte_nrfx_configure+0x178>
    e4c6:	4563      	cmp	r3, ip
    e4c8:	d039      	beq.n	e53e <uarte_nrfx_configure+0x15a>
    e4ca:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
    e4ce:	d1b6      	bne.n	e43e <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_460800;
    e4d0:	f04f 63e8 	mov.w	r3, #121634816	; 0x7400000
    e4d4:	e005      	b.n	e4e2 <uarte_nrfx_configure+0xfe>
	switch (baudrate) {
    e4d6:	f8df c088 	ldr.w	ip, [pc, #136]	; e560 <uarte_nrfx_configure+0x17c>
    e4da:	4563      	cmp	r3, ip
    e4dc:	d1af      	bne.n	e43e <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1000000;
    e4de:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type * p_reg, nrf_uarte_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
    e4e2:	f8c6 3524 	str.w	r3, [r6, #1316]	; 0x524
		return -ENOTSUP;
	}

	nrf_uarte_configure(get_uarte_instance(dev), &uarte_cfg);

	get_dev_data(dev)->uart_config = *cfg;
    e4e6:	68c3      	ldr	r3, [r0, #12]
                    | (uint32_t)p_cfg->hwfc;
    e4e8:	432c      	orrs	r4, r5
                    | (uint32_t)p_cfg->stop
    e4ea:	433a      	orrs	r2, r7
                    | (uint32_t)p_cfg->hwfc;
    e4ec:	4322      	orrs	r2, r4
    e4ee:	3304      	adds	r3, #4
    e4f0:	c903      	ldmia	r1, {r0, r1}
    p_reg->CONFIG = (uint32_t)p_cfg->parity
    e4f2:	f8c6 256c 	str.w	r2, [r6, #1388]	; 0x56c
    e4f6:	e883 0003 	stmia.w	r3, {r0, r1}

	return 0;
    e4fa:	2000      	movs	r0, #0
}
    e4fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
		nrf_baudrate = NRF_UARTE_BAUDRATE_38400;
    e4fe:	f44f 031d 	mov.w	r3, #10289152	; 0x9d0000
    e502:	e7ee      	b.n	e4e2 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_9600;
    e504:	4b11      	ldr	r3, [pc, #68]	; (e54c <uarte_nrfx_configure+0x168>)
    e506:	e7ec      	b.n	e4e2 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1200;
    e508:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
    e50c:	e7e9      	b.n	e4e2 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = 0x00014000;
    e50e:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
    e512:	e7e6      	b.n	e4e2 <uarte_nrfx_configure+0xfe>
	switch (baudrate) {
    e514:	f44f 331c 	mov.w	r3, #159744	; 0x27000
    e518:	e7e3      	b.n	e4e2 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_2400;
    e51a:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
    e51e:	e7e0      	b.n	e4e2 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
    e520:	4b0b      	ldr	r3, [pc, #44]	; (e550 <uarte_nrfx_configure+0x16c>)
    e522:	e7de      	b.n	e4e2 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_14400;
    e524:	4b0b      	ldr	r3, [pc, #44]	; (e554 <uarte_nrfx_configure+0x170>)
    e526:	e7dc      	b.n	e4e2 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_230400;
    e528:	f04f 736c 	mov.w	r3, #61865984	; 0x3b00000
    e52c:	e7d9      	b.n	e4e2 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_76800;
    e52e:	4b0a      	ldr	r3, [pc, #40]	; (e558 <uarte_nrfx_configure+0x174>)
    e530:	e7d7      	b.n	e4e2 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_56000;
    e532:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
    e536:	e7d4      	b.n	e4e2 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_921600;
    e538:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
    e53c:	e7d1      	b.n	e4e2 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_250000;
    e53e:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
    e542:	e7ce      	b.n	e4e2 <uarte_nrfx_configure+0xfe>
    e544:	0013b000 	.word	0x0013b000
    e548:	004ea000 	.word	0x004ea000
    e54c:	00275000 	.word	0x00275000
    e550:	0075c000 	.word	0x0075c000
    e554:	003af000 	.word	0x003af000
    e558:	013a9000 	.word	0x013a9000
    e55c:	0003d090 	.word	0x0003d090
    e560:	000f4240 	.word	0x000f4240

0000e564 <uarte_nrfx_poll_out>:
 *
 * @param dev UARTE device struct
 * @param c Character to send
 */
static void uarte_nrfx_poll_out(const struct device *dev, unsigned char c)
{
    e564:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    e568:	4606      	mov	r6, r0
    e56a:	4688      	mov	r8, r1
	struct uarte_nrfx_data *data = get_dev_data(dev);
    e56c:	68c7      	ldr	r7, [r0, #12]
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
    e56e:	f002 fa9e 	bl	10aae <k_is_in_isr>
    e572:	b9b8      	cbnz	r0, e5a4 <uarte_nrfx_poll_out+0x40>
	return !z_sys_post_kernel;
    e574:	4b28      	ldr	r3, [pc, #160]	; (e618 <uarte_nrfx_poll_out+0xb4>)
    e576:	781b      	ldrb	r3, [r3, #0]
    e578:	f083 0301 	eor.w	r3, r3, #1
	return config->uarte_regs;
    e57c:	6872      	ldr	r2, [r6, #4]
    e57e:	6815      	ldr	r5, [r2, #0]
#ifdef CONFIG_PM_DEVICE
	if (data->pm_state != DEVICE_PM_ACTIVE_STATE) {
		return;
	}
#endif
	if (isr_mode) {
    e580:	b193      	cbz	r3, e5a8 <uarte_nrfx_poll_out+0x44>
    e582:	f04f 0320 	mov.w	r3, #32
    e586:	f3ef 8411 	mrs	r4, BASEPRI
    e58a:	f383 8811 	msr	BASEPRI, r3
    e58e:	f3bf 8f6f 	isb	sy
		while (1) {
			key = irq_lock();
			if (is_tx_ready(dev)) {
    e592:	4630      	mov	r0, r6
    e594:	f002 f95e 	bl	10854 <is_tx_ready>
    e598:	bb38      	cbnz	r0, e5ea <uarte_nrfx_poll_out+0x86>
	__asm__ volatile(
    e59a:	f384 8811 	msr	BASEPRI, r4
    e59e:	f3bf 8f6f 	isb	sy
		"cpsie i;"
		: : : "memory", "cc");
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
}
    e5a2:	e7ee      	b.n	e582 <uarte_nrfx_poll_out+0x1e>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
    e5a4:	2301      	movs	r3, #1
    e5a6:	e7e9      	b.n	e57c <uarte_nrfx_poll_out+0x18>
    e5a8:	2464      	movs	r4, #100	; 0x64
		NRFX_WAIT_FOR(is_tx_ready(dev), 100, 1, res);
    e5aa:	4630      	mov	r0, r6
    e5ac:	f002 f952 	bl	10854 <is_tx_ready>
    e5b0:	b970      	cbnz	r0, e5d0 <uarte_nrfx_poll_out+0x6c>
    e5b2:	2001      	movs	r0, #1
    e5b4:	f002 f97e 	bl	108b4 <nrfx_busy_wait>
    e5b8:	3c01      	subs	r4, #1
    e5ba:	d1f6      	bne.n	e5aa <uarte_nrfx_poll_out+0x46>
	return z_impl_k_sleep(timeout);
    e5bc:	2100      	movs	r1, #0
    e5be:	2021      	movs	r0, #33	; 0x21
    e5c0:	f001 f8fc 	bl	f7bc <z_impl_k_sleep>
	return k_sleep(Z_TIMEOUT_MS(ms));
    e5c4:	e7f0      	b.n	e5a8 <uarte_nrfx_poll_out+0x44>
	__asm__ volatile(
    e5c6:	f384 8811 	msr	BASEPRI, r4
    e5ca:	f3bf 8f6f 	isb	sy
}
    e5ce:	e7f5      	b.n	e5bc <uarte_nrfx_poll_out+0x58>
	__asm__ volatile(
    e5d0:	f04f 0320 	mov.w	r3, #32
    e5d4:	f3ef 8411 	mrs	r4, BASEPRI
    e5d8:	f383 8811 	msr	BASEPRI, r3
    e5dc:	f3bf 8f6f 	isb	sy
			if (is_tx_ready(dev)) {
    e5e0:	4630      	mov	r0, r6
    e5e2:	f002 f937 	bl	10854 <is_tx_ready>
    e5e6:	2800      	cmp	r0, #0
    e5e8:	d0ed      	beq.n	e5c6 <uarte_nrfx_poll_out+0x62>
NRF_STATIC_INLINE void nrf_uarte_tx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t  const * p_buffer,
                                               size_t           length)
{
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    p_reg->TXD.MAXCNT = length;
    e5ea:	2301      	movs	r3, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    e5ec:	2200      	movs	r2, #0
	}

	/* At this point we should have irq locked and any previous transfer
	 * completed. Transfer can be started, no need to wait for completion.
	 */
	data->char_out = c;
    e5ee:	f807 8f10 	strb.w	r8, [r7, #16]!
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    e5f2:	f8c5 7544 	str.w	r7, [r5, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
    e5f6:	f8c5 3548 	str.w	r3, [r5, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    e5fa:	f8c5 2120 	str.w	r2, [r5, #288]	; 0x120
    e5fe:	f8d5 1120 	ldr.w	r1, [r5, #288]	; 0x120
    e602:	f8c5 2158 	str.w	r2, [r5, #344]	; 0x158
    e606:	f8d5 2158 	ldr.w	r2, [r5, #344]	; 0x158
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    e60a:	60ab      	str	r3, [r5, #8]
	__asm__ volatile(
    e60c:	f384 8811 	msr	BASEPRI, r4
    e610:	f3bf 8f6f 	isb	sy
	tx_start(uarte, &data->char_out, 1);

	irq_unlock(key);
}
    e614:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    e618:	20000966 	.word	0x20000966

0000e61c <nrf_gpio_cfg_output>:
        case 1: return NRF_P1;
    e61c:	4b07      	ldr	r3, [pc, #28]	; (e63c <nrf_gpio_cfg_output+0x20>)
    e61e:	4908      	ldr	r1, [pc, #32]	; (e640 <nrf_gpio_cfg_output+0x24>)
    *p_pin = pin_number & 0x1F;
    e620:	f000 021f 	and.w	r2, r0, #31
    return pin_number >> 5;
    e624:	0940      	lsrs	r0, r0, #5
        case 1: return NRF_P1;
    e626:	2801      	cmp	r0, #1
    e628:	bf14      	ite	ne
    e62a:	4618      	movne	r0, r3
    e62c:	4608      	moveq	r0, r1
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    e62e:	f102 0380 	add.w	r3, r2, #128	; 0x80
    e632:	2203      	movs	r2, #3
    e634:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
}
    e638:	4770      	bx	lr
    e63a:	bf00      	nop
    e63c:	50842500 	.word	0x50842500
    e640:	50842800 	.word	0x50842800

0000e644 <nrf_gpio_pin_set>:
        case 1: return NRF_P1;
    e644:	4b06      	ldr	r3, [pc, #24]	; (e660 <nrf_gpio_pin_set+0x1c>)
    e646:	4907      	ldr	r1, [pc, #28]	; (e664 <nrf_gpio_pin_set+0x20>)
    *p_pin = pin_number & 0x1F;
    e648:	f000 021f 	and.w	r2, r0, #31
    return pin_number >> 5;
    e64c:	0940      	lsrs	r0, r0, #5
        case 1: return NRF_P1;
    e64e:	2801      	cmp	r0, #1
    e650:	bf14      	ite	ne
    e652:	4618      	movne	r0, r3
    e654:	4608      	moveq	r0, r1
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    e656:	2301      	movs	r3, #1
    e658:	4093      	lsls	r3, r2
    p_reg->OUTSET = set_mask;
    e65a:	6083      	str	r3, [r0, #8]
}
    e65c:	4770      	bx	lr
    e65e:	bf00      	nop
    e660:	50842500 	.word	0x50842500
    e664:	50842800 	.word	0x50842800

0000e668 <uarte_0_init>:
				.tx_buffer = uarte##idx##_tx_buffer,	       \
				.tx_buff_size = sizeof(uarte##idx##_tx_buffer),\
			};))

#ifdef CONFIG_UART_0_NRF_UARTE
UART_NRF_UARTE_DEVICE(0);
    e668:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    e66a:	4605      	mov	r5, r0
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
    e66c:	2700      	movs	r7, #0
    e66e:	2101      	movs	r1, #1
    e670:	2200      	movs	r2, #0
    e672:	2008      	movs	r0, #8
    e674:	f7ff f942 	bl	d8fc <z_arm_irq_priority_set>
    e678:	2008      	movs	r0, #8
    e67a:	f7ff f921 	bl	d8c0 <arch_irq_enable>
	return config->uarte_regs;
    e67e:	686b      	ldr	r3, [r5, #4]
	struct uarte_nrfx_data *data = get_dev_data(dev);
    e680:	68ee      	ldr	r6, [r5, #12]
	return config->uarte_regs;
    e682:	681c      	ldr	r4, [r3, #0]
        nrf_gpio_pin_set(pin_number);
    e684:	2014      	movs	r0, #20
    e686:	f8c4 7500 	str.w	r7, [r4, #1280]	; 0x500
	data->dev = dev;
    e68a:	6035      	str	r5, [r6, #0]
    e68c:	f7ff ffda 	bl	e644 <nrf_gpio_pin_set>
	nrf_gpio_cfg_output(config->pseltxd);
    e690:	2014      	movs	r0, #20
    e692:	f7ff ffc3 	bl	e61c <nrf_gpio_cfg_output>
    p_reg->PSEL.TXD = pseltxd;
    e696:	2214      	movs	r2, #20
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    e698:	4b2c      	ldr	r3, [pc, #176]	; (e74c <uarte_0_init+0xe4>)
        nrf_gpio_pin_set(pin_number);
    e69a:	2013      	movs	r0, #19
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
    e69c:	f8c3 7258 	str.w	r7, [r3, #600]	; 0x258
    e6a0:	f8c4 250c 	str.w	r2, [r4, #1292]	; 0x50c
    p_reg->PSEL.RXD = pselrxd;
    e6a4:	2216      	movs	r2, #22
    e6a6:	f8c4 2514 	str.w	r2, [r4, #1300]	; 0x514
    e6aa:	f8c3 7254 	str.w	r7, [r3, #596]	; 0x254
        nrf_gpio_pin_set(pin_number);
    e6ae:	f7ff ffc9 	bl	e644 <nrf_gpio_pin_set>
		nrf_gpio_cfg_output(config->pselrts);
    e6b2:	2013      	movs	r0, #19
    e6b4:	f7ff ffb2 	bl	e61c <nrf_gpio_cfg_output>
    p_reg->PSEL.RTS = pselrts;
    e6b8:	2313      	movs	r3, #19
    e6ba:	f8c4 3508 	str.w	r3, [r4, #1288]	; 0x508
    p_reg->PSEL.CTS = pselcts;
    e6be:	2315      	movs	r3, #21
	err = uarte_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
    e6c0:	68e9      	ldr	r1, [r5, #12]
    e6c2:	4628      	mov	r0, r5
    e6c4:	f8c4 3510 	str.w	r3, [r4, #1296]	; 0x510
    e6c8:	3104      	adds	r1, #4
    e6ca:	f7ff fe8b 	bl	e3e4 <uarte_nrfx_configure>
	if (err) {
    e6ce:	4607      	mov	r7, r0
    e6d0:	2800      	cmp	r0, #0
    e6d2:	d136      	bne.n	e742 <uarte_0_init+0xda>
	if (get_dev_config(dev)->ppi_endtx) {
    e6d4:	686b      	ldr	r3, [r5, #4]
    e6d6:	799b      	ldrb	r3, [r3, #6]
    e6d8:	b19b      	cbz	r3, e702 <uarte_0_init+0x9a>
	ret = gppi_channel_alloc(&data->ppi_ch_endtx);
    e6da:	f106 0012 	add.w	r0, r6, #18
    e6de:	f000 fa0b 	bl	eaf8 <nrfx_dppi_channel_alloc>
	if (ret != NRFX_SUCCESS) {
    e6e2:	4b1b      	ldr	r3, [pc, #108]	; (e750 <uarte_0_init+0xe8>)
    e6e4:	4298      	cmp	r0, r3
    e6e6:	d12e      	bne.n	e746 <uarte_0_init+0xde>
}

__STATIC_INLINE void nrfx_gppi_event_endpoint_setup(uint8_t channel, uint32_t eep)
{
    NRFX_ASSERT(eep);
    *((volatile uint32_t *)(eep + 0x80uL)) = ((uint32_t)channel | DPPIC_SUBSCRIBE_CHG_EN_EN_Msk);
    e6e8:	7cb3      	ldrb	r3, [r6, #18]
    e6ea:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    e6ee:	f8c4 31a0 	str.w	r3, [r4, #416]	; 0x1a0
}

__STATIC_INLINE void nrfx_gppi_task_endpoint_setup(uint8_t channel, uint32_t tep)
{
    NRFX_ASSERT(tep);
    *((volatile uint32_t *)(tep + 0x80uL)) = ((uint32_t)channel | DPPIC_SUBSCRIBE_CHG_EN_EN_Msk);
    e6f2:	f8c4 308c 	str.w	r3, [r4, #140]	; 0x8c
	nrfx_gppi_channels_enable(BIT(data->ppi_ch_endtx));
    e6f6:	2301      	movs	r3, #1
    e6f8:	7cb2      	ldrb	r2, [r6, #18]
    e6fa:	4093      	lsls	r3, r2
    p_reg->CHENCLR = 0xFFFFFFFFuL;
}

NRF_STATIC_INLINE void nrf_dppi_channels_enable(NRF_DPPIC_Type * p_reg, uint32_t mask)
{
    p_reg->CHENSET = mask;
    e6fc:	4a15      	ldr	r2, [pc, #84]	; (e754 <uarte_0_init+0xec>)
    e6fe:	f8c2 3504 	str.w	r3, [r2, #1284]	; 0x504
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
    e702:	2308      	movs	r3, #8
    e704:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    e708:	2300      	movs	r3, #0
    e70a:	f8c4 3110 	str.w	r3, [r4, #272]	; 0x110
    e70e:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
			nrf_uarte_rx_buffer_set(uarte, &data->rx_data, 1);
    e712:	f106 0311 	add.w	r3, r6, #17

NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t *        p_buffer,
                                               size_t           length)
{
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
    e716:	f8c4 3534 	str.w	r3, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
    e71a:	2301      	movs	r3, #1
    e71c:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    e720:	6023      	str	r3, [r4, #0]
	if (!get_dev_config(dev)->ppi_endtx) {
    e722:	686b      	ldr	r3, [r5, #4]
    e724:	799b      	ldrb	r3, [r3, #6]
    e726:	b91b      	cbnz	r3, e730 <uarte_0_init+0xc8>
    p_reg->INTENSET = mask;
    e728:	f44f 7380 	mov.w	r3, #256	; 0x100
    e72c:	f8c4 3304 	str.w	r3, [r4, #772]	; 0x304
    p_reg->TXD.MAXCNT = length;
    e730:	2300      	movs	r3, #0
	nrf_uarte_tx_buffer_set(uarte, &data->char_out, 0);
    e732:	3610      	adds	r6, #16
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
    e734:	f8c4 6544 	str.w	r6, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
    e738:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    e73c:	2301      	movs	r3, #1
    e73e:	60a3      	str	r3, [r4, #8]
    e740:	60e3      	str	r3, [r4, #12]
UART_NRF_UARTE_DEVICE(0);
    e742:	4638      	mov	r0, r7
    e744:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -EIO;
    e746:	f06f 0704 	mvn.w	r7, #4
UART_NRF_UARTE_DEVICE(0);
    e74a:	e7fa      	b.n	e742 <uarte_0_init+0xda>
    e74c:	50842500 	.word	0x50842500
    e750:	0bad0000 	.word	0x0bad0000
    e754:	50017000 	.word	0x50017000

0000e758 <nrf53_errata_42>:
    #ifndef NRF53_SERIES
        return false;
    #else
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined(NRF_APPLICATION)
                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
    e758:	4b06      	ldr	r3, [pc, #24]	; (e774 <nrf53_errata_42+0x1c>)
                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
            #endif
        #endif
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined (NRF_APPLICATION)
                if (var1 == 0x07)
    e75a:	681b      	ldr	r3, [r3, #0]
    e75c:	2b07      	cmp	r3, #7
    e75e:	d107      	bne.n	e770 <nrf53_errata_42+0x18>
                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
    e760:	4b05      	ldr	r3, [pc, #20]	; (e778 <nrf53_errata_42+0x20>)
    e762:	681b      	ldr	r3, [r3, #0]
    e764:	3b02      	subs	r3, #2
    e766:	2b03      	cmp	r3, #3
    e768:	d802      	bhi.n	e770 <nrf53_errata_42+0x18>
    e76a:	4a04      	ldr	r2, [pc, #16]	; (e77c <nrf53_errata_42+0x24>)
    e76c:	5cd0      	ldrb	r0, [r2, r3]
    e76e:	4770      	bx	lr
                            return false;
                    }
                }
            #endif
        #endif
        return false;
    e770:	2000      	movs	r0, #0
    #endif
}
    e772:	4770      	bx	lr
    e774:	00ff0130 	.word	0x00ff0130
    e778:	00ff0134 	.word	0x00ff0134
    e77c:	00011083 	.word	0x00011083

0000e780 <SystemCoreClockUpdate>:
void SystemCoreClockUpdate(void)
{
#if defined(NRF_TRUSTZONE_NONSECURE)
    SystemCoreClock = __SYSTEM_CLOCK_MAX >> (NRF_CLOCK_NS->HFCLKCTRL & (CLOCK_HFCLKCTRL_HCLK_Msk));
#else
    SystemCoreClock = __SYSTEM_CLOCK_MAX >> (NRF_CLOCK_S->HFCLKCTRL & (CLOCK_HFCLKCTRL_HCLK_Msk));
    e780:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    e784:	f8d3 2558 	ldr.w	r2, [r3, #1368]	; 0x558
    e788:	4b03      	ldr	r3, [pc, #12]	; (e798 <SystemCoreClockUpdate+0x18>)
    e78a:	f002 0203 	and.w	r2, r2, #3
    e78e:	40d3      	lsrs	r3, r2
    e790:	4a02      	ldr	r2, [pc, #8]	; (e79c <SystemCoreClockUpdate+0x1c>)
    e792:	6013      	str	r3, [r2, #0]
#endif
}
    e794:	4770      	bx	lr
    e796:	bf00      	nop
    e798:	07a12000 	.word	0x07a12000
    e79c:	2000003c 	.word	0x2000003c

0000e7a0 <SystemInit>:

void SystemInit(void)
{
    e7a0:	b508      	push	{r3, lr}
          SAU->CTRL |= (1 << SAU_CTRL_ALLNS_Pos);
        #endif

        /* Workaround for Errata 97 "ERASEPROTECT, APPROTECT, or startup problems" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf53_errata_97())
    e7a2:	f7ff ffd9 	bl	e758 <nrf53_errata_42>
    e7a6:	b148      	cbz	r0, e7bc <SystemInit+0x1c>
        {
            if (*((volatile uint32_t *)0x50004A20ul) == 0)
    e7a8:	4b35      	ldr	r3, [pc, #212]	; (e880 <SystemInit+0xe0>)
    e7aa:	681a      	ldr	r2, [r3, #0]
    e7ac:	b932      	cbnz	r2, e7bc <SystemInit+0x1c>
            {
                *((volatile uint32_t *)0x50004A20ul) = 0xDul;
    e7ae:	210d      	movs	r1, #13
    e7b0:	6019      	str	r1, [r3, #0]
                *((volatile uint32_t *)0x5000491Cul) = 0x1ul;
    e7b2:	2101      	movs	r1, #1
    e7b4:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
    e7b8:	6019      	str	r1, [r3, #0]
                *((volatile uint32_t *)0x5000491Cul) = 0x0ul;
    e7ba:	601a      	str	r2, [r3, #0]
{
    e7bc:	2200      	movs	r2, #0
    e7be:	00d3      	lsls	r3, r2, #3
    e7c0:	f503 037f 	add.w	r3, r3, #16711680	; 0xff0000
        }

        /* Trimming of the device. Copy all the trimming values from FICR into the target addresses. Trim
         until one ADDR is not initialized. */
        uint32_t index = 0;
        for (index = 0; index < 32ul && NRF_FICR_S->TRIMCNF[index].ADDR != (uint32_t *)0xFFFFFFFFul; index++){
    e7c4:	f8d3 1300 	ldr.w	r1, [r3, #768]	; 0x300
    e7c8:	3101      	adds	r1, #1
    e7ca:	d007      	beq.n	e7dc <SystemInit+0x3c>
            #if defined ( __ICCARM__ )
                /* IAR will complain about the order of volatile pointer accesses. */
                #pragma diag_suppress=Pa082
            #endif
            *NRF_FICR_S->TRIMCNF[index].ADDR = NRF_FICR_S->TRIMCNF[index].DATA;
    e7cc:	f8d3 1300 	ldr.w	r1, [r3, #768]	; 0x300
        for (index = 0; index < 32ul && NRF_FICR_S->TRIMCNF[index].ADDR != (uint32_t *)0xFFFFFFFFul; index++){
    e7d0:	3201      	adds	r2, #1
            *NRF_FICR_S->TRIMCNF[index].ADDR = NRF_FICR_S->TRIMCNF[index].DATA;
    e7d2:	f8d3 3304 	ldr.w	r3, [r3, #772]	; 0x304
        for (index = 0; index < 32ul && NRF_FICR_S->TRIMCNF[index].ADDR != (uint32_t *)0xFFFFFFFFul; index++){
    e7d6:	2a20      	cmp	r2, #32
            *NRF_FICR_S->TRIMCNF[index].ADDR = NRF_FICR_S->TRIMCNF[index].DATA;
    e7d8:	600b      	str	r3, [r1, #0]
        for (index = 0; index < 32ul && NRF_FICR_S->TRIMCNF[index].ADDR != (uint32_t *)0xFFFFFFFFul; index++){
    e7da:	d1f0      	bne.n	e7be <SystemInit+0x1e>
        }

        /* errata 64 must be before errata 42, as errata 42 is dependant on the changes in errata 64*/
        /* Workaround for Errata 64 "VREGMAIN has invalid configuration when CPU is running at 128 MHz" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf53_errata_64())
    e7dc:	f7ff ffbc 	bl	e758 <nrf53_errata_42>
    e7e0:	2800      	cmp	r0, #0
    e7e2:	d146      	bne.n	e872 <SystemInit+0xd2>
            *((volatile uint32_t *)0x5000473Cul) = 0x3ul;
        }

        /* Workaround for Errata 42 "Reset value of HFCLKCTRL is invalid" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf53_errata_42())
    e7e4:	f7ff ffb8 	bl	e758 <nrf53_errata_42>
    e7e8:	b138      	cbz	r0, e7fa <SystemInit+0x5a>
        {
            *((volatile uint32_t *)0x50039530ul) = 0xBEEF0044ul;
    e7ea:	4b26      	ldr	r3, [pc, #152]	; (e884 <SystemInit+0xe4>)
    e7ec:	4a26      	ldr	r2, [pc, #152]	; (e888 <SystemInit+0xe8>)
    e7ee:	601a      	str	r2, [r3, #0]
            NRF_CLOCK_S->HFCLKCTRL = CLOCK_HFCLKCTRL_HCLK_Div2 << CLOCK_HFCLKCTRL_HCLK_Pos;
    e7f0:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    e7f4:	2201      	movs	r2, #1
    e7f6:	f8c3 2558 	str.w	r2, [r3, #1368]	; 0x558
    #ifndef NRF53_SERIES
        return false;
    #else
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined(NRF_APPLICATION)
                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
    e7fa:	4b24      	ldr	r3, [pc, #144]	; (e88c <SystemInit+0xec>)
                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
            #endif
        #endif
        #if defined (NRF5340_XXAA) || defined (DEVELOP_IN_NRF5340)
            #if defined (NRF_APPLICATION)
                if (var1 == 0x07)
    e7fc:	681b      	ldr	r3, [r3, #0]
    e7fe:	2b07      	cmp	r3, #7

        /* Workaround for Errata 46 "Higher power consumption of LFRC" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf53_errata_46())
        {
            *((volatile uint32_t *)0x5003254Cul) = 0;
    e800:	bf02      	ittt	eq
    e802:	2200      	moveq	r2, #0
    e804:	4b22      	ldreq	r3, [pc, #136]	; (e890 <SystemInit+0xf0>)
    e806:	601a      	streq	r2, [r3, #0]
        }

        /* Workaround for Errata 49 "SLEEPENTER and SLEEPEXIT events asserted after pin reset" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf53_errata_49())
    e808:	f7ff ffa6 	bl	e758 <nrf53_errata_42>
    e80c:	b150      	cbz	r0, e824 <SystemInit+0x84>
        {
            if (NRF_RESET_S->RESETREAS & RESET_RESETREAS_RESETPIN_Msk)
    e80e:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    e812:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    e816:	07d1      	lsls	r1, r2, #31
            {
                NRF_POWER_S->EVENTS_SLEEPENTER = 0;
    e818:	bf42      	ittt	mi
    e81a:	2200      	movmi	r2, #0
    e81c:	f8c3 2114 	strmi.w	r2, [r3, #276]	; 0x114
                NRF_POWER_S->EVENTS_SLEEPEXIT = 0;
    e820:	f8c3 2118 	strmi.w	r2, [r3, #280]	; 0x118
                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
    e824:	4b19      	ldr	r3, [pc, #100]	; (e88c <SystemInit+0xec>)
                if (var1 == 0x07)
    e826:	681b      	ldr	r3, [r3, #0]
    e828:	2b07      	cmp	r3, #7
    e82a:	d109      	bne.n	e840 <SystemInit+0xa0>

        /* Workaround for Errata 55 "Bits in RESETREAS are set when they should not be" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf53_errata_55())
        {
            if (NRF_RESET_S->RESETREAS & RESET_RESETREAS_RESETPIN_Msk){
    e82c:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    e830:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    e834:	07d2      	lsls	r2, r2, #31
                NRF_RESET_S->RESETREAS = ~RESET_RESETREAS_RESETPIN_Msk;
    e836:	bf44      	itt	mi
    e838:	f06f 0201 	mvnmi.w	r2, #1
    e83c:	f8c3 2400 	strmi.w	r2, [r3, #1024]	; 0x400
            }
        }

        /* Workaround for Errata 69 "VREGMAIN configuration is not retained in System OFF" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf53_errata_69())
    e840:	f7ff ff8a 	bl	e758 <nrf53_errata_42>
    e844:	b110      	cbz	r0, e84c <SystemInit+0xac>
        {
            *((volatile uint32_t *)0x5000470Cul) =0x65ul;
    e846:	2265      	movs	r2, #101	; 0x65
    e848:	4b12      	ldr	r3, [pc, #72]	; (e894 <SystemInit+0xf4>)
    e84a:	601a      	str	r2, [r3, #0]

        #endif

        /* Allow Non-Secure code to run FPU instructions.
         * If only the secure code should control FPU power state these registers should be configured accordingly in the secure application code. */
        SCB->NSACR |= (3UL << 10);
    e84c:	4a12      	ldr	r2, [pc, #72]	; (e898 <SystemInit+0xf8>)
    e84e:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
    e852:	f443 6340 	orr.w	r3, r3, #3072	; 0xc00
    e856:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
                /* Do nothing, allow user code to handle APPROTECT. Use this if you want to enable authenticated debug. */

        #else
            /* Load APPROTECT soft branch from UICR.
               If UICR->APPROTECT is disabled, CTRLAP->APPROTECT will be disabled. */
            NRF_CTRLAP_S->APPROTECT.DISABLE = NRF_UICR_S->APPROTECT;
    e85a:	4a10      	ldr	r2, [pc, #64]	; (e89c <SystemInit+0xfc>)
    e85c:	4b10      	ldr	r3, [pc, #64]	; (e8a0 <SystemInit+0x100>)
    e85e:	6811      	ldr	r1, [r2, #0]
    e860:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
                /* Do nothing, allow user code to handle SECURE APPROTECT. Use this if you want to enable authenticated debug. */

        #else
            /* Load SECURE APPROTECT soft branch from UICR.
               If UICR->SECUREAPPROTECT is disabled, CTRLAP->SECUREAPPROTECT will be disabled. */
            NRF_CTRLAP_S->SECUREAPPROTECT.DISABLE = NRF_UICR_S->SECUREAPPROTECT;
    e864:	69d2      	ldr	r2, [r2, #28]
    e866:	f8c3 254c 	str.w	r2, [r3, #1356]	; 0x54c
        __DSB();
        __ISB();
    #endif

    SystemCoreClockUpdate();
}
    e86a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    SystemCoreClockUpdate();
    e86e:	f7ff bf87 	b.w	e780 <SystemCoreClockUpdate>
            *((volatile uint32_t *)0x5000470Cul) = 0x29ul;
    e872:	2229      	movs	r2, #41	; 0x29
    e874:	4b07      	ldr	r3, [pc, #28]	; (e894 <SystemInit+0xf4>)
    e876:	601a      	str	r2, [r3, #0]
            *((volatile uint32_t *)0x5000473Cul) = 0x3ul;
    e878:	2203      	movs	r2, #3
    e87a:	631a      	str	r2, [r3, #48]	; 0x30
    e87c:	e7b2      	b.n	e7e4 <SystemInit+0x44>
    e87e:	bf00      	nop
    e880:	50004a20 	.word	0x50004a20
    e884:	50039530 	.word	0x50039530
    e888:	beef0044 	.word	0xbeef0044
    e88c:	00ff0130 	.word	0x00ff0130
    e890:	5003254c 	.word	0x5003254c
    e894:	5000470c 	.word	0x5000470c
    e898:	e000ed00 	.word	0xe000ed00
    e89c:	00ff8000 	.word	0x00ff8000
    e8a0:	50006000 	.word	0x50006000

0000e8a4 <nrfx_clock_init>:
nrfx_err_t nrfx_clock_init(nrfx_clock_event_handler_t event_handler)
{
    NRFX_ASSERT(event_handler);

    nrfx_err_t err_code = NRFX_SUCCESS;
    if (m_clock_cb.module_initialized)
    e8a4:	4b04      	ldr	r3, [pc, #16]	; (e8b8 <nrfx_clock_init+0x14>)
    e8a6:	791a      	ldrb	r2, [r3, #4]
    e8a8:	b922      	cbnz	r2, e8b4 <nrfx_clock_init+0x10>
    {
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)
        m_clock_cb.cal_state = CAL_STATE_IDLE;
#endif
        m_clock_cb.event_handler = event_handler;
        m_clock_cb.module_initialized = true;
    e8aa:	2201      	movs	r2, #1
        m_clock_cb.event_handler = event_handler;
    e8ac:	6018      	str	r0, [r3, #0]
        m_clock_cb.module_initialized = true;
    e8ae:	711a      	strb	r2, [r3, #4]
    nrfx_err_t err_code = NRFX_SUCCESS;
    e8b0:	4802      	ldr	r0, [pc, #8]	; (e8bc <nrfx_clock_init+0x18>)
    e8b2:	4770      	bx	lr
        err_code = NRFX_ERROR_ALREADY_INITIALIZED;
    e8b4:	4802      	ldr	r0, [pc, #8]	; (e8c0 <nrfx_clock_init+0x1c>)
#endif
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
    e8b6:	4770      	bx	lr
    e8b8:	2000089c 	.word	0x2000089c
    e8bc:	0bad0000 	.word	0x0bad0000
    e8c0:	0bad000c 	.word	0x0bad000c

0000e8c4 <nrfx_clock_start>:
}

void nrfx_clock_start(nrf_clock_domain_t domain)
{
    NRFX_ASSERT(m_clock_cb.module_initialized);
    switch (domain)
    e8c4:	2803      	cmp	r0, #3
    e8c6:	d847      	bhi.n	e958 <nrfx_clock_start+0x94>
    e8c8:	e8df f000 	tbb	[pc, r0]
    e8cc:	3a2d2202 	.word	0x3a2d2202
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    e8d0:	f04f 2250 	mov.w	r2, #1342197760	; 0x50005000
    e8d4:	f8d2 3418 	ldr.w	r3, [r2, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    e8d8:	f8d2 1418 	ldr.w	r1, [r2, #1048]	; 0x418
    e8dc:	03c9      	lsls	r1, r1, #15
    e8de:	d511      	bpl.n	e904 <nrfx_clock_start+0x40>
    {
        case NRF_CLOCK_DOMAIN_LFCLK:
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
            {
                nrf_clock_lfclk_t lfclksrc;
                if (nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc) &&
    e8e0:	f003 0303 	and.w	r3, r3, #3
    e8e4:	2b02      	cmp	r3, #2
    e8e6:	d10d      	bne.n	e904 <nrfx_clock_start+0x40>
    p_reg->LFCLKSRC = (uint32_t)(source);
    e8e8:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    e8ec:	2200      	movs	r2, #0
    e8ee:	4b1b      	ldr	r3, [pc, #108]	; (e95c <nrfx_clock_start+0x98>)
    e8f0:	601a      	str	r2, [r3, #0]
    e8f2:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
    e8f4:	2202      	movs	r2, #2
    e8f6:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    e8fa:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    e8fe:	2201      	movs	r2, #1
    e900:	609a      	str	r2, [r3, #8]
}
    e902:	4770      	bx	lr
    p_reg->LFCLKSRC = (uint32_t)(source);
    e904:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    e908:	2201      	movs	r2, #1
    e90a:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
}
    e90e:	e7ed      	b.n	e8ec <nrfx_clock_start+0x28>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    e910:	2200      	movs	r2, #0
    e912:	4b13      	ldr	r3, [pc, #76]	; (e960 <nrfx_clock_start+0x9c>)
    e914:	601a      	str	r2, [r3, #0]
    e916:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
    e918:	2201      	movs	r2, #1
    e91a:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    e91e:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    e922:	601a      	str	r2, [r3, #0]
}
    e924:	4770      	bx	lr
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    e926:	2200      	movs	r2, #0
    e928:	4b0e      	ldr	r3, [pc, #56]	; (e964 <nrfx_clock_start+0xa0>)
    e92a:	601a      	str	r2, [r3, #0]
    e92c:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
    e92e:	f44f 7200 	mov.w	r2, #512	; 0x200
    e932:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    e936:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    e93a:	2201      	movs	r2, #1
    e93c:	621a      	str	r2, [r3, #32]
}
    e93e:	4770      	bx	lr
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    e940:	2200      	movs	r2, #0
    e942:	4b09      	ldr	r3, [pc, #36]	; (e968 <nrfx_clock_start+0xa4>)
    e944:	601a      	str	r2, [r3, #0]
    e946:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENSET = mask;
    e948:	f44f 7280 	mov.w	r2, #256	; 0x100
    e94c:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    e950:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    e954:	2201      	movs	r2, #1
    e956:	619a      	str	r2, [r3, #24]
#endif
        default:
            NRFX_ASSERT(0);
            break;
    }
}
    e958:	4770      	bx	lr
    e95a:	bf00      	nop
    e95c:	50005104 	.word	0x50005104
    e960:	50005100 	.word	0x50005100
    e964:	50005124 	.word	0x50005124
    e968:	50005120 	.word	0x50005120

0000e96c <nrfx_clock_stop>:

void nrfx_clock_stop(nrf_clock_domain_t domain)
{
    e96c:	b570      	push	{r4, r5, r6, lr}
    e96e:	4604      	mov	r4, r0
    e970:	2803      	cmp	r0, #3
    e972:	d83e      	bhi.n	e9f2 <nrfx_clock_stop+0x86>
    e974:	e8df f000 	tbb	[pc, r0]
    e978:	4b3e2202 	.word	0x4b3e2202
    p_reg->INTENCLR = mask;
    e97c:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    e980:	2202      	movs	r2, #2
    e982:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    e986:	2200      	movs	r2, #0
    e988:	f503 7382 	add.w	r3, r3, #260	; 0x104
    e98c:	601a      	str	r2, [r3, #0]
    e98e:	681b      	ldr	r3, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    e990:	4b28      	ldr	r3, [pc, #160]	; (ea34 <nrfx_clock_stop+0xc8>)
    e992:	2201      	movs	r2, #1
    e994:	f242 7510 	movw	r5, #10000	; 0x2710
            if ((p_reg->HFCLK192MSTAT & CLOCK_HFCLK192MSTAT_STATE_Msk)
    e998:	f04f 2650 	mov.w	r6, #1342197760	; 0x50005000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    e99c:	601a      	str	r2, [r3, #0]
    switch (domain)
    e99e:	2c02      	cmp	r4, #2
    e9a0:	d042      	beq.n	ea28 <nrfx_clock_stop+0xbc>
    e9a2:	2c03      	cmp	r4, #3
    e9a4:	d043      	beq.n	ea2e <nrfx_clock_stop+0xc2>
    e9a6:	bb24      	cbnz	r4, e9f2 <nrfx_clock_stop+0x86>
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    e9a8:	f8d6 3418 	ldr.w	r3, [r6, #1048]	; 0x418
        NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, &clk_src) ||
                       (clk_src != NRF_CLOCK_HFCLK_HIGH_ACCURACY)), 10000, 1, stopped);
    }
    else
    {
        NRFX_WAIT_FOR(!nrfx_clock_is_running(domain, NULL), 10000, 1, stopped);
    e9ac:	03db      	lsls	r3, r3, #15
    e9ae:	d520      	bpl.n	e9f2 <nrfx_clock_stop+0x86>
    e9b0:	2001      	movs	r0, #1
    e9b2:	f001 ff7f 	bl	108b4 <nrfx_busy_wait>
    e9b6:	3d01      	subs	r5, #1
    e9b8:	d1f1      	bne.n	e99e <nrfx_clock_stop+0x32>
    e9ba:	e01a      	b.n	e9f2 <nrfx_clock_stop+0x86>
    p_reg->INTENCLR = mask;
    e9bc:	2301      	movs	r3, #1
    e9be:	f04f 2450 	mov.w	r4, #1342197760	; 0x50005000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    e9c2:	2100      	movs	r1, #0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    e9c4:	f242 7510 	movw	r5, #10000	; 0x2710
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    e9c8:	4a1b      	ldr	r2, [pc, #108]	; (ea38 <nrfx_clock_stop+0xcc>)
    p_reg->INTENCLR = mask;
    e9ca:	f8c4 3308 	str.w	r3, [r4, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    e9ce:	6011      	str	r1, [r2, #0]
    e9d0:	6812      	ldr	r2, [r2, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    e9d2:	4a1a      	ldr	r2, [pc, #104]	; (ea3c <nrfx_clock_stop+0xd0>)
    e9d4:	6013      	str	r3, [r2, #0]
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
    e9d6:	f8d4 340c 	ldr.w	r3, [r4, #1036]	; 0x40c
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    e9da:	f8d4 240c 	ldr.w	r2, [r4, #1036]	; 0x40c
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
    e9de:	f003 0301 	and.w	r3, r3, #1
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    e9e2:	03d2      	lsls	r2, r2, #15
    e9e4:	d505      	bpl.n	e9f2 <nrfx_clock_stop+0x86>
        NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, &clk_src) ||
    e9e6:	b123      	cbz	r3, e9f2 <nrfx_clock_stop+0x86>
    e9e8:	2001      	movs	r0, #1
    e9ea:	f001 ff63 	bl	108b4 <nrfx_busy_wait>
    e9ee:	3d01      	subs	r5, #1
    e9f0:	d1f1      	bne.n	e9d6 <nrfx_clock_stop+0x6a>
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    {
            m_clock_cb.hfclk_started = false;
    }
#endif
}
    e9f2:	bd70      	pop	{r4, r5, r6, pc}
    p_reg->INTENCLR = mask;
    e9f4:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    e9f8:	f44f 7200 	mov.w	r2, #512	; 0x200
    e9fc:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    ea00:	2200      	movs	r2, #0
    ea02:	f503 7392 	add.w	r3, r3, #292	; 0x124
    ea06:	601a      	str	r2, [r3, #0]
    ea08:	681b      	ldr	r3, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    ea0a:	4b0d      	ldr	r3, [pc, #52]	; (ea40 <nrfx_clock_stop+0xd4>)
    ea0c:	e7c1      	b.n	e992 <nrfx_clock_stop+0x26>
    p_reg->INTENCLR = mask;
    ea0e:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    ea12:	f44f 7280 	mov.w	r2, #256	; 0x100
    ea16:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    ea1a:	2200      	movs	r2, #0
    ea1c:	f503 7390 	add.w	r3, r3, #288	; 0x120
    ea20:	601a      	str	r2, [r3, #0]
    ea22:	681b      	ldr	r3, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    ea24:	4b07      	ldr	r3, [pc, #28]	; (ea44 <nrfx_clock_stop+0xd8>)
    ea26:	e7b4      	b.n	e992 <nrfx_clock_stop+0x26>
            if ((p_reg->HFCLK192MSTAT & CLOCK_HFCLK192MSTAT_STATE_Msk)
    ea28:	f8d6 345c 	ldr.w	r3, [r6, #1116]	; 0x45c
    ea2c:	e7be      	b.n	e9ac <nrfx_clock_stop+0x40>
            return (p_reg->HFCLKAUDIOSTAT & CLOCK_HFCLKAUDIOSTAT_STATE_Msk) ==
    ea2e:	f8d6 3454 	ldr.w	r3, [r6, #1108]	; 0x454
    ea32:	e7bb      	b.n	e9ac <nrfx_clock_stop+0x40>
    ea34:	5000500c 	.word	0x5000500c
    ea38:	50005100 	.word	0x50005100
    ea3c:	50005004 	.word	0x50005004
    ea40:	50005024 	.word	0x50005024
    ea44:	5000501c 	.word	0x5000501c

0000ea48 <nrfx_power_clock_irq_handler>:
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    ea48:	4b26      	ldr	r3, [pc, #152]	; (eae4 <CONFIG_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x84>)
    }
}
#endif

void nrfx_clock_irq_handler(void)
{
    ea4a:	b510      	push	{r4, lr}
    ea4c:	681a      	ldr	r2, [r3, #0]
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED))
    ea4e:	b152      	cbz	r2, ea66 <CONFIG_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x6>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    ea50:	2000      	movs	r0, #0
    ea52:	6018      	str	r0, [r3, #0]
    ea54:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENCLR = mask;
    ea56:	2201      	movs	r2, #1
    ea58:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    ea5c:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
        {
            m_clock_cb.hfclk_started = true;
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
        }
#else
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
    ea60:	4b21      	ldr	r3, [pc, #132]	; (eae8 <CONFIG_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x88>)
    ea62:	681b      	ldr	r3, [r3, #0]
    ea64:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    ea66:	4b21      	ldr	r3, [pc, #132]	; (eaec <CONFIG_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x8c>)
    ea68:	681a      	ldr	r2, [r3, #0]
#endif
    }
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED))
    ea6a:	b18a      	cbz	r2, ea90 <CONFIG_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x30>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    ea6c:	2200      	movs	r2, #0
    ea6e:	601a      	str	r2, [r3, #0]
    ea70:	681b      	ldr	r3, [r3, #0]
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    ea72:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    ea76:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    ea7a:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_LFCLKSTARTED");

#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
        nrf_clock_lfclk_t lfclksrc;
        (void)nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc);
        if (lfclksrc == NRF_CLOCK_LFCLK_RC)
    ea7e:	f002 0203 	and.w	r2, r2, #3
    ea82:	2a01      	cmp	r2, #1
    ea84:	f04f 0102 	mov.w	r1, #2
    ea88:	d124      	bne.n	ead4 <CONFIG_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x74>
    p_reg->LFCLKSRC = (uint32_t)(source);
    ea8a:	f8c3 1518 	str.w	r1, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    ea8e:	609a      	str	r2, [r3, #8]
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    ea90:	4b17      	ldr	r3, [pc, #92]	; (eaf0 <CONFIG_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x90>)
    ea92:	681a      	ldr	r2, [r3, #0]
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_CAL_DONE);
    }
#endif // NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)

#if NRF_CLOCK_HAS_HFCLKAUDIO
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKAUDIOSTARTED))
    ea94:	b162      	cbz	r2, eab0 <CONFIG_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x50>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    ea96:	2200      	movs	r2, #0
    ea98:	601a      	str	r2, [r3, #0]
    ea9a:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENCLR = mask;
    ea9c:	f44f 7280 	mov.w	r2, #256	; 0x100
    eaa0:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    eaa4:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    {
        nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKAUDIOSTARTED);
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_HFCLKAUDIOSTARTED");
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HFAUDIO_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLKAUDIO_STARTED);
    eaa8:	4b0f      	ldr	r3, [pc, #60]	; (eae8 <CONFIG_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x88>)
    eaaa:	2004      	movs	r0, #4
    eaac:	681b      	ldr	r3, [r3, #0]
    eaae:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    eab0:	4b10      	ldr	r3, [pc, #64]	; (eaf4 <CONFIG_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x94>)
    eab2:	681a      	ldr	r2, [r3, #0]
    }
#endif

#if NRF_CLOCK_HAS_HFCLK192M
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLK192MSTARTED))
    eab4:	b1aa      	cbz	r2, eae2 <CONFIG_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x82>
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF192M_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
    }
#endif
}
    eab6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    eaba:	2200      	movs	r2, #0
    eabc:	601a      	str	r2, [r3, #0]
    eabe:	681b      	ldr	r3, [r3, #0]
    p_reg->INTENCLR = mask;
    eac0:	f44f 7200 	mov.w	r2, #512	; 0x200
    eac4:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
    eac8:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
    eacc:	4b06      	ldr	r3, [pc, #24]	; (eae8 <CONFIG_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x88>)
    eace:	2005      	movs	r0, #5
    ead0:	681b      	ldr	r3, [r3, #0]
    ead2:	4718      	bx	r3
    ead4:	f8c3 1308 	str.w	r1, [r3, #776]	; 0x308
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
    ead8:	4b03      	ldr	r3, [pc, #12]	; (eae8 <CONFIG_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x88>)
    eada:	2001      	movs	r0, #1
    eadc:	681b      	ldr	r3, [r3, #0]
    eade:	4798      	blx	r3
    eae0:	e7d6      	b.n	ea90 <CONFIG_PM_MIN_RESIDENCY_DEEP_SLEEP_1+0x30>
}
    eae2:	bd10      	pop	{r4, pc}
    eae4:	50005100 	.word	0x50005100
    eae8:	2000089c 	.word	0x2000089c
    eaec:	50005104 	.word	0x50005104
    eaf0:	50005120 	.word	0x50005120
    eaf4:	50005124 	.word	0x50005124

0000eaf8 <nrfx_dppi_channel_alloc>:
nrfx_err_t nrfx_dppi_channel_alloc(uint8_t * p_channel)
{
    nrfx_err_t err_code;

    // Get mask of available DPPI channels
    uint32_t remaining_channels = DPPI_AVAILABLE_CHANNELS_MASK & ~(m_allocated_channels);
    eaf8:	4a0a      	ldr	r2, [pc, #40]	; (eb24 <nrfx_dppi_channel_alloc+0x2c>)
{
    eafa:	b570      	push	{r4, r5, r6, lr}
    uint32_t remaining_channels = DPPI_AVAILABLE_CHANNELS_MASK & ~(m_allocated_channels);
    eafc:	6814      	ldr	r4, [r2, #0]
    uint8_t channel = 0;

    if (!remaining_channels)
    eafe:	43e6      	mvns	r6, r4
    eb00:	d00e      	beq.n	eb20 <nrfx_dppi_channel_alloc+0x28>
    eb02:	2300      	movs	r3, #0
    eb04:	b2d9      	uxtb	r1, r3
        NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
        return err_code;
    }

    // Find first free channel
    while (!(remaining_channels & DPPI_BIT_SET(channel)))
    eb06:	fa26 f501 	lsr.w	r5, r6, r1
    eb0a:	07ed      	lsls	r5, r5, #31
    eb0c:	f103 0301 	add.w	r3, r3, #1
    eb10:	d5f8      	bpl.n	eb04 <nrfx_dppi_channel_alloc+0xc>
    {
        channel++;
    }

    m_allocated_channels |= DPPI_BIT_SET(channel);
    eb12:	2301      	movs	r3, #1
    eb14:	408b      	lsls	r3, r1
    eb16:	4323      	orrs	r3, r4
    *p_channel = channel;
    eb18:	7001      	strb	r1, [r0, #0]

    err_code = NRFX_SUCCESS;
    NRFX_LOG_INFO("Allocated channel: %d.", channel);
    return err_code;
    eb1a:	4803      	ldr	r0, [pc, #12]	; (eb28 <nrfx_dppi_channel_alloc+0x30>)
    m_allocated_channels |= DPPI_BIT_SET(channel);
    eb1c:	6013      	str	r3, [r2, #0]
}
    eb1e:	bd70      	pop	{r4, r5, r6, pc}
        return err_code;
    eb20:	4802      	ldr	r0, [pc, #8]	; (eb2c <nrfx_dppi_channel_alloc+0x34>)
    eb22:	e7fc      	b.n	eb1e <nrfx_dppi_channel_alloc+0x26>
    eb24:	200008a4 	.word	0x200008a4
    eb28:	0bad0000 	.word	0x0bad0000
    eb2c:	0bad0002 	.word	0x0bad0002

0000eb30 <nrfx_gpiote_channel_free>:
    return m_cb.allocated_channels_mask & (1UL << index);
}

static bool is_app_channel(uint8_t index)
{
    return NRFX_GPIOTE_APP_CHANNELS_MASK & (1UL << index);
    eb30:	2301      	movs	r3, #1
    eb32:	fa03 f000 	lsl.w	r0, r3, r0

nrfx_err_t nrfx_gpiote_channel_free(uint8_t channel)
{
    nrfx_err_t err_code = NRFX_SUCCESS;

    if (!is_app_channel(channel))
    eb36:	f010 0fff 	tst.w	r0, #255	; 0xff
    eb3a:	d012      	beq.n	eb62 <nrfx_gpiote_channel_free+0x32>
	__asm__ volatile(
    eb3c:	f04f 0320 	mov.w	r3, #32
    eb40:	f3ef 8111 	mrs	r1, BASEPRI
    eb44:	f383 8811 	msr	BASEPRI, r3
    eb48:	f3bf 8f6f 	isb	sy
    m_cb.allocated_channels_mask &= ~(1UL << index);
    eb4c:	4a06      	ldr	r2, [pc, #24]	; (eb68 <nrfx_gpiote_channel_free+0x38>)
    eb4e:	6dd3      	ldr	r3, [r2, #92]	; 0x5c
    eb50:	ea23 0000 	bic.w	r0, r3, r0
    eb54:	65d0      	str	r0, [r2, #92]	; 0x5c
	__asm__ volatile(
    eb56:	f381 8811 	msr	BASEPRI, r1
    eb5a:	f3bf 8f6f 	isb	sy
    eb5e:	4803      	ldr	r0, [pc, #12]	; (eb6c <nrfx_gpiote_channel_free+0x3c>)
    eb60:	4770      	bx	lr
    {
        err_code = NRFX_ERROR_INVALID_PARAM;
    eb62:	4803      	ldr	r0, [pc, #12]	; (eb70 <nrfx_gpiote_channel_free+0x40>)
        NRFX_CRITICAL_SECTION_EXIT();
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
    eb64:	4770      	bx	lr
    eb66:	bf00      	nop
    eb68:	200008a8 	.word	0x200008a8
    eb6c:	0bad0000 	.word	0x0bad0000
    eb70:	0bad0004 	.word	0x0bad0004

0000eb74 <nrfx_gpiote_channel_alloc>:

nrfx_err_t nrfx_gpiote_channel_alloc(uint8_t * p_channel)
{
    eb74:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    nrfx_err_t err_code = NRFX_ERROR_NO_MEM;
    uint32_t mask = NRFX_GPIOTE_APP_CHANNELS_MASK;
    eb78:	22ff      	movs	r2, #255	; 0xff
{
    eb7a:	2400      	movs	r4, #0
    return m_cb.allocated_channels_mask & (1UL << index);
    eb7c:	2601      	movs	r6, #1
{
    eb7e:	4605      	mov	r5, r0
    return m_cb.allocated_channels_mask & (1UL << index);
    eb80:	f8df e058 	ldr.w	lr, [pc, #88]	; ebdc <nrfx_gpiote_channel_alloc+0x68>
    nrfx_err_t err_code = NRFX_ERROR_NO_MEM;
    eb84:	4814      	ldr	r0, [pc, #80]	; (ebd8 <nrfx_gpiote_channel_alloc+0x64>)
        NRFX_CRITICAL_SECTION_ENTER();
        if ((mask & (1UL << ch_idx)) && (!is_allocated_channel(ch_idx)))
        {
            channel_allocated_set(ch_idx);
            *p_channel = ch_idx;
            err_code = NRFX_SUCCESS;
    eb86:	f8df 8058 	ldr.w	r8, [pc, #88]	; ebe0 <nrfx_gpiote_channel_alloc+0x6c>
    eb8a:	b2e3      	uxtb	r3, r4
	__asm__ volatile(
    eb8c:	f04f 0120 	mov.w	r1, #32
    eb90:	f3ef 8c11 	mrs	ip, BASEPRI
    eb94:	f381 8811 	msr	BASEPRI, r1
    eb98:	f3bf 8f6f 	isb	sy
        if ((mask & (1UL << ch_idx)) && (!is_allocated_channel(ch_idx)))
    eb9c:	fa22 f103 	lsr.w	r1, r2, r3
    eba0:	07c9      	lsls	r1, r1, #31
    eba2:	d50a      	bpl.n	ebba <nrfx_gpiote_channel_alloc+0x46>
    return m_cb.allocated_channels_mask & (1UL << index);
    eba4:	f8de 105c 	ldr.w	r1, [lr, #92]	; 0x5c
    eba8:	fa06 f703 	lsl.w	r7, r6, r3
        if ((mask & (1UL << ch_idx)) && (!is_allocated_channel(ch_idx)))
    ebac:	4239      	tst	r1, r7
            err_code = NRFX_SUCCESS;
    ebae:	bf01      	itttt	eq
    ebb0:	4640      	moveq	r0, r8
    m_cb.allocated_channels_mask |= (1UL << index);
    ebb2:	4339      	orreq	r1, r7
    ebb4:	f8ce 105c 	streq.w	r1, [lr, #92]	; 0x5c
            *p_channel = ch_idx;
    ebb8:	702b      	strbeq	r3, [r5, #0]
	__asm__ volatile(
    ebba:	f38c 8811 	msr	BASEPRI, ip
    ebbe:	f3bf 8f6f 	isb	sy
        }
        NRFX_CRITICAL_SECTION_EXIT();

        if (err_code == NRFX_SUCCESS)
    ebc2:	4540      	cmp	r0, r8
    ebc4:	d005      	beq.n	ebd2 <nrfx_gpiote_channel_alloc+0x5e>
        {
            NRFX_LOG_INFO("Allocated channel: %d.", ch_idx);
            break;
        }

        mask &= ~(1UL << ch_idx);
    ebc6:	fa06 f303 	lsl.w	r3, r6, r3
    for (uint8_t ch_idx = 0; mask != 0; ch_idx++)
    ebca:	439a      	bics	r2, r3
    ebcc:	f104 0401 	add.w	r4, r4, #1
    ebd0:	d1db      	bne.n	eb8a <nrfx_gpiote_channel_alloc+0x16>
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
    ebd2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ebd6:	bf00      	nop
    ebd8:	0bad0002 	.word	0x0bad0002
    ebdc:	200008a8 	.word	0x200008a8
    ebe0:	0bad0000 	.word	0x0bad0000

0000ebe4 <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_init_run_level(int32_t level)
{
    ebe4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    ebe6:	4b10      	ldr	r3, [pc, #64]	; (ec28 <z_sys_init_run_level+0x44>)
			/* Initialization failed.
			 * Set the init status bit so device is not declared ready.
			 */
			sys_bitfield_set_bit(
				(mem_addr_t) __device_init_status_start,
				(dev - __device_start));
    ebe8:	4f10      	ldr	r7, [pc, #64]	; (ec2c <z_sys_init_run_level+0x48>)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    ebea:	f853 5020 	ldr.w	r5, [r3, r0, lsl #2]
    ebee:	3001      	adds	r0, #1
    ebf0:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
    ebf4:	42ae      	cmp	r6, r5
    ebf6:	d800      	bhi.n	ebfa <z_sys_init_run_level+0x16>
		}
	}
}
    ebf8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if ((entry->init(dev) != 0) && (dev != NULL)) {
    ebfa:	e9d5 3400 	ldrd	r3, r4, [r5]
    ebfe:	4620      	mov	r0, r4
    ec00:	4798      	blx	r3
    ec02:	b170      	cbz	r0, ec22 <z_sys_init_run_level+0x3e>
    ec04:	b16c      	cbz	r4, ec22 <z_sys_init_run_level+0x3e>

static ALWAYS_INLINE void sys_set_bit(mem_addr_t addr, unsigned int bit)
{
	uint32_t temp = *(volatile uint32_t *)addr;

	*(volatile uint32_t *)addr = temp | (1 << bit);
    ec06:	2301      	movs	r3, #1
				(dev - __device_start));
    ec08:	1be4      	subs	r4, r4, r7
	void sys_bitfield_set_bit(mem_addr_t addr, unsigned int bit)
{
	/* Doing memory offsets in terms of 32-bit values to prevent
	 * alignment issues
	 */
	sys_set_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
    ec0a:	4a09      	ldr	r2, [pc, #36]	; (ec30 <z_sys_init_run_level+0x4c>)
    ec0c:	1124      	asrs	r4, r4, #4
    ec0e:	0961      	lsrs	r1, r4, #5
	uint32_t temp = *(volatile uint32_t *)addr;
    ec10:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
	sys_set_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
    ec14:	f004 041f 	and.w	r4, r4, #31
	*(volatile uint32_t *)addr = temp | (1 << bit);
    ec18:	fa03 f404 	lsl.w	r4, r3, r4
    ec1c:	4304      	orrs	r4, r0
    ec1e:	f842 4021 	str.w	r4, [r2, r1, lsl #2]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    ec22:	3508      	adds	r5, #8
    ec24:	e7e6      	b.n	ebf4 <z_sys_init_run_level+0x10>
    ec26:	bf00      	nop
    ec28:	00010ef0 	.word	0x00010ef0
    ec2c:	200000a8 	.word	0x200000a8
    ec30:	20000108 	.word	0x20000108

0000ec34 <z_device_ready>:

bool z_device_ready(const struct device *dev)
{
	/* Set bit indicates device failed initialization */
	return !(sys_bitfield_test_bit((mem_addr_t)__device_init_status_start,
					(dev - __device_start)));
    ec34:	4b08      	ldr	r3, [pc, #32]	; (ec58 <z_device_ready+0x24>)
    ec36:	1ac0      	subs	r0, r0, r3
    ec38:	1100      	asrs	r0, r0, #4
}

static ALWAYS_INLINE
	int sys_bitfield_test_bit(mem_addr_t addr, unsigned int bit)
{
	return sys_test_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
    ec3a:	4b08      	ldr	r3, [pc, #32]	; (ec5c <z_device_ready+0x28>)
    ec3c:	0942      	lsrs	r2, r0, #5
	uint32_t temp = *(volatile uint32_t *)addr;
    ec3e:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
	return temp & (1 << bit);
    ec42:	2301      	movs	r3, #1
	return sys_test_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
    ec44:	f000 001f 	and.w	r0, r0, #31
	return temp & (1 << bit);
    ec48:	fa03 f000 	lsl.w	r0, r3, r0
	return !(sys_bitfield_test_bit((mem_addr_t)__device_init_status_start,
    ec4c:	4210      	tst	r0, r2
}
    ec4e:	bf0c      	ite	eq
    ec50:	4618      	moveq	r0, r3
    ec52:	2000      	movne	r0, #0
    ec54:	4770      	bx	lr
    ec56:	bf00      	nop
    ec58:	200000a8 	.word	0x200000a8
    ec5c:	20000108 	.word	0x20000108

0000ec60 <z_impl_device_get_binding>:
	for (dev = __device_start; dev != __device_end; dev++) {
    ec60:	4911      	ldr	r1, [pc, #68]	; (eca8 <z_impl_device_get_binding+0x48>)
{
    ec62:	b570      	push	{r4, r5, r6, lr}
    ec64:	4605      	mov	r5, r0
    ec66:	460e      	mov	r6, r1
	for (dev = __device_start; dev != __device_end; dev++) {
    ec68:	4c10      	ldr	r4, [pc, #64]	; (ecac <z_impl_device_get_binding+0x4c>)
    ec6a:	428c      	cmp	r4, r1
    ec6c:	d104      	bne.n	ec78 <z_impl_device_get_binding+0x18>
	for (dev = __device_start; dev != __device_end; dev++) {
    ec6e:	4c0f      	ldr	r4, [pc, #60]	; (ecac <z_impl_device_get_binding+0x4c>)
    ec70:	42b4      	cmp	r4, r6
    ec72:	d10a      	bne.n	ec8a <z_impl_device_get_binding+0x2a>
	return NULL;
    ec74:	2400      	movs	r4, #0
    ec76:	e014      	b.n	eca2 <z_impl_device_get_binding+0x42>
		if (z_device_ready(dev) && (dev->name == name)) {
    ec78:	4620      	mov	r0, r4
    ec7a:	f7ff ffdb 	bl	ec34 <z_device_ready>
    ec7e:	b110      	cbz	r0, ec86 <z_impl_device_get_binding+0x26>
    ec80:	6823      	ldr	r3, [r4, #0]
    ec82:	42ab      	cmp	r3, r5
    ec84:	d00d      	beq.n	eca2 <z_impl_device_get_binding+0x42>
	for (dev = __device_start; dev != __device_end; dev++) {
    ec86:	3410      	adds	r4, #16
    ec88:	e7ef      	b.n	ec6a <z_impl_device_get_binding+0xa>
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
    ec8a:	4620      	mov	r0, r4
    ec8c:	f7ff ffd2 	bl	ec34 <z_device_ready>
    ec90:	b908      	cbnz	r0, ec96 <z_impl_device_get_binding+0x36>
	for (dev = __device_start; dev != __device_end; dev++) {
    ec92:	3410      	adds	r4, #16
    ec94:	e7ec      	b.n	ec70 <z_impl_device_get_binding+0x10>
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
    ec96:	4628      	mov	r0, r5
    ec98:	6821      	ldr	r1, [r4, #0]
    ec9a:	f001 fc9e 	bl	105da <strcmp>
    ec9e:	2800      	cmp	r0, #0
    eca0:	d1f7      	bne.n	ec92 <z_impl_device_get_binding+0x32>
}
    eca2:	4620      	mov	r0, r4
    eca4:	bd70      	pop	{r4, r5, r6, pc}
    eca6:	bf00      	nop
    eca8:	20000108 	.word	0x20000108
    ecac:	200000a8 	.word	0x200000a8

0000ecb0 <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *p1, void *unused2, void *unused3)
{
    ecb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ecb2:	4605      	mov	r5, r0
		 */
		int key = arch_irq_lock();
		struct k_thread *to_abort = cpu->pending_abort;

		if (to_abort) {
			cpu->pending_abort = NULL;
    ecb4:	2700      	movs	r7, #0
		 * saves no power and does not improve latency.  But it's an
		 * API we need to honor...
		 */
		z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
#ifdef CONFIG_PM
		_kernel.idle = ticks;
    ecb6:	4e15      	ldr	r6, [pc, #84]	; (ed0c <idle+0x5c>)
	__asm__ volatile(
    ecb8:	f04f 0220 	mov.w	r2, #32
    ecbc:	f3ef 8311 	mrs	r3, BASEPRI
    ecc0:	f382 8811 	msr	BASEPRI, r2
    ecc4:	f3bf 8f6f 	isb	sy
		struct k_thread *to_abort = cpu->pending_abort;
    ecc8:	6928      	ldr	r0, [r5, #16]
		if (to_abort) {
    ecca:	b188      	cbz	r0, ecf0 <idle+0x40>
			cpu->pending_abort = NULL;
    eccc:	612f      	str	r7, [r5, #16]
	__asm__ volatile(
    ecce:	f383 8811 	msr	BASEPRI, r3
    ecd2:	f3bf 8f6f 	isb	sy
			z_thread_single_abort(to_abort);
    ecd6:	f000 fbc3 	bl	f460 <z_thread_single_abort>
	__asm__ volatile(
    ecda:	f04f 0320 	mov.w	r3, #32
    ecde:	f3ef 8011 	mrs	r0, BASEPRI
    ece2:	f383 8811 	msr	BASEPRI, r3
    ece6:	f3bf 8f6f 	isb	sy
    ecea:	f001 fe34 	bl	10956 <z_reschedule_irqlock>
			continue;
    ecee:	e7e3      	b.n	ecb8 <idle+0x8>
		int32_t ticks = z_get_next_timeout_expiry();
    ecf0:	f001 fefd 	bl	10aee <z_get_next_timeout_expiry>
		z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
    ecf4:	2101      	movs	r1, #1
		int32_t ticks = z_get_next_timeout_expiry();
    ecf6:	4604      	mov	r4, r0
		z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
    ecf8:	2802      	cmp	r0, #2
    ecfa:	bfd8      	it	le
    ecfc:	4608      	movle	r0, r1
    ecfe:	f001 ff06 	bl	10b0e <z_set_timeout_expiry>
		_kernel.idle = ticks;
    ed02:	6274      	str	r4, [r6, #36]	; 0x24
	arch_cpu_idle();
    ed04:	f7fe fe4c 	bl	d9a0 <arch_cpu_idle>
}
    ed08:	e7d6      	b.n	ecb8 <idle+0x8>
    ed0a:	bf00      	nop
    ed0c:	20000908 	.word	0x20000908

0000ed10 <z_bss_zero>:
 *
 * @return N/A
 */
void z_bss_zero(void)
{
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
    ed10:	4802      	ldr	r0, [pc, #8]	; (ed1c <z_bss_zero+0xc>)
    ed12:	4a03      	ldr	r2, [pc, #12]	; (ed20 <z_bss_zero+0x10>)
    ed14:	2100      	movs	r1, #0
    ed16:	1a12      	subs	r2, r2, r0
    ed18:	f001 bc96 	b.w	10648 <memset>
    ed1c:	20000160 	.word	0x20000160
    ed20:	20000968 	.word	0x20000968

0000ed24 <bg_thread_main>:
{
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	z_sys_post_kernel = true;
    ed24:	2201      	movs	r2, #1
{
    ed26:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
    ed28:	4b09      	ldr	r3, [pc, #36]	; (ed50 <bg_thread_main+0x2c>)

	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    ed2a:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
    ed2c:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    ed2e:	f7ff ff59 	bl	ebe4 <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
    ed32:	f000 fe57 	bl	f9e4 <boot_banner>
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
    ed36:	2003      	movs	r0, #3
    ed38:	f7ff ff54 	bl	ebe4 <z_sys_init_run_level>

	z_init_static_threads();
    ed3c:	f000 fde0 	bl	f900 <z_init_static_threads>
	z_timestamp_main = k_cycle_get_32();
#endif

	extern void main(void);

	main();
    ed40:	f7fd fc86 	bl	c650 <main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    ed44:	4a03      	ldr	r2, [pc, #12]	; (ed54 <bg_thread_main+0x30>)
    ed46:	7b13      	ldrb	r3, [r2, #12]
    ed48:	f023 0301 	bic.w	r3, r3, #1
    ed4c:	7313      	strb	r3, [r2, #12]

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    ed4e:	bd08      	pop	{r3, pc}
    ed50:	20000966 	.word	0x20000966
    ed54:	200001e0 	.word	0x200001e0

0000ed58 <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
    ed58:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
		(uint32_t)(Z_KERNEL_STACK_BUFFER(z_interrupt_stacks[0])) +
    ed5c:	4b34      	ldr	r3, [pc, #208]	; (ee30 <z_cstart+0xd8>)
    ed5e:	b0a7      	sub	sp, #156	; 0x9c
	uint32_t msp =
    ed60:	f503 6900 	add.w	r9, r3, #2048	; 0x800
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
    ed64:	f389 8808 	msr	MSP, r9
  __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
    ed68:	f383 880a 	msr	MSPLIM, r3
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    ed6c:	2400      	movs	r4, #0
    ed6e:	23e0      	movs	r3, #224	; 0xe0
    ed70:	4d30      	ldr	r5, [pc, #192]	; (ee34 <z_cstart+0xdc>)
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    ed72:	f04f 0b01 	mov.w	fp, #1
    ed76:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
    ed7a:	77ec      	strb	r4, [r5, #31]
    ed7c:	762c      	strb	r4, [r5, #24]
    ed7e:	766c      	strb	r4, [r5, #25]
    ed80:	76ac      	strb	r4, [r5, #26]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
    ed82:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	_kernel.ready_q.cache = &z_main_thread;
    ed84:	4e2c      	ldr	r6, [pc, #176]	; (ee38 <z_cstart+0xe0>)
    ed86:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
    ed8a:	626b      	str	r3, [r5, #36]	; 0x24

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
    ed8c:	f7fe ff68 	bl	dc60 <z_arm_fault_init>
	z_arm_cpu_idle_init();
    ed90:	f7fe fe00 	bl	d994 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
    ed94:	f04f 33ff 	mov.w	r3, #4294967295
    ed98:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
    ed9a:	62eb      	str	r3, [r5, #44]	; 0x2c
{
	dummy_thread->base.thread_state = _THREAD_DUMMY;
#ifdef CONFIG_SCHED_CPU_MASK
	dummy_thread->base.cpu_mask = -1;
#endif
	dummy_thread->base.user_options = K_ESSENTIAL;
    ed9c:	f240 1301 	movw	r3, #257	; 0x101
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
    eda0:	4d26      	ldr	r5, [pc, #152]	; (ee3c <z_cstart+0xe4>)
	dummy_thread->base.user_options = K_ESSENTIAL;
    eda2:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
	_current_cpu->current = dummy_thread;
    eda6:	ab06      	add	r3, sp, #24
    eda8:	60ab      	str	r3, [r5, #8]

	z_dummy_thread_init(&dummy_thread);
#endif

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    edaa:	4620      	mov	r0, r4
	dummy_thread->stack_info.size = 0U;
    edac:	e9cd 4420 	strd	r4, r4, [sp, #128]	; 0x80
    edb0:	f7ff ff18 	bl	ebe4 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    edb4:	2001      	movs	r0, #1
    edb6:	f7ff ff15 	bl	ebe4 <z_sys_init_run_level>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    edba:	f8df a098 	ldr.w	sl, [pc, #152]	; ee54 <z_cstart+0xfc>
	z_sched_init();
    edbe:	f000 fca3 	bl	f708 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    edc2:	4b1f      	ldr	r3, [pc, #124]	; (ee40 <z_cstart+0xe8>)
	_kernel.ready_q.cache = &z_main_thread;
    edc4:	62ae      	str	r6, [r5, #40]	; 0x28
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
    edc6:	f44f 6280 	mov.w	r2, #1024	; 0x400
    edca:	491e      	ldr	r1, [pc, #120]	; (ee44 <z_cstart+0xec>)
    edcc:	9305      	str	r3, [sp, #20]
    edce:	4630      	mov	r0, r6
    edd0:	4653      	mov	r3, sl
    edd2:	e9cd 4b03 	strd	r4, fp, [sp, #12]
    edd6:	e9cd 4401 	strd	r4, r4, [sp, #4]
    edda:	9400      	str	r4, [sp, #0]
    eddc:	f000 fd60 	bl	f8a0 <z_setup_new_thread>
	sys_trace_thread_resume(thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
    ede0:	7b73      	ldrb	r3, [r6, #13]
    ede2:	4680      	mov	r8, r0
    ede4:	f023 0304 	bic.w	r3, r3, #4
	z_ready_thread(&z_main_thread);
    ede8:	4630      	mov	r0, r6
    edea:	7373      	strb	r3, [r6, #13]
    edec:	f001 fddf 	bl	109ae <z_ready_thread>
	z_setup_new_thread(thread, stack,
    edf0:	230f      	movs	r3, #15
    edf2:	4f15      	ldr	r7, [pc, #84]	; (ee48 <z_cstart+0xf0>)
    edf4:	f44f 72a0 	mov.w	r2, #320	; 0x140
    edf8:	e9cd 4302 	strd	r4, r3, [sp, #8]
    edfc:	4913      	ldr	r1, [pc, #76]	; (ee4c <z_cstart+0xf4>)
    edfe:	4b14      	ldr	r3, [pc, #80]	; (ee50 <z_cstart+0xf8>)
    ee00:	4638      	mov	r0, r7
    ee02:	e9cd b404 	strd	fp, r4, [sp, #16]
    ee06:	e9cd 5400 	strd	r5, r4, [sp]
    ee0a:	f000 fd49 	bl	f8a0 <z_setup_new_thread>
    ee0e:	7b7b      	ldrb	r3, [r7, #13]
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
    ee10:	4652      	mov	r2, sl
    ee12:	f023 0304 	bic.w	r3, r3, #4
    ee16:	737b      	strb	r3, [r7, #13]
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
    ee18:	f105 031c 	add.w	r3, r5, #28
    ee1c:	4641      	mov	r1, r8
    ee1e:	4630      	mov	r0, r6
	list->tail = (sys_dnode_t *)list;
    ee20:	e9c5 3307 	strd	r3, r3, [r5, #28]
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
    ee24:	60ef      	str	r7, [r5, #12]
		_kernel.cpus[i].id = i;
    ee26:	762c      	strb	r4, [r5, #24]
		_kernel.cpus[i].irq_stack =
    ee28:	f8c5 9004 	str.w	r9, [r5, #4]
	arch_switch_to_main_thread(&z_main_thread, stack_ptr, bg_thread_main);
    ee2c:	f7fe fd98 	bl	d960 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    ee30:	20000ea8 	.word	0x20000ea8
    ee34:	e000ed00 	.word	0xe000ed00
    ee38:	200001e0 	.word	0x200001e0
    ee3c:	20000908 	.word	0x20000908
    ee40:	00011087 	.word	0x00011087
    ee44:	20000968 	.word	0x20000968
    ee48:	20000160 	.word	0x20000160
    ee4c:	20000d68 	.word	0x20000d68
    ee50:	0000ecb1 	.word	0x0000ecb1
    ee54:	0000ed25 	.word	0x0000ed25

0000ee58 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return N/A
 */
static int init_mem_slab_module(const struct device *dev)
{
    ee58:	b570      	push	{r4, r5, r6, lr}
	int rc = 0;
	ARG_UNUSED(dev);

	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    ee5a:	4b0e      	ldr	r3, [pc, #56]	; (ee94 <init_mem_slab_module+0x3c>)
    ee5c:	4c0e      	ldr	r4, [pc, #56]	; (ee98 <init_mem_slab_module+0x40>)
    ee5e:	42a3      	cmp	r3, r4
    ee60:	d301      	bcc.n	ee66 <init_mem_slab_module+0xe>
		}
		SYS_TRACING_OBJ_INIT(k_mem_slab, slab);
		z_object_init(slab);
	}

out:
    ee62:	2000      	movs	r0, #0
	return rc;
}
    ee64:	bd70      	pop	{r4, r5, r6, pc}
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
    ee66:	e9d3 0103 	ldrd	r0, r1, [r3, #12]
    ee6a:	ea41 0200 	orr.w	r2, r1, r0
    ee6e:	f012 0203 	ands.w	r2, r2, #3
    ee72:	d10b      	bne.n	ee8c <init_mem_slab_module+0x34>
	for (j = 0U; j < slab->num_blocks; j++) {
    ee74:	689d      	ldr	r5, [r3, #8]
	slab->free_list = NULL;
    ee76:	615a      	str	r2, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
    ee78:	42aa      	cmp	r2, r5
    ee7a:	d101      	bne.n	ee80 <init_mem_slab_module+0x28>
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
    ee7c:	331c      	adds	r3, #28
    ee7e:	e7ee      	b.n	ee5e <init_mem_slab_module+0x6>
		*(char **)p = slab->free_list;
    ee80:	695e      	ldr	r6, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
    ee82:	3201      	adds	r2, #1
		*(char **)p = slab->free_list;
    ee84:	600e      	str	r6, [r1, #0]
		slab->free_list = p;
    ee86:	6159      	str	r1, [r3, #20]
		p += slab->block_size;
    ee88:	4401      	add	r1, r0
	for (j = 0U; j < slab->num_blocks; j++) {
    ee8a:	e7f5      	b.n	ee78 <init_mem_slab_module+0x20>
		return -EINVAL;
    ee8c:	f06f 0015 	mvn.w	r0, #21
	return rc;
    ee90:	e7e8      	b.n	ee64 <init_mem_slab_module+0xc>
    ee92:	bf00      	nop
    ee94:	2000010c 	.word	0x2000010c
    ee98:	2000010c 	.word	0x2000010c

0000ee9c <k_mem_slab_alloc>:
out:
	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
    ee9c:	b5d3      	push	{r0, r1, r4, r6, r7, lr}
    ee9e:	460c      	mov	r4, r1
    eea0:	4616      	mov	r6, r2
    eea2:	461f      	mov	r7, r3
    eea4:	f04f 0320 	mov.w	r3, #32
    eea8:	f3ef 8111 	mrs	r1, BASEPRI
    eeac:	f383 8811 	msr	BASEPRI, r3
    eeb0:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	int result;

	if (slab->free_list != NULL) {
    eeb4:	6943      	ldr	r3, [r0, #20]
    eeb6:	b15b      	cbz	r3, eed0 <k_mem_slab_alloc+0x34>
		/* take a free block */
		*mem = slab->free_list;
    eeb8:	6023      	str	r3, [r4, #0]
		slab->free_list = *(char **)(slab->free_list);
    eeba:	681b      	ldr	r3, [r3, #0]
    eebc:	6143      	str	r3, [r0, #20]
		slab->num_used++;
    eebe:	6983      	ldr	r3, [r0, #24]
    eec0:	3301      	adds	r3, #1
    eec2:	6183      	str	r3, [r0, #24]

#ifdef CONFIG_MEM_SLAB_TRACE_MAX_UTILIZATION
		slab->max_used = MAX(slab->num_used, slab->max_used);
#endif

		result = 0;
    eec4:	2000      	movs	r0, #0
	__asm__ volatile(
    eec6:	f381 8811 	msr	BASEPRI, r1
    eeca:	f3bf 8f6f 	isb	sy
		return result;
	}

	k_spin_unlock(&lock, key);

	return result;
    eece:	e011      	b.n	eef4 <k_mem_slab_alloc+0x58>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    eed0:	ea56 0207 	orrs.w	r2, r6, r7
    eed4:	d103      	bne.n	eede <k_mem_slab_alloc+0x42>
		result = -ENOMEM;
    eed6:	f06f 000b 	mvn.w	r0, #11
		*mem = NULL;
    eeda:	6023      	str	r3, [r4, #0]
		result = -ENOMEM;
    eedc:	e7f3      	b.n	eec6 <k_mem_slab_alloc+0x2a>
		result = z_pend_curr(&lock, key, &slab->wait_q, timeout);
    eede:	4602      	mov	r2, r0
    eee0:	e9cd 6700 	strd	r6, r7, [sp]
    eee4:	4804      	ldr	r0, [pc, #16]	; (eef8 <k_mem_slab_alloc+0x5c>)
    eee6:	f000 fb7d 	bl	f5e4 <z_pend_curr>
		if (result == 0) {
    eeea:	b918      	cbnz	r0, eef4 <k_mem_slab_alloc+0x58>
			*mem = _current->base.swap_data;
    eeec:	4b03      	ldr	r3, [pc, #12]	; (eefc <k_mem_slab_alloc+0x60>)
    eeee:	689b      	ldr	r3, [r3, #8]
    eef0:	695b      	ldr	r3, [r3, #20]
    eef2:	6023      	str	r3, [r4, #0]
}
    eef4:	b002      	add	sp, #8
    eef6:	bdd0      	pop	{r4, r6, r7, pc}
    eef8:	20000967 	.word	0x20000967
    eefc:	20000908 	.word	0x20000908

0000ef00 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
    ef00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    ef02:	4604      	mov	r4, r0
    ef04:	460d      	mov	r5, r1
	__asm__ volatile(
    ef06:	f04f 0320 	mov.w	r3, #32
    ef0a:	f3ef 8611 	mrs	r6, BASEPRI
    ef0e:	f383 8811 	msr	BASEPRI, r3
    ef12:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);

	if (slab->free_list == NULL) {
    ef16:	6947      	ldr	r7, [r0, #20]
    ef18:	b96f      	cbnz	r7, ef36 <k_mem_slab_free+0x36>
		struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
    ef1a:	f001 fda3 	bl	10a64 <z_unpend_first_thread>

		if (pending_thread != NULL) {
    ef1e:	b150      	cbz	r0, ef36 <k_mem_slab_free+0x36>
			z_thread_return_value_set_with_data(pending_thread, 0, *mem);
    ef20:	682a      	ldr	r2, [r5, #0]
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
    ef22:	67c7      	str	r7, [r0, #124]	; 0x7c
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
    ef24:	6142      	str	r2, [r0, #20]
			z_ready_thread(pending_thread);
    ef26:	f001 fd42 	bl	109ae <z_ready_thread>
			z_reschedule(&lock, key);
    ef2a:	4631      	mov	r1, r6
	}
	**(char ***) mem = slab->free_list;
	slab->free_list = *(char **) mem;
	slab->num_used--;
	k_spin_unlock(&lock, key);
}
    ef2c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			z_reschedule(&lock, key);
    ef30:	4807      	ldr	r0, [pc, #28]	; (ef50 <k_mem_slab_free+0x50>)
    ef32:	f000 b90f 	b.w	f154 <z_reschedule>
	**(char ***) mem = slab->free_list;
    ef36:	682b      	ldr	r3, [r5, #0]
    ef38:	6962      	ldr	r2, [r4, #20]
    ef3a:	601a      	str	r2, [r3, #0]
	slab->free_list = *(char **) mem;
    ef3c:	682b      	ldr	r3, [r5, #0]
    ef3e:	6163      	str	r3, [r4, #20]
	slab->num_used--;
    ef40:	69a3      	ldr	r3, [r4, #24]
    ef42:	3b01      	subs	r3, #1
    ef44:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
    ef46:	f386 8811 	msr	BASEPRI, r6
    ef4a:	f3bf 8f6f 	isb	sy
}
    ef4e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ef50:	20000967 	.word	0x20000967

0000ef54 <z_impl_k_mutex_lock>:
	}
	return false;
}

int z_impl_k_mutex_lock(struct k_mutex *mutex, k_timeout_t timeout)
{
    ef54:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    ef58:	4604      	mov	r4, r0
    ef5a:	4616      	mov	r6, r2
    ef5c:	461f      	mov	r7, r3
	__asm__ volatile(
    ef5e:	f04f 0320 	mov.w	r3, #32
    ef62:	f3ef 8811 	mrs	r8, BASEPRI
    ef66:	f383 8811 	msr	BASEPRI, r3
    ef6a:	f3bf 8f6f 	isb	sy
	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	sys_trace_mutex_lock(mutex);
	key = k_spin_lock(&lock);

	if (likely((mutex->lock_count == 0U) || (mutex->owner == _current))) {
    ef6e:	68c3      	ldr	r3, [r0, #12]
    ef70:	4a32      	ldr	r2, [pc, #200]	; (f03c <z_impl_k_mutex_lock+0xe8>)
    ef72:	b16b      	cbz	r3, ef90 <z_impl_k_mutex_lock+0x3c>
    ef74:	6880      	ldr	r0, [r0, #8]
    ef76:	6891      	ldr	r1, [r2, #8]
    ef78:	4288      	cmp	r0, r1
    ef7a:	d019      	beq.n	efb0 <z_impl_k_mutex_lock+0x5c>
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);

		return 0;
	}

	if (unlikely(K_TIMEOUT_EQ(timeout, K_NO_WAIT))) {
    ef7c:	ea56 0307 	orrs.w	r3, r6, r7
    ef80:	d118      	bne.n	efb4 <z_impl_k_mutex_lock+0x60>
	__asm__ volatile(
    ef82:	f388 8811 	msr	BASEPRI, r8
    ef86:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
		return -EBUSY;
    ef8a:	f06f 000f 	mvn.w	r0, #15
    ef8e:	e00c      	b.n	efaa <z_impl_k_mutex_lock+0x56>
					_current->base.prio :
    ef90:	6891      	ldr	r1, [r2, #8]
    ef92:	f991 100e 	ldrsb.w	r1, [r1, #14]
		mutex->lock_count++;
    ef96:	3301      	adds	r3, #1
    ef98:	60e3      	str	r3, [r4, #12]
		mutex->owner = _current;
    ef9a:	6893      	ldr	r3, [r2, #8]
		mutex->owner_orig_prio = (mutex->lock_count == 0U) ?
    ef9c:	6121      	str	r1, [r4, #16]
		mutex->owner = _current;
    ef9e:	60a3      	str	r3, [r4, #8]
    efa0:	f388 8811 	msr	BASEPRI, r8
    efa4:	f3bf 8f6f 	isb	sy
		return 0;
    efa8:	2000      	movs	r0, #0
		k_spin_unlock(&lock, key);
	}

	sys_trace_end_call(SYS_TRACE_ID_MUTEX_LOCK);
	return -EAGAIN;
}
    efaa:	b002      	add	sp, #8
    efac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
					_current->base.prio :
    efb0:	6921      	ldr	r1, [r4, #16]
    efb2:	e7f0      	b.n	ef96 <z_impl_k_mutex_lock+0x42>
	new_prio = new_prio_for_inheritance(_current->base.prio,
    efb4:	f990 300e 	ldrsb.w	r3, [r0, #14]
    efb8:	f991 100e 	ldrsb.w	r1, [r1, #14]
    efbc:	4299      	cmp	r1, r3
    efbe:	bfa8      	it	ge
    efc0:	4619      	movge	r1, r3
    efc2:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	if (z_is_prio_higher(new_prio, mutex->owner->base.prio)) {
    efc6:	4299      	cmp	r1, r3
    efc8:	da2c      	bge.n	f024 <z_impl_k_mutex_lock+0xd0>
		return z_set_prio(mutex->owner, new_prio);
    efca:	f000 fb59 	bl	f680 <z_set_prio>
    efce:	4605      	mov	r5, r0
	int got_mutex = z_pend_curr(&lock, key, &mutex->wait_q, timeout);
    efd0:	4622      	mov	r2, r4
    efd2:	4641      	mov	r1, r8
    efd4:	e9cd 6700 	strd	r6, r7, [sp]
    efd8:	4819      	ldr	r0, [pc, #100]	; (f040 <z_impl_k_mutex_lock+0xec>)
    efda:	f000 fb03 	bl	f5e4 <z_pend_curr>
	if (got_mutex == 0) {
    efde:	2800      	cmp	r0, #0
    efe0:	d0e3      	beq.n	efaa <z_impl_k_mutex_lock+0x56>
	__asm__ volatile(
    efe2:	f04f 0320 	mov.w	r3, #32
    efe6:	f3ef 8611 	mrs	r6, BASEPRI
    efea:	f383 8811 	msr	BASEPRI, r3
    efee:	f3bf 8f6f 	isb	sy
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
    eff2:	6823      	ldr	r3, [r4, #0]
    eff4:	6921      	ldr	r1, [r4, #16]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
    eff6:	42a3      	cmp	r3, r4
    eff8:	d007      	beq.n	f00a <z_impl_k_mutex_lock+0xb6>
		new_prio_for_inheritance(waiter->base.prio, mutex->owner_orig_prio) :
    effa:	b133      	cbz	r3, f00a <z_impl_k_mutex_lock+0xb6>
    effc:	f993 300e 	ldrsb.w	r3, [r3, #14]
    f000:	4299      	cmp	r1, r3
    f002:	bfa8      	it	ge
    f004:	4619      	movge	r1, r3
    f006:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
	resched = adjust_owner_prio(mutex, new_prio) || resched;
    f00a:	68a0      	ldr	r0, [r4, #8]
	if (mutex->owner->base.prio != new_prio) {
    f00c:	f990 300e 	ldrsb.w	r3, [r0, #14]
    f010:	4299      	cmp	r1, r3
    f012:	d109      	bne.n	f028 <z_impl_k_mutex_lock+0xd4>
	if (resched) {
    f014:	b16d      	cbz	r5, f032 <z_impl_k_mutex_lock+0xde>
		z_reschedule(&lock, key);
    f016:	4631      	mov	r1, r6
    f018:	4809      	ldr	r0, [pc, #36]	; (f040 <z_impl_k_mutex_lock+0xec>)
    f01a:	f000 f89b 	bl	f154 <z_reschedule>
	return -EAGAIN;
    f01e:	f06f 000a 	mvn.w	r0, #10
    f022:	e7c2      	b.n	efaa <z_impl_k_mutex_lock+0x56>
	bool resched = false;
    f024:	2500      	movs	r5, #0
    f026:	e7d3      	b.n	efd0 <z_impl_k_mutex_lock+0x7c>
		return z_set_prio(mutex->owner, new_prio);
    f028:	f000 fb2a 	bl	f680 <z_set_prio>
	resched = adjust_owner_prio(mutex, new_prio) || resched;
    f02c:	2800      	cmp	r0, #0
    f02e:	d1f2      	bne.n	f016 <z_impl_k_mutex_lock+0xc2>
    f030:	e7f0      	b.n	f014 <z_impl_k_mutex_lock+0xc0>
	__asm__ volatile(
    f032:	f386 8811 	msr	BASEPRI, r6
    f036:	f3bf 8f6f 	isb	sy
    f03a:	e7f0      	b.n	f01e <z_impl_k_mutex_lock+0xca>
    f03c:	20000908 	.word	0x20000908
    f040:	20000967 	.word	0x20000967

0000f044 <z_impl_k_mutex_unlock>:
}
#include <syscalls/k_mutex_lock_mrsh.c>
#endif

int z_impl_k_mutex_unlock(struct k_mutex *mutex)
{
    f044:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *new_owner;

	__ASSERT(!arch_is_in_isr(), "mutexes cannot be used inside ISRs");

	CHECKIF(mutex->owner == NULL) {
    f046:	6883      	ldr	r3, [r0, #8]
{
    f048:	4604      	mov	r4, r0
	CHECKIF(mutex->owner == NULL) {
    f04a:	2b00      	cmp	r3, #0
    f04c:	d036      	beq.n	f0bc <z_impl_k_mutex_unlock+0x78>
		return -EINVAL;
	}
	/*
	 * The current thread does not own the mutex.
	 */
	CHECKIF(mutex->owner != _current) {
    f04e:	4a1e      	ldr	r2, [pc, #120]	; (f0c8 <z_impl_k_mutex_unlock+0x84>)
    f050:	6892      	ldr	r2, [r2, #8]
    f052:	4293      	cmp	r3, r2
    f054:	d135      	bne.n	f0c2 <z_impl_k_mutex_unlock+0x7e>
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
    f056:	7bda      	ldrb	r2, [r3, #15]
    f058:	3a01      	subs	r2, #1
    f05a:	73da      	strb	r2, [r3, #15]

	/*
	 * If we are the owner and count is greater than 1, then decrement
	 * the count and return and keep current thread as the owner.
	 */
	if (mutex->lock_count - 1U != 0U) {
    f05c:	68c3      	ldr	r3, [r0, #12]
    f05e:	2b01      	cmp	r3, #1
    f060:	d005      	beq.n	f06e <z_impl_k_mutex_unlock+0x2a>
		mutex->lock_count--;
    f062:	3b01      	subs	r3, #1
    f064:	60c3      	str	r3, [r0, #12]
		k_spin_unlock(&lock, key);
	}


k_mutex_unlock_return:
	k_sched_unlock();
    f066:	f000 f8d9 	bl	f21c <k_sched_unlock>
	sys_trace_end_call(SYS_TRACE_ID_MUTEX_UNLOCK);

	return 0;
    f06a:	2000      	movs	r0, #0
}
    f06c:	bd38      	pop	{r3, r4, r5, pc}
	__asm__ volatile(
    f06e:	f04f 0320 	mov.w	r3, #32
    f072:	f3ef 8511 	mrs	r5, BASEPRI
    f076:	f383 8811 	msr	BASEPRI, r3
    f07a:	f3bf 8f6f 	isb	sy
	adjust_owner_prio(mutex, mutex->owner_orig_prio);
    f07e:	6901      	ldr	r1, [r0, #16]
    f080:	6880      	ldr	r0, [r0, #8]
	if (mutex->owner->base.prio != new_prio) {
    f082:	f990 300e 	ldrsb.w	r3, [r0, #14]
    f086:	4299      	cmp	r1, r3
    f088:	d001      	beq.n	f08e <z_impl_k_mutex_unlock+0x4a>
		return z_set_prio(mutex->owner, new_prio);
    f08a:	f000 faf9 	bl	f680 <z_set_prio>
	new_owner = z_unpend_first_thread(&mutex->wait_q);
    f08e:	4620      	mov	r0, r4
    f090:	f001 fce8 	bl	10a64 <z_unpend_first_thread>
	mutex->owner = new_owner;
    f094:	60a0      	str	r0, [r4, #8]
	if (new_owner != NULL) {
    f096:	b158      	cbz	r0, f0b0 <z_impl_k_mutex_unlock+0x6c>
		mutex->owner_orig_prio = new_owner->base.prio;
    f098:	f990 200e 	ldrsb.w	r2, [r0, #14]
    f09c:	6122      	str	r2, [r4, #16]
    f09e:	2200      	movs	r2, #0
    f0a0:	67c2      	str	r2, [r0, #124]	; 0x7c
		z_ready_thread(new_owner);
    f0a2:	f001 fc84 	bl	109ae <z_ready_thread>
		z_reschedule(&lock, key);
    f0a6:	4629      	mov	r1, r5
    f0a8:	4808      	ldr	r0, [pc, #32]	; (f0cc <z_impl_k_mutex_unlock+0x88>)
    f0aa:	f000 f853 	bl	f154 <z_reschedule>
    f0ae:	e7da      	b.n	f066 <z_impl_k_mutex_unlock+0x22>
		mutex->lock_count = 0U;
    f0b0:	60e0      	str	r0, [r4, #12]
	__asm__ volatile(
    f0b2:	f385 8811 	msr	BASEPRI, r5
    f0b6:	f3bf 8f6f 	isb	sy
    f0ba:	e7d4      	b.n	f066 <z_impl_k_mutex_unlock+0x22>
		return -EINVAL;
    f0bc:	f06f 0015 	mvn.w	r0, #21
    f0c0:	e7d4      	b.n	f06c <z_impl_k_mutex_unlock+0x28>
		return -EPERM;
    f0c2:	f04f 30ff 	mov.w	r0, #4294967295
    f0c6:	e7d1      	b.n	f06c <z_impl_k_mutex_unlock+0x28>
    f0c8:	20000908 	.word	0x20000908
    f0cc:	20000967 	.word	0x20000967

0000f0d0 <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
    f0d0:	b510      	push	{r4, lr}
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
    f0d2:	4c08      	ldr	r4, [pc, #32]	; (f0f4 <z_reset_time_slice+0x24>)
    f0d4:	6823      	ldr	r3, [r4, #0]
    f0d6:	b15b      	cbz	r3, f0f0 <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
    f0d8:	f7fe faa6 	bl	d628 <z_clock_elapsed>
    f0dc:	4603      	mov	r3, r0
    f0de:	6820      	ldr	r0, [r4, #0]
    f0e0:	4a05      	ldr	r2, [pc, #20]	; (f0f8 <z_reset_time_slice+0x28>)
    f0e2:	4403      	add	r3, r0
		z_set_timeout_expiry(slice_time, false);
    f0e4:	2100      	movs	r1, #0
	}
}
    f0e6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
    f0ea:	6153      	str	r3, [r2, #20]
		z_set_timeout_expiry(slice_time, false);
    f0ec:	f001 bd0f 	b.w	10b0e <z_set_timeout_expiry>
}
    f0f0:	bd10      	pop	{r4, pc}
    f0f2:	bf00      	nop
    f0f4:	20000944 	.word	0x20000944
    f0f8:	20000908 	.word	0x20000908

0000f0fc <k_sched_time_slice_set>:

void k_sched_time_slice_set(int32_t slice, int prio)
{
    f0fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    f0fe:	4605      	mov	r5, r0
    f100:	460c      	mov	r4, r1
	__asm__ volatile(
    f102:	f04f 0320 	mov.w	r3, #32
    f106:	f3ef 8611 	mrs	r6, BASEPRI
    f10a:	f383 8811 	msr	BASEPRI, r3
    f10e:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
    f112:	2200      	movs	r2, #0
		} else {
			return t * (to_hz / from_hz);
		}
	} else {
		if (result32) {
			return (uint32_t)((t * to_hz + off) / from_hz);
    f114:	f44f 4700 	mov.w	r7, #32768	; 0x8000
    f118:	f240 30e7 	movw	r0, #999	; 0x3e7
    f11c:	2100      	movs	r1, #0
    f11e:	4b0a      	ldr	r3, [pc, #40]	; (f148 <k_sched_time_slice_set+0x4c>)
    f120:	fbe7 0105 	umlal	r0, r1, r7, r5
    f124:	615a      	str	r2, [r3, #20]
    f126:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    f12a:	2300      	movs	r3, #0
    f12c:	f7fd f912 	bl	c354 <__aeabi_uldivmod>
		slice_time = k_ms_to_ticks_ceil32(slice);
    f130:	4b06      	ldr	r3, [pc, #24]	; (f14c <k_sched_time_slice_set+0x50>)
    f132:	6018      	str	r0, [r3, #0]
		slice_max_prio = prio;
    f134:	4b06      	ldr	r3, [pc, #24]	; (f150 <k_sched_time_slice_set+0x54>)
    f136:	601c      	str	r4, [r3, #0]
		z_reset_time_slice();
    f138:	f7ff ffca 	bl	f0d0 <z_reset_time_slice>
	__asm__ volatile(
    f13c:	f386 8811 	msr	BASEPRI, r6
    f140:	f3bf 8f6f 	isb	sy
	}
}
    f144:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    f146:	bf00      	nop
    f148:	20000908 	.word	0x20000908
    f14c:	20000944 	.word	0x20000944
    f150:	20000940 	.word	0x20000940

0000f154 <z_reschedule>:
{
#ifdef CONFIG_SMP
	_current_cpu->swap_ok = 0;
#endif

	return arch_irq_unlocked(key) && !arch_is_in_isr();
    f154:	b949      	cbnz	r1, f16a <z_reschedule+0x16>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    f156:	f3ef 8005 	mrs	r0, IPSR
    f15a:	b930      	cbnz	r0, f16a <z_reschedule+0x16>
	return _kernel.ready_q.cache;
    f15c:	4b05      	ldr	r3, [pc, #20]	; (f174 <z_reschedule+0x20>)
#endif
}

void z_reschedule(struct k_spinlock *lock, k_spinlock_key_t key)
{
	if (resched(key.key) && need_swap()) {
    f15e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    f160:	689b      	ldr	r3, [r3, #8]
    f162:	429a      	cmp	r2, r3
    f164:	d001      	beq.n	f16a <z_reschedule+0x16>
	ret = arch_swap(key);
    f166:	f7fe bb55 	b.w	d814 <arch_swap>
    f16a:	f381 8811 	msr	BASEPRI, r1
    f16e:	f3bf 8f6f 	isb	sy
		z_swap(lock, key);
	} else {
		k_spin_unlock(lock, key);
	}
}
    f172:	4770      	bx	lr
    f174:	20000908 	.word	0x20000908

0000f178 <k_sched_lock>:
	__asm__ volatile(
    f178:	f04f 0320 	mov.w	r3, #32
    f17c:	f3ef 8111 	mrs	r1, BASEPRI
    f180:	f383 8811 	msr	BASEPRI, r3
    f184:	f3bf 8f6f 	isb	sy
	--_current->base.sched_locked;
    f188:	4b04      	ldr	r3, [pc, #16]	; (f19c <k_sched_lock+0x24>)
    f18a:	689a      	ldr	r2, [r3, #8]
    f18c:	7bd3      	ldrb	r3, [r2, #15]
    f18e:	3b01      	subs	r3, #1
    f190:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
    f192:	f381 8811 	msr	BASEPRI, r1
    f196:	f3bf 8f6f 	isb	sy
void k_sched_lock(void)
{
	LOCKED(&sched_spinlock) {
		z_sched_lock();
	}
}
    f19a:	4770      	bx	lr
    f19c:	20000908 	.word	0x20000908

0000f1a0 <z_priq_dumb_remove>:
}

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
#if defined(CONFIG_SWAP_NONATOMIC) && defined(CONFIG_SCHED_DUMB)
	if (pq == &_kernel.ready_q.runq && thread == _current &&
    f1a0:	4b09      	ldr	r3, [pc, #36]	; (f1c8 <z_priq_dumb_remove+0x28>)
    f1a2:	f103 022c 	add.w	r2, r3, #44	; 0x2c
    f1a6:	4282      	cmp	r2, r0
    f1a8:	d105      	bne.n	f1b6 <z_priq_dumb_remove+0x16>
    f1aa:	689b      	ldr	r3, [r3, #8]
    f1ac:	428b      	cmp	r3, r1
    f1ae:	d102      	bne.n	f1b6 <z_priq_dumb_remove+0x16>
    f1b0:	7b4b      	ldrb	r3, [r1, #13]
    f1b2:	06db      	lsls	r3, r3, #27
    f1b4:	d106      	bne.n	f1c4 <z_priq_dumb_remove+0x24>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
    f1b6:	e9d1 3200 	ldrd	r3, r2, [r1]
    f1ba:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
    f1bc:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    f1be:	2300      	movs	r3, #0
	node->prev = NULL;
    f1c0:	e9c1 3300 	strd	r3, r3, [r1]
#endif

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
}
    f1c4:	4770      	bx	lr
    f1c6:	bf00      	nop
    f1c8:	20000908 	.word	0x20000908

0000f1cc <update_cache>:
{
    f1cc:	b538      	push	{r3, r4, r5, lr}
    f1ce:	4c12      	ldr	r4, [pc, #72]	; (f218 <update_cache+0x4c>)
    f1d0:	4601      	mov	r1, r0
	if (_current_cpu->pending_abort != NULL) {
    f1d2:	6923      	ldr	r3, [r4, #16]
    f1d4:	68a2      	ldr	r2, [r4, #8]
    f1d6:	b10b      	cbz	r3, f1dc <update_cache+0x10>
	return thread ? thread : _current_cpu->idle_thread;
    f1d8:	68e5      	ldr	r5, [r4, #12]
    f1da:	e00c      	b.n	f1f6 <update_cache+0x2a>
	thread = _priq_run_best(&_kernel.ready_q.runq);
    f1dc:	f104 002c 	add.w	r0, r4, #44	; 0x2c
    f1e0:	f001 fbdb 	bl	1099a <z_priq_dumb_best>
    f1e4:	4605      	mov	r5, r0
	if (_current->base.thread_state & _THREAD_ABORTING) {
    f1e6:	7b53      	ldrb	r3, [r2, #13]
    f1e8:	0698      	lsls	r0, r3, #26
		_current->base.thread_state |= _THREAD_DEAD;
    f1ea:	bf44      	itt	mi
    f1ec:	f043 0308 	orrmi.w	r3, r3, #8
    f1f0:	7353      	strbmi	r3, [r2, #13]
	return thread ? thread : _current_cpu->idle_thread;
    f1f2:	2d00      	cmp	r5, #0
    f1f4:	d0f0      	beq.n	f1d8 <update_cache+0xc>
	if (preempt_ok != 0) {
    f1f6:	b949      	cbnz	r1, f20c <update_cache+0x40>
	if (z_is_thread_prevented_from_running(_current)) {
    f1f8:	7b53      	ldrb	r3, [r2, #13]
    f1fa:	06db      	lsls	r3, r3, #27
    f1fc:	d106      	bne.n	f20c <update_cache+0x40>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
    f1fe:	69ab      	ldr	r3, [r5, #24]
    f200:	b923      	cbnz	r3, f20c <update_cache+0x40>
	if (is_preempt(_current) || is_metairq(thread)) {
    f202:	89d3      	ldrh	r3, [r2, #14]
    f204:	2b7f      	cmp	r3, #127	; 0x7f
    f206:	d901      	bls.n	f20c <update_cache+0x40>
		_kernel.ready_q.cache = _current;
    f208:	62a2      	str	r2, [r4, #40]	; 0x28
}
    f20a:	bd38      	pop	{r3, r4, r5, pc}
		if (thread != _current) {
    f20c:	4295      	cmp	r5, r2
    f20e:	d001      	beq.n	f214 <update_cache+0x48>
			z_reset_time_slice();
    f210:	f7ff ff5e 	bl	f0d0 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
    f214:	62a5      	str	r5, [r4, #40]	; 0x28
}
    f216:	e7f8      	b.n	f20a <update_cache+0x3e>
    f218:	20000908 	.word	0x20000908

0000f21c <k_sched_unlock>:
{
    f21c:	b510      	push	{r4, lr}
	__asm__ volatile(
    f21e:	f04f 0320 	mov.w	r3, #32
    f222:	f3ef 8411 	mrs	r4, BASEPRI
    f226:	f383 8811 	msr	BASEPRI, r3
    f22a:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
    f22e:	4b08      	ldr	r3, [pc, #32]	; (f250 <k_sched_unlock+0x34>)
		update_cache(0);
    f230:	2000      	movs	r0, #0
		++_current->base.sched_locked;
    f232:	689a      	ldr	r2, [r3, #8]
    f234:	7bd3      	ldrb	r3, [r2, #15]
    f236:	3301      	adds	r3, #1
    f238:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
    f23a:	f7ff ffc7 	bl	f1cc <update_cache>
	__asm__ volatile(
    f23e:	f384 8811 	msr	BASEPRI, r4
    f242:	f3bf 8f6f 	isb	sy
}
    f246:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
    f24a:	f001 bb90 	b.w	1096e <z_reschedule_unlocked>
    f24e:	bf00      	nop
    f250:	20000908 	.word	0x20000908

0000f254 <ready_thread>:
{
    f254:	b470      	push	{r4, r5, r6}
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
    f256:	f990 200d 	ldrsb.w	r2, [r0, #13]
	return z_is_thread_state_set(thread, _THREAD_QUEUED);
    f25a:	7b43      	ldrb	r3, [r0, #13]
    f25c:	2a00      	cmp	r2, #0
    f25e:	db2c      	blt.n	f2ba <ready_thread+0x66>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    f260:	06db      	lsls	r3, r3, #27
    f262:	d12a      	bne.n	f2ba <ready_thread+0x66>

int z_abort_timeout(struct _timeout *to);

static inline bool z_is_inactive_timeout(const struct _timeout *t)
{
	return !sys_dnode_is_linked(&t->node);
    f264:	6983      	ldr	r3, [r0, #24]
    f266:	bb43      	cbnz	r3, f2ba <ready_thread+0x66>
	return list->head == list;
    f268:	4a15      	ldr	r2, [pc, #84]	; (f2c0 <ready_thread+0x6c>)
    f26a:	4611      	mov	r1, r2
    f26c:	f851 4f2c 	ldr.w	r4, [r1, #44]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
    f270:	428c      	cmp	r4, r1
    f272:	bf18      	it	ne
    f274:	4623      	movne	r3, r4
    f276:	2b00      	cmp	r3, #0
    f278:	bf38      	it	cc
    f27a:	2300      	movcc	r3, #0
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    f27c:	6b14      	ldr	r4, [r2, #48]	; 0x30
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    f27e:	b1b3      	cbz	r3, f2ae <ready_thread+0x5a>
	if (thread_1->base.prio < thread_2->base.prio) {
    f280:	f990 600e 	ldrsb.w	r6, [r0, #14]
    f284:	f993 500e 	ldrsb.w	r5, [r3, #14]
    f288:	42ae      	cmp	r6, r5
    f28a:	db03      	blt.n	f294 <ready_thread+0x40>
	return (node == list->tail) ? NULL : node->next;
    f28c:	42a3      	cmp	r3, r4
    f28e:	d00e      	beq.n	f2ae <ready_thread+0x5a>
    f290:	681b      	ldr	r3, [r3, #0]
    f292:	e7f4      	b.n	f27e <ready_thread+0x2a>
	node->prev = successor->prev;
    f294:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
    f296:	e9c0 3200 	strd	r3, r2, [r0]
	successor->prev->next = node;
    f29a:	6010      	str	r0, [r2, #0]
	successor->prev = node;
    f29c:	6058      	str	r0, [r3, #4]
	thread->base.thread_state |= states;
    f29e:	7b43      	ldrb	r3, [r0, #13]
    f2a0:	f063 037f 	orn	r3, r3, #127	; 0x7f
    f2a4:	7343      	strb	r3, [r0, #13]
}
    f2a6:	bc70      	pop	{r4, r5, r6}
		update_cache(0);
    f2a8:	2000      	movs	r0, #0
    f2aa:	f7ff bf8f 	b.w	f1cc <update_cache>
	node->prev = list->tail;
    f2ae:	e9c0 1400 	strd	r1, r4, [r0]
	list->tail->next = node;
    f2b2:	6b13      	ldr	r3, [r2, #48]	; 0x30
    f2b4:	6018      	str	r0, [r3, #0]
	list->tail = node;
    f2b6:	6310      	str	r0, [r2, #48]	; 0x30
}
    f2b8:	e7f1      	b.n	f29e <ready_thread+0x4a>
}
    f2ba:	bc70      	pop	{r4, r5, r6}
    f2bc:	4770      	bx	lr
    f2be:	bf00      	nop
    f2c0:	20000908 	.word	0x20000908

0000f2c4 <z_sched_start>:
{
    f2c4:	b510      	push	{r4, lr}
	__asm__ volatile(
    f2c6:	f04f 0220 	mov.w	r2, #32
    f2ca:	f3ef 8411 	mrs	r4, BASEPRI
    f2ce:	f382 8811 	msr	BASEPRI, r2
    f2d2:	f3bf 8f6f 	isb	sy
	if (z_has_thread_started(thread)) {
    f2d6:	7b42      	ldrb	r2, [r0, #13]
    f2d8:	0751      	lsls	r1, r2, #29
    f2da:	d404      	bmi.n	f2e6 <z_sched_start+0x22>
	__asm__ volatile(
    f2dc:	f384 8811 	msr	BASEPRI, r4
    f2e0:	f3bf 8f6f 	isb	sy
}
    f2e4:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
    f2e6:	f022 0204 	bic.w	r2, r2, #4
    f2ea:	7342      	strb	r2, [r0, #13]
	ready_thread(thread);
    f2ec:	f7ff ffb2 	bl	f254 <ready_thread>
	z_reschedule(&sched_spinlock, key);
    f2f0:	4621      	mov	r1, r4
}
    f2f2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&sched_spinlock, key);
    f2f6:	4801      	ldr	r0, [pc, #4]	; (f2fc <z_sched_start+0x38>)
    f2f8:	f7ff bf2c 	b.w	f154 <z_reschedule>
    f2fc:	20000967 	.word	0x20000967

0000f300 <move_thread_to_end_of_prio_q>:
{
    f300:	b570      	push	{r4, r5, r6, lr}
	if (z_is_thread_queued(thread)) {
    f302:	f990 300d 	ldrsb.w	r3, [r0, #13]
{
    f306:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
    f308:	2b00      	cmp	r3, #0
    f30a:	da02      	bge.n	f312 <move_thread_to_end_of_prio_q+0x12>
		_priq_run_remove(&_kernel.ready_q.runq, thread);
    f30c:	4817      	ldr	r0, [pc, #92]	; (f36c <move_thread_to_end_of_prio_q+0x6c>)
    f30e:	f7ff ff47 	bl	f1a0 <z_priq_dumb_remove>
	return list->head == list;
    f312:	4a17      	ldr	r2, [pc, #92]	; (f370 <move_thread_to_end_of_prio_q+0x70>)
    f314:	4610      	mov	r0, r2
    f316:	f850 3f2c 	ldr.w	r3, [r0, #44]!
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    f31a:	6b14      	ldr	r4, [r2, #48]	; 0x30
	return sys_dlist_is_empty(list) ? NULL : list->head;
    f31c:	4283      	cmp	r3, r0
    f31e:	bf08      	it	eq
    f320:	2300      	moveq	r3, #0
    f322:	2b00      	cmp	r3, #0
    f324:	bf38      	it	cc
    f326:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    f328:	b1d3      	cbz	r3, f360 <move_thread_to_end_of_prio_q+0x60>
	if (thread_1->base.prio < thread_2->base.prio) {
    f32a:	f991 600e 	ldrsb.w	r6, [r1, #14]
    f32e:	f993 500e 	ldrsb.w	r5, [r3, #14]
    f332:	42ae      	cmp	r6, r5
    f334:	db03      	blt.n	f33e <move_thread_to_end_of_prio_q+0x3e>
	return (node == list->tail) ? NULL : node->next;
    f336:	42a3      	cmp	r3, r4
    f338:	d012      	beq.n	f360 <move_thread_to_end_of_prio_q+0x60>
    f33a:	681b      	ldr	r3, [r3, #0]
    f33c:	e7f4      	b.n	f328 <move_thread_to_end_of_prio_q+0x28>
	node->prev = successor->prev;
    f33e:	6858      	ldr	r0, [r3, #4]
	node->next = successor;
    f340:	e9c1 3000 	strd	r3, r0, [r1]
	successor->prev->next = node;
    f344:	6001      	str	r1, [r0, #0]
	successor->prev = node;
    f346:	6059      	str	r1, [r3, #4]
	thread->base.thread_state |= states;
    f348:	7b4b      	ldrb	r3, [r1, #13]
	update_cache(thread == _current);
    f34a:	6890      	ldr	r0, [r2, #8]
    f34c:	f063 037f 	orn	r3, r3, #127	; 0x7f
    f350:	734b      	strb	r3, [r1, #13]
    f352:	1a43      	subs	r3, r0, r1
    f354:	4258      	negs	r0, r3
    f356:	4158      	adcs	r0, r3
}
    f358:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	update_cache(thread == _current);
    f35c:	f7ff bf36 	b.w	f1cc <update_cache>
	node->prev = list->tail;
    f360:	e9c1 0400 	strd	r0, r4, [r1]
	list->tail->next = node;
    f364:	6b13      	ldr	r3, [r2, #48]	; 0x30
    f366:	6019      	str	r1, [r3, #0]
	list->tail = node;
    f368:	6311      	str	r1, [r2, #48]	; 0x30
}
    f36a:	e7ed      	b.n	f348 <move_thread_to_end_of_prio_q+0x48>
    f36c:	20000934 	.word	0x20000934
    f370:	20000908 	.word	0x20000908

0000f374 <z_time_slice>:
{
    f374:	4601      	mov	r1, r0
    f376:	b570      	push	{r4, r5, r6, lr}
	__asm__ volatile(
    f378:	f04f 0320 	mov.w	r3, #32
    f37c:	f3ef 8411 	mrs	r4, BASEPRI
    f380:	f383 8811 	msr	BASEPRI, r3
    f384:	f3bf 8f6f 	isb	sy
	if (pending_current == _current) {
    f388:	4b16      	ldr	r3, [pc, #88]	; (f3e4 <z_time_slice+0x70>)
    f38a:	4a17      	ldr	r2, [pc, #92]	; (f3e8 <z_time_slice+0x74>)
    f38c:	6898      	ldr	r0, [r3, #8]
    f38e:	6815      	ldr	r5, [r2, #0]
    f390:	42a8      	cmp	r0, r5
    f392:	461d      	mov	r5, r3
    f394:	d106      	bne.n	f3a4 <z_time_slice+0x30>
			z_reset_time_slice();
    f396:	f7ff fe9b 	bl	f0d0 <z_reset_time_slice>
	__asm__ volatile(
    f39a:	f384 8811 	msr	BASEPRI, r4
    f39e:	f3bf 8f6f 	isb	sy
}
    f3a2:	bd70      	pop	{r4, r5, r6, pc}
	pending_current = NULL;
    f3a4:	2600      	movs	r6, #0
    f3a6:	6016      	str	r6, [r2, #0]
	if (slice_time && sliceable(_current)) {
    f3a8:	4a10      	ldr	r2, [pc, #64]	; (f3ec <z_time_slice+0x78>)
    f3aa:	6812      	ldr	r2, [r2, #0]
    f3ac:	b1ba      	cbz	r2, f3de <z_time_slice+0x6a>
		&& !z_is_idle_thread_object(thread);
    f3ae:	89c2      	ldrh	r2, [r0, #14]
    f3b0:	2a7f      	cmp	r2, #127	; 0x7f
    f3b2:	d814      	bhi.n	f3de <z_time_slice+0x6a>
		&& !z_is_thread_prevented_from_running(thread)
    f3b4:	7b42      	ldrb	r2, [r0, #13]
    f3b6:	06d2      	lsls	r2, r2, #27
    f3b8:	d111      	bne.n	f3de <z_time_slice+0x6a>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
    f3ba:	4a0d      	ldr	r2, [pc, #52]	; (f3f0 <z_time_slice+0x7c>)
    f3bc:	f990 600e 	ldrsb.w	r6, [r0, #14]
    f3c0:	6812      	ldr	r2, [r2, #0]
    f3c2:	4296      	cmp	r6, r2
    f3c4:	db0b      	blt.n	f3de <z_time_slice+0x6a>
		&& !z_is_idle_thread_object(thread);
    f3c6:	4a0b      	ldr	r2, [pc, #44]	; (f3f4 <z_time_slice+0x80>)
    f3c8:	4290      	cmp	r0, r2
    f3ca:	d008      	beq.n	f3de <z_time_slice+0x6a>
		if (ticks >= _current_cpu->slice_ticks) {
    f3cc:	695a      	ldr	r2, [r3, #20]
    f3ce:	428a      	cmp	r2, r1
    f3d0:	dc02      	bgt.n	f3d8 <z_time_slice+0x64>
			move_thread_to_end_of_prio_q(_current);
    f3d2:	f7ff ff95 	bl	f300 <move_thread_to_end_of_prio_q>
    f3d6:	e7de      	b.n	f396 <z_time_slice+0x22>
			_current_cpu->slice_ticks -= ticks;
    f3d8:	1a52      	subs	r2, r2, r1
    f3da:	615a      	str	r2, [r3, #20]
    f3dc:	e7dd      	b.n	f39a <z_time_slice+0x26>
		_current_cpu->slice_ticks = 0;
    f3de:	2300      	movs	r3, #0
    f3e0:	616b      	str	r3, [r5, #20]
    f3e2:	e7da      	b.n	f39a <z_time_slice+0x26>
    f3e4:	20000908 	.word	0x20000908
    f3e8:	2000093c 	.word	0x2000093c
    f3ec:	20000944 	.word	0x20000944
    f3f0:	20000940 	.word	0x20000940
    f3f4:	20000160 	.word	0x20000160

0000f3f8 <z_impl_k_thread_suspend>:
{
    f3f8:	b570      	push	{r4, r5, r6, lr}
    f3fa:	4604      	mov	r4, r0
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
    f3fc:	3018      	adds	r0, #24
    f3fe:	f001 fb60 	bl	10ac2 <z_abort_timeout>
	__asm__ volatile(
    f402:	f04f 0320 	mov.w	r3, #32
    f406:	f3ef 8611 	mrs	r6, BASEPRI
    f40a:	f383 8811 	msr	BASEPRI, r3
    f40e:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
    f412:	f994 300d 	ldrsb.w	r3, [r4, #13]
    f416:	2b00      	cmp	r3, #0
    f418:	da07      	bge.n	f42a <z_impl_k_thread_suspend+0x32>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
    f41a:	4621      	mov	r1, r4
    f41c:	480e      	ldr	r0, [pc, #56]	; (f458 <z_impl_k_thread_suspend+0x60>)
    f41e:	f7ff febf 	bl	f1a0 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
    f422:	7b63      	ldrb	r3, [r4, #13]
    f424:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    f428:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
    f42a:	4d0c      	ldr	r5, [pc, #48]	; (f45c <z_impl_k_thread_suspend+0x64>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
    f42c:	7b63      	ldrb	r3, [r4, #13]
    f42e:	68a8      	ldr	r0, [r5, #8]
    f430:	f043 0310 	orr.w	r3, r3, #16
    f434:	7363      	strb	r3, [r4, #13]
    f436:	1b03      	subs	r3, r0, r4
    f438:	4258      	negs	r0, r3
    f43a:	4158      	adcs	r0, r3
    f43c:	f7ff fec6 	bl	f1cc <update_cache>
	__asm__ volatile(
    f440:	f386 8811 	msr	BASEPRI, r6
    f444:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
    f448:	68ab      	ldr	r3, [r5, #8]
    f44a:	42a3      	cmp	r3, r4
    f44c:	d103      	bne.n	f456 <z_impl_k_thread_suspend+0x5e>
}
    f44e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
    f452:	f001 ba8c 	b.w	1096e <z_reschedule_unlocked>
}
    f456:	bd70      	pop	{r4, r5, r6, pc}
    f458:	20000934 	.word	0x20000934
    f45c:	20000908 	.word	0x20000908

0000f460 <z_thread_single_abort>:
{
    f460:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f464:	4604      	mov	r4, r0
	__asm__ volatile(
    f466:	f04f 0320 	mov.w	r3, #32
    f46a:	f3ef 8211 	mrs	r2, BASEPRI
    f46e:	f383 8811 	msr	BASEPRI, r3
    f472:	f3bf 8f6f 	isb	sy
	if ((thread->base.thread_state &
    f476:	7b43      	ldrb	r3, [r0, #13]
    f478:	f013 0f28 	tst.w	r3, #40	; 0x28
    f47c:	d005      	beq.n	f48a <z_thread_single_abort+0x2a>
	__asm__ volatile(
    f47e:	f382 8811 	msr	BASEPRI, r2
    f482:	f3bf 8f6f 	isb	sy
}
    f486:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	thread->base.thread_state |= _THREAD_ABORTING;
    f48a:	f043 0320 	orr.w	r3, r3, #32
    f48e:	7343      	strb	r3, [r0, #13]
    f490:	f382 8811 	msr	BASEPRI, r2
    f494:	f3bf 8f6f 	isb	sy
    f498:	3018      	adds	r0, #24
    f49a:	f001 fb12 	bl	10ac2 <z_abort_timeout>
	__asm__ volatile(
    f49e:	f04f 0320 	mov.w	r3, #32
    f4a2:	f3ef 8611 	mrs	r6, BASEPRI
    f4a6:	f383 8811 	msr	BASEPRI, r3
    f4aa:	f3bf 8f6f 	isb	sy
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    f4ae:	7b63      	ldrb	r3, [r4, #13]
    f4b0:	06d8      	lsls	r0, r3, #27
    f4b2:	d116      	bne.n	f4e2 <z_thread_single_abort+0x82>
		if (z_is_thread_ready(thread)) {
    f4b4:	69a2      	ldr	r2, [r4, #24]
    f4b6:	b9a2      	cbnz	r2, f4e2 <z_thread_single_abort+0x82>
			if (z_is_thread_queued(thread)) {
    f4b8:	0619      	lsls	r1, r3, #24
    f4ba:	d507      	bpl.n	f4cc <z_thread_single_abort+0x6c>
				_priq_run_remove(&_kernel.ready_q.runq,
    f4bc:	4621      	mov	r1, r4
    f4be:	4826      	ldr	r0, [pc, #152]	; (f558 <z_thread_single_abort+0xf8>)
    f4c0:	f7ff fe6e 	bl	f1a0 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
    f4c4:	7b63      	ldrb	r3, [r4, #13]
    f4c6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    f4ca:	7363      	strb	r3, [r4, #13]
			update_cache(thread == _current);
    f4cc:	4b23      	ldr	r3, [pc, #140]	; (f55c <z_thread_single_abort+0xfc>)
    f4ce:	6898      	ldr	r0, [r3, #8]
    f4d0:	1b02      	subs	r2, r0, r4
    f4d2:	4250      	negs	r0, r2
    f4d4:	4150      	adcs	r0, r2
    f4d6:	f7ff fe79 	bl	f1cc <update_cache>
			waiter->base.pended_on = NULL;
    f4da:	2700      	movs	r7, #0
	sys_dlist_init(&w->waitq);
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
    f4dc:	f104 0830 	add.w	r8, r4, #48	; 0x30
    f4e0:	e01d      	b.n	f51e <z_thread_single_abort+0xbe>
			if (z_is_thread_pending(thread)) {
    f4e2:	079b      	lsls	r3, r3, #30
    f4e4:	d5f9      	bpl.n	f4da <z_thread_single_abort+0x7a>
				_priq_wait_remove(&pended_on(thread)->waitq,
    f4e6:	4621      	mov	r1, r4
    f4e8:	68a0      	ldr	r0, [r4, #8]
    f4ea:	f7ff fe59 	bl	f1a0 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
    f4ee:	7b63      	ldrb	r3, [r4, #13]
    f4f0:	f023 0302 	bic.w	r3, r3, #2
    f4f4:	7363      	strb	r3, [r4, #13]
				thread->base.pended_on = NULL;
    f4f6:	2300      	movs	r3, #0
    f4f8:	60a3      	str	r3, [r4, #8]
    f4fa:	e7ee      	b.n	f4da <z_thread_single_abort+0x7a>
    f4fc:	f105 0018 	add.w	r0, r5, #24
    f500:	f001 fadf 	bl	10ac2 <z_abort_timeout>
			_priq_wait_remove(&pended_on(waiter)->waitq, waiter);
    f504:	68a8      	ldr	r0, [r5, #8]
    f506:	4629      	mov	r1, r5
    f508:	f7ff fe4a 	bl	f1a0 <z_priq_dumb_remove>
    f50c:	7b6b      	ldrb	r3, [r5, #13]
			ready_thread(waiter);
    f50e:	4628      	mov	r0, r5
    f510:	f023 0302 	bic.w	r3, r3, #2
    f514:	736b      	strb	r3, [r5, #13]
			waiter->base.pended_on = NULL;
    f516:	60af      	str	r7, [r5, #8]
    f518:	67ef      	str	r7, [r5, #124]	; 0x7c
			ready_thread(waiter);
    f51a:	f7ff fe9b 	bl	f254 <ready_thread>
	return list->head == list;
    f51e:	6b25      	ldr	r5, [r4, #48]	; 0x30
	return sys_dlist_is_empty(list) ? NULL : list->head;
    f520:	4545      	cmp	r5, r8
    f522:	d001      	beq.n	f528 <z_thread_single_abort+0xc8>
		while ((waiter = z_waitq_head(&thread->base.join_waiters)) !=
    f524:	2d00      	cmp	r5, #0
    f526:	d1e9      	bne.n	f4fc <z_thread_single_abort+0x9c>
		if (z_is_idle_thread_object(_current)) {
    f528:	4b0c      	ldr	r3, [pc, #48]	; (f55c <z_thread_single_abort+0xfc>)
    f52a:	689a      	ldr	r2, [r3, #8]
    f52c:	4b0c      	ldr	r3, [pc, #48]	; (f560 <z_thread_single_abort+0x100>)
    f52e:	429a      	cmp	r2, r3
    f530:	d102      	bne.n	f538 <z_thread_single_abort+0xd8>
			update_cache(1);
    f532:	2001      	movs	r0, #1
    f534:	f7ff fe4a 	bl	f1cc <update_cache>
		thread->base.thread_state |= _THREAD_DEAD;
    f538:	7b63      	ldrb	r3, [r4, #13]
    f53a:	f043 0308 	orr.w	r3, r3, #8
    f53e:	7363      	strb	r3, [r4, #13]
		fn_abort = thread->fn_abort;
    f540:	6e23      	ldr	r3, [r4, #96]	; 0x60
	__asm__ volatile(
    f542:	f386 8811 	msr	BASEPRI, r6
    f546:	f3bf 8f6f 	isb	sy
	if (fn_abort != NULL) {
    f54a:	2b00      	cmp	r3, #0
    f54c:	d09b      	beq.n	f486 <z_thread_single_abort+0x26>
		fn_abort(thread);
    f54e:	4620      	mov	r0, r4
}
    f550:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		fn_abort(thread);
    f554:	4718      	bx	r3
    f556:	bf00      	nop
    f558:	20000934 	.word	0x20000934
    f55c:	20000908 	.word	0x20000908
    f560:	20000160 	.word	0x20000160

0000f564 <unready_thread>:
{
    f564:	b508      	push	{r3, lr}
	if (z_is_thread_queued(thread)) {
    f566:	f990 300d 	ldrsb.w	r3, [r0, #13]
{
    f56a:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
    f56c:	2b00      	cmp	r3, #0
    f56e:	da06      	bge.n	f57e <unready_thread+0x1a>
		_priq_run_remove(&_kernel.ready_q.runq, thread);
    f570:	4807      	ldr	r0, [pc, #28]	; (f590 <unready_thread+0x2c>)
    f572:	f7ff fe15 	bl	f1a0 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
    f576:	7b4b      	ldrb	r3, [r1, #13]
    f578:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    f57c:	734b      	strb	r3, [r1, #13]
	update_cache(thread == _current);
    f57e:	4b05      	ldr	r3, [pc, #20]	; (f594 <unready_thread+0x30>)
    f580:	6898      	ldr	r0, [r3, #8]
    f582:	1a43      	subs	r3, r0, r1
    f584:	4258      	negs	r0, r3
    f586:	4158      	adcs	r0, r3
}
    f588:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	update_cache(thread == _current);
    f58c:	f7ff be1e 	b.w	f1cc <update_cache>
    f590:	20000934 	.word	0x20000934
    f594:	20000908 	.word	0x20000908

0000f598 <pend>:
{
    f598:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f59c:	4606      	mov	r6, r0
    f59e:	4614      	mov	r4, r2
    f5a0:	461d      	mov	r5, r3
	__asm__ volatile(
    f5a2:	f04f 0320 	mov.w	r3, #32
    f5a6:	f3ef 8711 	mrs	r7, BASEPRI
    f5aa:	f383 8811 	msr	BASEPRI, r3
    f5ae:	f3bf 8f6f 	isb	sy
		add_to_waitq_locked(thread, wait_q);
    f5b2:	f001 fa2c 	bl	10a0e <add_to_waitq_locked>
	__asm__ volatile(
    f5b6:	f387 8811 	msr	BASEPRI, r7
    f5ba:	f3bf 8f6f 	isb	sy
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    f5be:	1c6b      	adds	r3, r5, #1
    f5c0:	bf08      	it	eq
    f5c2:	f1b4 3fff 	cmpeq.w	r4, #4294967295
    f5c6:	d008      	beq.n	f5da <pend+0x42>
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
    f5c8:	4622      	mov	r2, r4
    f5ca:	462b      	mov	r3, r5
    f5cc:	f106 0018 	add.w	r0, r6, #24
    f5d0:	4903      	ldr	r1, [pc, #12]	; (f5e0 <pend+0x48>)
}
    f5d2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    f5d6:	f000 ba7b 	b.w	fad0 <z_add_timeout>
    f5da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    f5de:	bf00      	nop
    f5e0:	000109cf 	.word	0x000109cf

0000f5e4 <z_pend_curr>:
{
    f5e4:	b510      	push	{r4, lr}
    f5e6:	460c      	mov	r4, r1
	pending_current = _current;
    f5e8:	4b06      	ldr	r3, [pc, #24]	; (f604 <z_pend_curr+0x20>)
{
    f5ea:	4611      	mov	r1, r2
	pending_current = _current;
    f5ec:	6898      	ldr	r0, [r3, #8]
    f5ee:	4b06      	ldr	r3, [pc, #24]	; (f608 <z_pend_curr+0x24>)
    f5f0:	6018      	str	r0, [r3, #0]
	pend(_current, wait_q, timeout);
    f5f2:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
    f5f6:	f7ff ffcf 	bl	f598 <pend>
    f5fa:	4620      	mov	r0, r4
}
    f5fc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    f600:	f7fe b908 	b.w	d814 <arch_swap>
    f604:	20000908 	.word	0x20000908
    f608:	2000093c 	.word	0x2000093c

0000f60c <z_tick_sleep.part.0>:
	z_impl_k_yield();
}
#include <syscalls/k_yield_mrsh.c>
#endif

static int32_t z_tick_sleep(k_ticks_t ticks)
    f60c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f610:	4605      	mov	r5, r0
    f612:	460f      	mov	r7, r1
		return 0;
	}

	k_timeout_t timeout = Z_TIMEOUT_TICKS(ticks);

	expected_wakeup_ticks = ticks + z_tick_get_32();
    f614:	f001 fa95 	bl	10b42 <z_tick_get_32>
    f618:	4604      	mov	r4, r0
	__asm__ volatile(
    f61a:	f04f 0320 	mov.w	r3, #32
    f61e:	f3ef 8811 	mrs	r8, BASEPRI
    f622:	f383 8811 	msr	BASEPRI, r3
    f626:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&sched_spinlock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
    f62a:	4e12      	ldr	r6, [pc, #72]	; (f674 <z_tick_sleep.part.0+0x68>)
    f62c:	4b12      	ldr	r3, [pc, #72]	; (f678 <z_tick_sleep.part.0+0x6c>)
    f62e:	68b0      	ldr	r0, [r6, #8]
	expected_wakeup_ticks = ticks + z_tick_get_32();
    f630:	442c      	add	r4, r5
	pending_current = _current;
    f632:	6018      	str	r0, [r3, #0]
#endif
	unready_thread(_current);
    f634:	f7ff ff96 	bl	f564 <unready_thread>
	z_add_thread_timeout(_current, timeout);
    f638:	68b0      	ldr	r0, [r6, #8]
    f63a:	4910      	ldr	r1, [pc, #64]	; (f67c <z_tick_sleep.part.0+0x70>)
    f63c:	462a      	mov	r2, r5
    f63e:	463b      	mov	r3, r7
    f640:	3018      	adds	r0, #24
    f642:	f000 fa45 	bl	fad0 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
    f646:	68b2      	ldr	r2, [r6, #8]
    f648:	4640      	mov	r0, r8
	thread->base.thread_state |= _THREAD_SUSPENDED;
    f64a:	7b53      	ldrb	r3, [r2, #13]

	(void)z_swap(&sched_spinlock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = (k_ticks_t)expected_wakeup_ticks - z_tick_get_32();
    f64c:	2500      	movs	r5, #0
    f64e:	f043 0310 	orr.w	r3, r3, #16
    f652:	7353      	strb	r3, [r2, #13]
    f654:	f7fe f8de 	bl	d814 <arch_swap>
    f658:	f001 fa73 	bl	10b42 <z_tick_get_32>
    f65c:	1a24      	subs	r4, r4, r0
    f65e:	f165 0500 	sbc.w	r5, r5, #0
    f662:	2c00      	cmp	r4, #0
    f664:	f175 0300 	sbcs.w	r3, r5, #0
    f668:	bfb8      	it	lt
    f66a:	2400      	movlt	r4, #0
		return ticks;
	}
#endif

	return 0;
}
    f66c:	4620      	mov	r0, r4
    f66e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    f672:	bf00      	nop
    f674:	20000908 	.word	0x20000908
    f678:	2000093c 	.word	0x2000093c
    f67c:	000109cf 	.word	0x000109cf

0000f680 <z_set_prio>:
{
    f680:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    f684:	4604      	mov	r4, r0
    f686:	f04f 0320 	mov.w	r3, #32
    f68a:	f3ef 8811 	mrs	r8, BASEPRI
    f68e:	f383 8811 	msr	BASEPRI, r3
    f692:	f3bf 8f6f 	isb	sy
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
    f696:	7b43      	ldrb	r3, [r0, #13]
    f698:	b24e      	sxtb	r6, r1
    f69a:	06db      	lsls	r3, r3, #27
    f69c:	d12e      	bne.n	f6fc <z_set_prio+0x7c>
	return !sys_dnode_is_linked(&t->node);
    f69e:	6985      	ldr	r5, [r0, #24]
		if (need_sched) {
    f6a0:	bb65      	cbnz	r5, f6fc <z_set_prio+0x7c>
				_priq_run_remove(&_kernel.ready_q.runq, thread);
    f6a2:	4f18      	ldr	r7, [pc, #96]	; (f704 <z_set_prio+0x84>)
    f6a4:	4621      	mov	r1, r4
    f6a6:	f107 002c 	add.w	r0, r7, #44	; 0x2c
    f6aa:	f7ff fd79 	bl	f1a0 <z_priq_dumb_remove>
	return list->head == list;
    f6ae:	6afb      	ldr	r3, [r7, #44]	; 0x2c
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    f6b0:	6b3a      	ldr	r2, [r7, #48]	; 0x30
	return sys_dlist_is_empty(list) ? NULL : list->head;
    f6b2:	4283      	cmp	r3, r0
    f6b4:	bf18      	it	ne
    f6b6:	461d      	movne	r5, r3
    f6b8:	2d00      	cmp	r5, #0
    f6ba:	bf38      	it	cc
    f6bc:	2500      	movcc	r5, #0
				thread->base.prio = prio;
    f6be:	73a6      	strb	r6, [r4, #14]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    f6c0:	b1b5      	cbz	r5, f6f0 <z_set_prio+0x70>
	if (thread_1->base.prio < thread_2->base.prio) {
    f6c2:	f995 100e 	ldrsb.w	r1, [r5, #14]
    f6c6:	42b1      	cmp	r1, r6
    f6c8:	dc03      	bgt.n	f6d2 <z_set_prio+0x52>
	return (node == list->tail) ? NULL : node->next;
    f6ca:	42aa      	cmp	r2, r5
    f6cc:	d010      	beq.n	f6f0 <z_set_prio+0x70>
    f6ce:	682d      	ldr	r5, [r5, #0]
    f6d0:	e7f6      	b.n	f6c0 <z_set_prio+0x40>
	node->prev = successor->prev;
    f6d2:	686a      	ldr	r2, [r5, #4]
	node->next = successor;
    f6d4:	e9c4 5200 	strd	r5, r2, [r4]
	successor->prev->next = node;
    f6d8:	6014      	str	r4, [r2, #0]
	successor->prev = node;
    f6da:	606c      	str	r4, [r5, #4]
			update_cache(1);
    f6dc:	2001      	movs	r0, #1
    f6de:	f7ff fd75 	bl	f1cc <update_cache>
    f6e2:	2001      	movs	r0, #1
	__asm__ volatile(
    f6e4:	f388 8811 	msr	BASEPRI, r8
    f6e8:	f3bf 8f6f 	isb	sy
}
    f6ec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	node->prev = list->tail;
    f6f0:	e9c4 0200 	strd	r0, r2, [r4]
	list->tail->next = node;
    f6f4:	6b3b      	ldr	r3, [r7, #48]	; 0x30
    f6f6:	601c      	str	r4, [r3, #0]
	list->tail = node;
    f6f8:	633c      	str	r4, [r7, #48]	; 0x30
}
    f6fa:	e7ef      	b.n	f6dc <z_set_prio+0x5c>
			thread->base.prio = prio;
    f6fc:	2000      	movs	r0, #0
    f6fe:	73a6      	strb	r6, [r4, #14]
    f700:	e7f0      	b.n	f6e4 <z_set_prio+0x64>
    f702:	bf00      	nop
    f704:	20000908 	.word	0x20000908

0000f708 <z_sched_init>:
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
    f708:	2100      	movs	r1, #0
	list->head = (sys_dnode_t *)list;
    f70a:	4b04      	ldr	r3, [pc, #16]	; (f71c <z_sched_init+0x14>)
    f70c:	4608      	mov	r0, r1
    f70e:	f103 022c 	add.w	r2, r3, #44	; 0x2c
	list->tail = (sys_dnode_t *)list;
    f712:	e9c3 220b 	strd	r2, r2, [r3, #44]	; 0x2c
    f716:	f7ff bcf1 	b.w	f0fc <k_sched_time_slice_set>
    f71a:	bf00      	nop
    f71c:	20000908 	.word	0x20000908

0000f720 <z_impl_k_yield>:
{
    f720:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!z_is_idle_thread_object(_current)) {
    f722:	4c24      	ldr	r4, [pc, #144]	; (f7b4 <z_impl_k_yield+0x94>)
    f724:	4b24      	ldr	r3, [pc, #144]	; (f7b8 <z_impl_k_yield+0x98>)
    f726:	68a2      	ldr	r2, [r4, #8]
    f728:	429a      	cmp	r2, r3
    f72a:	d030      	beq.n	f78e <z_impl_k_yield+0x6e>
	__asm__ volatile(
    f72c:	f04f 0320 	mov.w	r3, #32
    f730:	f3ef 8511 	mrs	r5, BASEPRI
    f734:	f383 8811 	msr	BASEPRI, r3
    f738:	f3bf 8f6f 	isb	sy
				_priq_run_remove(&_kernel.ready_q.runq,
    f73c:	68a1      	ldr	r1, [r4, #8]
    f73e:	f104 002c 	add.w	r0, r4, #44	; 0x2c
    f742:	f7ff fd2d 	bl	f1a0 <z_priq_dumb_remove>
	return list->head == list;
    f746:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
			_priq_run_add(&_kernel.ready_q.runq, _current);
    f748:	68a2      	ldr	r2, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    f74a:	4283      	cmp	r3, r0
    f74c:	bf08      	it	eq
    f74e:	2300      	moveq	r3, #0
    f750:	2b00      	cmp	r3, #0
    f752:	bf38      	it	cc
    f754:	2300      	movcc	r3, #0
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    f756:	6b21      	ldr	r1, [r4, #48]	; 0x30
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
    f758:	b32b      	cbz	r3, f7a6 <z_impl_k_yield+0x86>
	if (thread_1->base.prio < thread_2->base.prio) {
    f75a:	f992 700e 	ldrsb.w	r7, [r2, #14]
    f75e:	f993 600e 	ldrsb.w	r6, [r3, #14]
    f762:	42b7      	cmp	r7, r6
    f764:	db03      	blt.n	f76e <z_impl_k_yield+0x4e>
	return (node == list->tail) ? NULL : node->next;
    f766:	428b      	cmp	r3, r1
    f768:	d01d      	beq.n	f7a6 <z_impl_k_yield+0x86>
    f76a:	681b      	ldr	r3, [r3, #0]
    f76c:	e7f4      	b.n	f758 <z_impl_k_yield+0x38>
	node->prev = successor->prev;
    f76e:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
    f770:	e9c2 3100 	strd	r3, r1, [r2]
	successor->prev->next = node;
    f774:	600a      	str	r2, [r1, #0]
	successor->prev = node;
    f776:	605a      	str	r2, [r3, #4]
	thread->base.thread_state |= states;
    f778:	7b53      	ldrb	r3, [r2, #13]
			update_cache(1);
    f77a:	2001      	movs	r0, #1
    f77c:	f063 037f 	orn	r3, r3, #127	; 0x7f
    f780:	7353      	strb	r3, [r2, #13]
    f782:	f7ff fd23 	bl	f1cc <update_cache>
	__asm__ volatile(
    f786:	f385 8811 	msr	BASEPRI, r5
    f78a:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
    f78e:	f04f 0320 	mov.w	r3, #32
    f792:	f3ef 8011 	mrs	r0, BASEPRI
    f796:	f383 8811 	msr	BASEPRI, r3
    f79a:	f3bf 8f6f 	isb	sy
}
    f79e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    f7a2:	f7fe b837 	b.w	d814 <arch_swap>
	node->prev = list->tail;
    f7a6:	e9c2 0100 	strd	r0, r1, [r2]
	list->tail->next = node;
    f7aa:	6b23      	ldr	r3, [r4, #48]	; 0x30
    f7ac:	601a      	str	r2, [r3, #0]
	list->tail = node;
    f7ae:	6322      	str	r2, [r4, #48]	; 0x30
}
    f7b0:	e7e2      	b.n	f778 <z_impl_k_yield+0x58>
    f7b2:	bf00      	nop
    f7b4:	20000908 	.word	0x20000908
    f7b8:	20000160 	.word	0x20000160

0000f7bc <z_impl_k_sleep>:

	__ASSERT(!arch_is_in_isr(), "");
	sys_trace_void(SYS_TRACE_ID_SLEEP);

	/* in case of K_FOREVER, we suspend */
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    f7bc:	f1b1 3fff 	cmp.w	r1, #4294967295
    f7c0:	bf08      	it	eq
    f7c2:	f1b0 3fff 	cmpeq.w	r0, #4294967295
{
    f7c6:	b508      	push	{r3, lr}
    f7c8:	4602      	mov	r2, r0
    f7ca:	460b      	mov	r3, r1
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    f7cc:	d106      	bne.n	f7dc <z_impl_k_sleep+0x20>
		k_thread_suspend(_current);
    f7ce:	4b0b      	ldr	r3, [pc, #44]	; (f7fc <z_impl_k_sleep+0x40>)
    f7d0:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
    f7d2:	f7ff fe11 	bl	f3f8 <z_impl_k_thread_suspend>
		return (int32_t) K_TICKS_FOREVER;
    f7d6:	f04f 30ff 	mov.w	r0, #4294967295
	ticks = timeout.ticks;

	ticks = z_tick_sleep(ticks);
	sys_trace_end_call(SYS_TRACE_ID_SLEEP);
	return k_ticks_to_ms_floor64(ticks);
}
    f7da:	bd08      	pop	{r3, pc}
	if (ticks == 0) {
    f7dc:	4313      	orrs	r3, r2
    f7de:	d10a      	bne.n	f7f6 <z_impl_k_sleep+0x3a>
	z_impl_k_yield();
    f7e0:	f7ff ff9e 	bl	f720 <z_impl_k_yield>
		return 0;
    f7e4:	2000      	movs	r0, #0
		} else {
			return (t * to_hz + off) / from_hz;
    f7e6:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
    f7ea:	fb80 2303 	smull	r2, r3, r0, r3
    f7ee:	0bd0      	lsrs	r0, r2, #15
    f7f0:	ea40 4043 	orr.w	r0, r0, r3, lsl #17
	return k_ticks_to_ms_floor64(ticks);
    f7f4:	e7f1      	b.n	f7da <z_impl_k_sleep+0x1e>
    f7f6:	f7ff ff09 	bl	f60c <z_tick_sleep.part.0>
    f7fa:	e7f4      	b.n	f7e6 <z_impl_k_sleep+0x2a>
    f7fc:	20000908 	.word	0x20000908

0000f800 <z_impl_k_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
    f800:	4b01      	ldr	r3, [pc, #4]	; (f808 <z_impl_k_current_get+0x8>)
    f802:	6898      	ldr	r0, [r3, #8]
    f804:	4770      	bx	lr
    f806:	bf00      	nop
    f808:	20000908 	.word	0x20000908

0000f80c <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
    f80c:	b538      	push	{r3, r4, r5, lr}
    f80e:	4604      	mov	r4, r0
    f810:	f04f 0320 	mov.w	r3, #32
    f814:	f3ef 8511 	mrs	r5, BASEPRI
    f818:	f383 8811 	msr	BASEPRI, r3
    f81c:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	sys_trace_semaphore_give(sem);
	thread = z_unpend_first_thread(&sem->wait_q);
    f820:	f001 f920 	bl	10a64 <z_unpend_first_thread>

	if (thread != NULL) {
    f824:	b148      	cbz	r0, f83a <z_impl_k_sem_give+0x2e>
    f826:	2200      	movs	r2, #0
    f828:	67c2      	str	r2, [r0, #124]	; 0x7c
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
    f82a:	f001 f8c0 	bl	109ae <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
    f82e:	4629      	mov	r1, r5
	sys_trace_end_call(SYS_TRACE_ID_SEMA_GIVE);
}
    f830:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
    f834:	4804      	ldr	r0, [pc, #16]	; (f848 <z_impl_k_sem_give+0x3c>)
    f836:	f7ff bc8d 	b.w	f154 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
    f83a:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
    f83e:	429a      	cmp	r2, r3
    f840:	bf18      	it	ne
    f842:	3301      	addne	r3, #1
    f844:	60a3      	str	r3, [r4, #8]
		handle_poll_events(sem);
    f846:	e7f2      	b.n	f82e <z_impl_k_sem_give+0x22>
    f848:	20000967 	.word	0x20000967

0000f84c <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
    f84c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    f84e:	4614      	mov	r4, r2
    f850:	461d      	mov	r5, r3
    f852:	f04f 0320 	mov.w	r3, #32
    f856:	f3ef 8111 	mrs	r1, BASEPRI
    f85a:	f383 8811 	msr	BASEPRI, r3
    f85e:	f3bf 8f6f 	isb	sy
		  K_TIMEOUT_EQ(timeout, K_NO_WAIT)), "");

	k_spinlock_key_t key = k_spin_lock(&lock);
	sys_trace_semaphore_take(sem);

	if (likely(sem->count > 0U)) {
    f862:	6883      	ldr	r3, [r0, #8]
    f864:	b143      	cbz	r3, f878 <z_impl_k_sem_take+0x2c>
		sem->count--;
    f866:	3b01      	subs	r3, #1
    f868:	6083      	str	r3, [r0, #8]
	__asm__ volatile(
    f86a:	f381 8811 	msr	BASEPRI, r1
    f86e:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
    f872:	2000      	movs	r0, #0
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);

out:
	sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
	return ret;
}
    f874:	b003      	add	sp, #12
    f876:	bd30      	pop	{r4, r5, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
    f878:	ea54 0305 	orrs.w	r3, r4, r5
    f87c:	d106      	bne.n	f88c <z_impl_k_sem_take+0x40>
    f87e:	f381 8811 	msr	BASEPRI, r1
    f882:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
    f886:	f06f 000f 	mvn.w	r0, #15
    f88a:	e7f3      	b.n	f874 <z_impl_k_sem_take+0x28>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
    f88c:	4602      	mov	r2, r0
    f88e:	e9cd 4500 	strd	r4, r5, [sp]
    f892:	4802      	ldr	r0, [pc, #8]	; (f89c <z_impl_k_sem_take+0x50>)
    f894:	f7ff fea6 	bl	f5e4 <z_pend_curr>
	return ret;
    f898:	e7ec      	b.n	f874 <z_impl_k_sem_take+0x28>
    f89a:	bf00      	nop
    f89c:	20000967 	.word	0x20000967

0000f8a0 <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
    f8a0:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
	sys_dlist_init(&w->waitq);
    f8a4:	f100 0530 	add.w	r5, r0, #48	; 0x30
	list->tail = (sys_dnode_t *)list;
    f8a8:	e9c0 550c 	strd	r5, r5, [r0, #48]	; 0x30
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (uint8_t)options;
    f8ac:	9d0e      	ldr	r5, [sp, #56]	; 0x38
{
    f8ae:	4604      	mov	r4, r0
	thread_base->user_options = (uint8_t)options;
    f8b0:	7305      	strb	r5, [r0, #12]
	thread_base->thread_state = (uint8_t)initial_state;
    f8b2:	2504      	movs	r5, #4
    f8b4:	7345      	strb	r5, [r0, #13]

	thread_base->prio = priority;
    f8b6:	9d0d      	ldr	r5, [sp, #52]	; 0x34
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    f8b8:	1dd6      	adds	r6, r2, #7
	thread_base->prio = priority;
    f8ba:	7385      	strb	r5, [r0, #14]

	thread_base->sched_locked = 0U;
    f8bc:	2500      	movs	r5, #0
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    f8be:	9a0c      	ldr	r2, [sp, #48]	; 0x30
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
    f8c0:	f026 0607 	bic.w	r6, r6, #7
	node->prev = NULL;
    f8c4:	e9c0 5506 	strd	r5, r5, [r0, #24]
	new_thread->stack_info.size = stack_buf_size;
    f8c8:	e9c0 161a 	strd	r1, r6, [r0, #104]	; 0x68
	thread_base->sched_locked = 0U;
    f8cc:	73c5      	strb	r5, [r0, #15]
	new_thread->stack_info.delta = delta;
    f8ce:	6705      	str	r5, [r0, #112]	; 0x70
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    f8d0:	9202      	str	r2, [sp, #8]
    f8d2:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
	stack_ptr = (char *)stack + stack_obj_size;
    f8d4:	eb01 0806 	add.w	r8, r1, r6
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
    f8d8:	9201      	str	r2, [sp, #4]
    f8da:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    f8dc:	9200      	str	r2, [sp, #0]
    f8de:	4642      	mov	r2, r8
    f8e0:	f7fe f822 	bl	d928 <arch_new_thread>
	if (!_current) {
    f8e4:	4b05      	ldr	r3, [pc, #20]	; (f8fc <z_setup_new_thread+0x5c>)
	new_thread->fn_abort = NULL;
    f8e6:	e9c4 5517 	strd	r5, r5, [r4, #92]	; 0x5c
	if (!_current) {
    f8ea:	689b      	ldr	r3, [r3, #8]
    f8ec:	b103      	cbz	r3, f8f0 <z_setup_new_thread+0x50>
	new_thread->resource_pool = _current->resource_pool;
    f8ee:	6f5b      	ldr	r3, [r3, #116]	; 0x74
}
    f8f0:	4640      	mov	r0, r8
    f8f2:	6763      	str	r3, [r4, #116]	; 0x74
    f8f4:	b004      	add	sp, #16
    f8f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    f8fa:	bf00      	nop
    f8fc:	20000908 	.word	0x20000908

0000f900 <z_init_static_threads>:
{
    f900:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	_FOREACH_STATIC_THREAD(thread_data) {
    f904:	4e2a      	ldr	r6, [pc, #168]	; (f9b0 <z_init_static_threads+0xb0>)
    f906:	4d2b      	ldr	r5, [pc, #172]	; (f9b4 <z_init_static_threads+0xb4>)
    f908:	46b0      	mov	r8, r6
{
    f90a:	b086      	sub	sp, #24
	_FOREACH_STATIC_THREAD(thread_data) {
    f90c:	42b5      	cmp	r5, r6
    f90e:	f105 0430 	add.w	r4, r5, #48	; 0x30
    f912:	d310      	bcc.n	f936 <z_init_static_threads+0x36>
	k_sched_lock();
    f914:	f7ff fc30 	bl	f178 <k_sched_lock>
    f918:	f44f 4900 	mov.w	r9, #32768	; 0x8000
    f91c:	f240 36e7 	movw	r6, #999	; 0x3e7
    f920:	2700      	movs	r7, #0
	_FOREACH_STATIC_THREAD(thread_data) {
    f922:	4c24      	ldr	r4, [pc, #144]	; (f9b4 <z_init_static_threads+0xb4>)
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
    f924:	f8df a090 	ldr.w	sl, [pc, #144]	; f9b8 <z_init_static_threads+0xb8>
    f928:	4544      	cmp	r4, r8
    f92a:	d321      	bcc.n	f970 <z_init_static_threads+0x70>
}
    f92c:	b006      	add	sp, #24
    f92e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	k_sched_unlock();
    f932:	f7ff bc73 	b.w	f21c <k_sched_unlock>
		z_setup_new_thread(
    f936:	f854 3c04 	ldr.w	r3, [r4, #-4]
    f93a:	9305      	str	r3, [sp, #20]
    f93c:	f854 3c10 	ldr.w	r3, [r4, #-16]
    f940:	9304      	str	r3, [sp, #16]
    f942:	f854 3c14 	ldr.w	r3, [r4, #-20]
    f946:	9303      	str	r3, [sp, #12]
    f948:	f854 3c18 	ldr.w	r3, [r4, #-24]
    f94c:	9302      	str	r3, [sp, #8]
    f94e:	f854 3c1c 	ldr.w	r3, [r4, #-28]
    f952:	9301      	str	r3, [sp, #4]
    f954:	f854 3c20 	ldr.w	r3, [r4, #-32]
    f958:	9300      	str	r3, [sp, #0]
    f95a:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
    f95e:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
    f962:	f7ff ff9d 	bl	f8a0 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
    f966:	f854 3c30 	ldr.w	r3, [r4, #-48]
    f96a:	65dd      	str	r5, [r3, #92]	; 0x5c
    f96c:	4625      	mov	r5, r4
    f96e:	e7cd      	b.n	f90c <z_init_static_threads+0xc>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
    f970:	6a63      	ldr	r3, [r4, #36]	; 0x24
    f972:	1c5a      	adds	r2, r3, #1
    f974:	d00d      	beq.n	f992 <z_init_static_threads+0x92>
    f976:	4630      	mov	r0, r6
    f978:	4639      	mov	r1, r7
					    K_MSEC(thread_data->init_delay));
    f97a:	ea23 73e3 	bic.w	r3, r3, r3, asr #31
    f97e:	fbc9 0103 	smlal	r0, r1, r9, r3
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    f982:	42b9      	cmp	r1, r7
    f984:	bf08      	it	eq
    f986:	42b0      	cmpeq	r0, r6
			schedule_new_thread(thread_data->init_thread,
    f988:	6825      	ldr	r5, [r4, #0]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
    f98a:	d104      	bne.n	f996 <z_init_static_threads+0x96>
	z_sched_start(thread);
    f98c:	4628      	mov	r0, r5
    f98e:	f7ff fc99 	bl	f2c4 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
    f992:	3430      	adds	r4, #48	; 0x30
    f994:	e7c8      	b.n	f928 <z_init_static_threads+0x28>
    f996:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    f99a:	2300      	movs	r3, #0
    f99c:	f7fc fcda 	bl	c354 <__aeabi_uldivmod>
    f9a0:	4602      	mov	r2, r0
    f9a2:	460b      	mov	r3, r1
    f9a4:	f105 0018 	add.w	r0, r5, #24
    f9a8:	4651      	mov	r1, sl
    f9aa:	f000 f891 	bl	fad0 <z_add_timeout>
    f9ae:	e7f0      	b.n	f992 <z_init_static_threads+0x92>
    f9b0:	2000010c 	.word	0x2000010c
    f9b4:	2000010c 	.word	0x2000010c
    f9b8:	000109cf 	.word	0x000109cf

0000f9bc <z_self_abort>:
#include <syscall_handler.h>
#include <logging/log.h>
LOG_MODULE_DECLARE(os, CONFIG_KERNEL_LOG_LEVEL);

FUNC_NORETURN void z_self_abort(void)
{
    f9bc:	b508      	push	{r3, lr}
	__asm__ volatile(
    f9be:	f04f 0320 	mov.w	r3, #32
    f9c2:	f3ef 8411 	mrs	r4, BASEPRI
    f9c6:	f383 8811 	msr	BASEPRI, r3
    f9ca:	f3bf 8f6f 	isb	sy
	 * while we set this up
	 */
	key = arch_irq_lock();
	cpu = _current_cpu;
	__ASSERT(cpu->pending_abort == NULL, "already have a thread to abort");
	cpu->pending_abort = _current;
    f9ce:	4b04      	ldr	r3, [pc, #16]	; (f9e0 <z_self_abort+0x24>)
    f9d0:	6898      	ldr	r0, [r3, #8]
    f9d2:	6118      	str	r0, [r3, #16]
	z_impl_k_thread_suspend(thread);
    f9d4:	f7ff fd10 	bl	f3f8 <z_impl_k_thread_suspend>
    f9d8:	4620      	mov	r0, r4
    f9da:	f7fd ff1b 	bl	d814 <arch_swap>
		_current, cpu->idle_thread);

	k_thread_suspend(_current);
	z_swap_irqlock(key);
	__ASSERT(false, "should never get here");
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    f9de:	bf00      	nop
    f9e0:	20000908 	.word	0x20000908

0000f9e4 <boot_banner>:
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
    f9e4:	4a02      	ldr	r2, [pc, #8]	; (f9f0 <boot_banner+0xc>)
    f9e6:	4903      	ldr	r1, [pc, #12]	; (f9f4 <boot_banner+0x10>)
    f9e8:	4803      	ldr	r0, [pc, #12]	; (f9f8 <boot_banner+0x14>)
    f9ea:	f000 bb03 	b.w	fff4 <printk>
    f9ee:	bf00      	nop
    f9f0:	000110c1 	.word	0x000110c1
    f9f4:	0001108c 	.word	0x0001108c
    f9f8:	0001109b 	.word	0x0001109b

0000f9fc <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
    f9fc:	b508      	push	{r3, lr}
	(void)memcpy(&__data_ram_start, &__data_rom_start,
		 __data_ram_end - __data_ram_start);
    f9fe:	4806      	ldr	r0, [pc, #24]	; (fa18 <z_data_copy+0x1c>)
	(void)memcpy(&__data_ram_start, &__data_rom_start,
    fa00:	4a06      	ldr	r2, [pc, #24]	; (fa1c <z_data_copy+0x20>)
    fa02:	4907      	ldr	r1, [pc, #28]	; (fa20 <z_data_copy+0x24>)
    fa04:	1a12      	subs	r2, r2, r0
    fa06:	f000 fdf4 	bl	105f2 <memcpy>
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
    fa0a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)memcpy(&_ramfunc_ram_start, &_ramfunc_rom_start,
    fa0e:	4a05      	ldr	r2, [pc, #20]	; (fa24 <z_data_copy+0x28>)
    fa10:	4905      	ldr	r1, [pc, #20]	; (fa28 <z_data_copy+0x2c>)
    fa12:	4806      	ldr	r0, [pc, #24]	; (fa2c <z_data_copy+0x30>)
    fa14:	f000 bded 	b.w	105f2 <memcpy>
    fa18:	20000000 	.word	0x20000000
    fa1c:	2000015c 	.word	0x2000015c
    fa20:	000110c4 	.word	0x000110c4
    fa24:	00000000 	.word	0x00000000
    fa28:	000110c4 	.word	0x000110c4
    fa2c:	20000000 	.word	0x20000000

0000fa30 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0U;
    fa30:	4b03      	ldr	r3, [pc, #12]	; (fa40 <elapsed+0x10>)
    fa32:	681b      	ldr	r3, [r3, #0]
    fa34:	b90b      	cbnz	r3, fa3a <elapsed+0xa>
    fa36:	f7fd bdf7 	b.w	d628 <z_clock_elapsed>
}
    fa3a:	2000      	movs	r0, #0
    fa3c:	4770      	bx	lr
    fa3e:	bf00      	nop
    fa40:	20000948 	.word	0x20000948

0000fa44 <remove_timeout>:
{
    fa44:	b530      	push	{r4, r5, lr}
    fa46:	6803      	ldr	r3, [r0, #0]
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    fa48:	b168      	cbz	r0, fa66 <remove_timeout+0x22>
    fa4a:	4a0a      	ldr	r2, [pc, #40]	; (fa74 <remove_timeout+0x30>)
	return (node == list->tail) ? NULL : node->next;
    fa4c:	6852      	ldr	r2, [r2, #4]
    fa4e:	4290      	cmp	r0, r2
    fa50:	d009      	beq.n	fa66 <remove_timeout+0x22>
	if (next(t) != NULL) {
    fa52:	b143      	cbz	r3, fa66 <remove_timeout+0x22>
		next(t)->dticks += t->dticks;
    fa54:	e9d3 2104 	ldrd	r2, r1, [r3, #16]
    fa58:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
    fa5c:	1912      	adds	r2, r2, r4
    fa5e:	eb45 0101 	adc.w	r1, r5, r1
    fa62:	e9c3 2104 	strd	r2, r1, [r3, #16]
	node->prev->next = node->next;
    fa66:	6842      	ldr	r2, [r0, #4]
    fa68:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
    fa6a:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    fa6c:	2300      	movs	r3, #0
	node->prev = NULL;
    fa6e:	e9c0 3300 	strd	r3, r3, [r0]
}
    fa72:	bd30      	pop	{r4, r5, pc}
    fa74:	20000040 	.word	0x20000040

0000fa78 <next_timeout>:

static int32_t next_timeout(void)
{
    fa78:	b538      	push	{r3, r4, r5, lr}
	return list->head == list;
    fa7a:	4b13      	ldr	r3, [pc, #76]	; (fac8 <next_timeout+0x50>)
    fa7c:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    fa7e:	429c      	cmp	r4, r3
    fa80:	bf08      	it	eq
    fa82:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
    fa84:	f7ff ffd4 	bl	fa30 <elapsed>
    fa88:	4605      	mov	r5, r0
	int32_t ret = to == NULL ? MAX_WAIT
    fa8a:	b1bc      	cbz	r4, fabc <next_timeout+0x44>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    fa8c:	e9d4 0104 	ldrd	r0, r1, [r4, #16]
    fa90:	1b40      	subs	r0, r0, r5
    fa92:	eb61 71e5 	sbc.w	r1, r1, r5, asr #31
	int32_t ret = to == NULL ? MAX_WAIT
    fa96:	2801      	cmp	r0, #1
    fa98:	f171 0300 	sbcs.w	r3, r1, #0
    fa9c:	db11      	blt.n	fac2 <next_timeout+0x4a>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
    fa9e:	f06f 4200 	mvn.w	r2, #2147483648	; 0x80000000
    faa2:	2300      	movs	r3, #0
    faa4:	4282      	cmp	r2, r0
    faa6:	eb73 0401 	sbcs.w	r4, r3, r1
    faaa:	da00      	bge.n	faae <next_timeout+0x36>
    faac:	4610      	mov	r0, r2

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
    faae:	4b07      	ldr	r3, [pc, #28]	; (facc <next_timeout+0x54>)
    fab0:	695b      	ldr	r3, [r3, #20]
    fab2:	b113      	cbz	r3, faba <next_timeout+0x42>
    fab4:	4298      	cmp	r0, r3
    fab6:	bfa8      	it	ge
    fab8:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
    faba:	bd38      	pop	{r3, r4, r5, pc}
	int32_t ret = to == NULL ? MAX_WAIT
    fabc:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
    fac0:	e7f5      	b.n	faae <next_timeout+0x36>
    fac2:	2000      	movs	r0, #0
    fac4:	e7f3      	b.n	faae <next_timeout+0x36>
    fac6:	bf00      	nop
    fac8:	20000040 	.word	0x20000040
    facc:	20000908 	.word	0x20000908

0000fad0 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
    fad0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    fad4:	9101      	str	r1, [sp, #4]
    fad6:	4619      	mov	r1, r3
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    fad8:	1c4b      	adds	r3, r1, #1
    fada:	bf08      	it	eq
    fadc:	f1b2 3fff 	cmpeq.w	r2, #4294967295
{
    fae0:	4682      	mov	sl, r0
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
    fae2:	d070      	beq.n	fbc6 <z_add_timeout+0xf6>
	__ASSERT_NO_MSG(arch_mem_coherent(to));
#endif

	k_ticks_t ticks = timeout.ticks + 1;

	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(ticks) >= 0) {
    fae4:	f06f 0301 	mvn.w	r3, #1
    fae8:	f04f 3bff 	mov.w	fp, #4294967295
	k_ticks_t ticks = timeout.ticks + 1;
    faec:	1c54      	adds	r4, r2, #1
    faee:	f141 0500 	adc.w	r5, r1, #0
	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(ticks) >= 0) {
    faf2:	ebb3 0804 	subs.w	r8, r3, r4
    faf6:	eb6b 0905 	sbc.w	r9, fp, r5
    fafa:	f1b8 0f00 	cmp.w	r8, #0
    fafe:	f179 0300 	sbcs.w	r3, r9, #0
    fb02:	db0f      	blt.n	fb24 <z_add_timeout+0x54>
		ticks = Z_TICK_ABS(ticks) - (curr_tick + elapsed());
    fb04:	f7ff ff94 	bl	fa30 <elapsed>
    fb08:	f06f 0301 	mvn.w	r3, #1
    fb0c:	4a34      	ldr	r2, [pc, #208]	; (fbe0 <z_add_timeout+0x110>)
    fb0e:	e9d2 1c00 	ldrd	r1, ip, [r2]
    fb12:	1a5b      	subs	r3, r3, r1
    fb14:	eb6b 020c 	sbc.w	r2, fp, ip
    fb18:	1b1e      	subs	r6, r3, r4
    fb1a:	eb62 0705 	sbc.w	r7, r2, r5
    fb1e:	1a34      	subs	r4, r6, r0
    fb20:	eb67 75e0 	sbc.w	r5, r7, r0, asr #31
	}

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
    fb24:	9b01      	ldr	r3, [sp, #4]
    fb26:	f8ca 3008 	str.w	r3, [sl, #8]
    fb2a:	f04f 0320 	mov.w	r3, #32
    fb2e:	f3ef 8611 	mrs	r6, BASEPRI
    fb32:	f383 8811 	msr	BASEPRI, r3
    fb36:	f3bf 8f6f 	isb	sy
	ticks = MAX(1, ticks);

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
    fb3a:	f7ff ff79 	bl	fa30 <elapsed>
	ticks = MAX(1, ticks);
    fb3e:	2c01      	cmp	r4, #1
    fb40:	f175 0300 	sbcs.w	r3, r5, #0
    fb44:	bfbc      	itt	lt
    fb46:	2401      	movlt	r4, #1
    fb48:	2500      	movlt	r5, #0
	return list->head == list;
    fb4a:	4b26      	ldr	r3, [pc, #152]	; (fbe4 <z_add_timeout+0x114>)
		to->dticks = ticks + elapsed();
    fb4c:	1824      	adds	r4, r4, r0
    fb4e:	681a      	ldr	r2, [r3, #0]
    fb50:	eb45 75e0 	adc.w	r5, r5, r0, asr #31
	return sys_dlist_is_empty(list) ? NULL : list->head;
    fb54:	429a      	cmp	r2, r3
    fb56:	e9ca 4504 	strd	r4, r5, [sl, #16]
    fb5a:	d001      	beq.n	fb60 <z_add_timeout+0x90>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    fb5c:	685f      	ldr	r7, [r3, #4]
		for (t = first(); t != NULL; t = next(t)) {
    fb5e:	b952      	cbnz	r2, fb76 <z_add_timeout+0xa6>
	node->prev = list->tail;
    fb60:	685a      	ldr	r2, [r3, #4]
	node->next = list;
    fb62:	f8ca 3000 	str.w	r3, [sl]
	node->prev = list->tail;
    fb66:	f8ca 2004 	str.w	r2, [sl, #4]
	list->tail->next = node;
    fb6a:	685a      	ldr	r2, [r3, #4]
    fb6c:	f8c2 a000 	str.w	sl, [r2]
	list->tail = node;
    fb70:	f8c3 a004 	str.w	sl, [r3, #4]
}
    fb74:	e014      	b.n	fba0 <z_add_timeout+0xd0>
			if (t->dticks > to->dticks) {
    fb76:	e9d2 8904 	ldrd	r8, r9, [r2, #16]
    fb7a:	e9da 4504 	ldrd	r4, r5, [sl, #16]
    fb7e:	4544      	cmp	r4, r8
    fb80:	eb75 0109 	sbcs.w	r1, r5, r9
    fb84:	da22      	bge.n	fbcc <z_add_timeout+0xfc>
				t->dticks -= to->dticks;
    fb86:	ebb8 0004 	subs.w	r0, r8, r4
    fb8a:	eb69 0105 	sbc.w	r1, r9, r5
    fb8e:	e9c2 0104 	strd	r0, r1, [r2, #16]
	node->prev = successor->prev;
    fb92:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
    fb94:	e9ca 2100 	strd	r2, r1, [sl]
	successor->prev->next = node;
    fb98:	f8c1 a000 	str.w	sl, [r1]
	successor->prev = node;
    fb9c:	f8c2 a004 	str.w	sl, [r2, #4]
	return list->head == list;
    fba0:	681a      	ldr	r2, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    fba2:	429a      	cmp	r2, r3
    fba4:	d00b      	beq.n	fbbe <z_add_timeout+0xee>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
    fba6:	4592      	cmp	sl, r2
    fba8:	d109      	bne.n	fbbe <z_add_timeout+0xee>
			 * last announcement, and slice_ticks is based
			 * on that. It means the that time remaining for
			 * the next announcement can be lesser than
			 * slice_ticks.
			 */
			int32_t next_time = next_timeout();
    fbaa:	f7ff ff65 	bl	fa78 <next_timeout>

			if (next_time == 0 ||
    fbae:	b118      	cbz	r0, fbb8 <z_add_timeout+0xe8>
			    _current_cpu->slice_ticks != next_time) {
    fbb0:	4b0d      	ldr	r3, [pc, #52]	; (fbe8 <z_add_timeout+0x118>)
			if (next_time == 0 ||
    fbb2:	695b      	ldr	r3, [r3, #20]
    fbb4:	4283      	cmp	r3, r0
    fbb6:	d002      	beq.n	fbbe <z_add_timeout+0xee>
				z_clock_set_timeout(next_time, false);
    fbb8:	2100      	movs	r1, #0
    fbba:	f7fd fd03 	bl	d5c4 <z_clock_set_timeout>
	__asm__ volatile(
    fbbe:	f386 8811 	msr	BASEPRI, r6
    fbc2:	f3bf 8f6f 	isb	sy
#else
			z_clock_set_timeout(next_timeout(), false);
#endif	/* CONFIG_TIMESLICING */
		}
	}
}
    fbc6:	b003      	add	sp, #12
    fbc8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			to->dticks -= t->dticks;
    fbcc:	ebb4 0008 	subs.w	r0, r4, r8
    fbd0:	eb65 0109 	sbc.w	r1, r5, r9
	return (node == list->tail) ? NULL : node->next;
    fbd4:	42ba      	cmp	r2, r7
    fbd6:	e9ca 0104 	strd	r0, r1, [sl, #16]
    fbda:	d0c1      	beq.n	fb60 <z_add_timeout+0x90>
    fbdc:	6812      	ldr	r2, [r2, #0]
    fbde:	e7be      	b.n	fb5e <z_add_timeout+0x8e>
    fbe0:	20000260 	.word	0x20000260
    fbe4:	20000040 	.word	0x20000040
    fbe8:	20000908 	.word	0x20000908

0000fbec <z_clock_announce>:
		}
	}
}

void z_clock_announce(int32_t ticks)
{
    fbec:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    fbf0:	4606      	mov	r6, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
    fbf2:	f7ff fbbf 	bl	f374 <z_time_slice>
	__asm__ volatile(
    fbf6:	f04f 0320 	mov.w	r3, #32
    fbfa:	f3ef 8411 	mrs	r4, BASEPRI
    fbfe:	f383 8811 	msr	BASEPRI, r3
    fc02:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
    fc06:	f8df a0b0 	ldr.w	sl, [pc, #176]	; fcb8 <z_clock_announce+0xcc>
    fc0a:	4d2a      	ldr	r5, [pc, #168]	; (fcb4 <z_clock_announce+0xc8>)
    fc0c:	4651      	mov	r1, sl
	return list->head == list;
    fc0e:	f8df b0ac 	ldr.w	fp, [pc, #172]	; fcbc <z_clock_announce+0xd0>
    fc12:	602e      	str	r6, [r5, #0]
    fc14:	f8d5 c000 	ldr.w	ip, [r5]
    fc18:	f8db 0000 	ldr.w	r0, [fp]
    fc1c:	4662      	mov	r2, ip
    fc1e:	e9da 8900 	ldrd	r8, r9, [sl]
    fc22:	17d3      	asrs	r3, r2, #31
	return sys_dlist_is_empty(list) ? NULL : list->head;
    fc24:	4558      	cmp	r0, fp
    fc26:	e9cd 2300 	strd	r2, r3, [sp]
    fc2a:	d00d      	beq.n	fc48 <z_clock_announce+0x5c>

	while (first() != NULL && first()->dticks <= announce_remaining) {
    fc2c:	b160      	cbz	r0, fc48 <z_clock_announce+0x5c>
    fc2e:	e9d0 6704 	ldrd	r6, r7, [r0, #16]
    fc32:	45b4      	cmp	ip, r6
    fc34:	41bb      	sbcs	r3, r7
    fc36:	da1d      	bge.n	fc74 <z_clock_announce+0x88>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
    fc38:	9b00      	ldr	r3, [sp, #0]
    fc3a:	ebb6 0c03 	subs.w	ip, r6, r3
    fc3e:	9b01      	ldr	r3, [sp, #4]
    fc40:	eb67 0603 	sbc.w	r6, r7, r3
    fc44:	e9c0 c604 	strd	ip, r6, [r0, #16]
	}

	curr_tick += announce_remaining;
	announce_remaining = 0;
    fc48:	2600      	movs	r6, #0
	curr_tick += announce_remaining;
    fc4a:	9b00      	ldr	r3, [sp, #0]
	announce_remaining = 0;
    fc4c:	602e      	str	r6, [r5, #0]
	curr_tick += announce_remaining;
    fc4e:	eb13 0208 	adds.w	r2, r3, r8
    fc52:	9b01      	ldr	r3, [sp, #4]
    fc54:	eb43 0309 	adc.w	r3, r3, r9
    fc58:	e9c1 2300 	strd	r2, r3, [r1]

	z_clock_set_timeout(next_timeout(), false);
    fc5c:	f7ff ff0c 	bl	fa78 <next_timeout>
    fc60:	4631      	mov	r1, r6
    fc62:	f7fd fcaf 	bl	d5c4 <z_clock_set_timeout>
	__asm__ volatile(
    fc66:	f384 8811 	msr	BASEPRI, r4
    fc6a:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
    fc6e:	b003      	add	sp, #12
    fc70:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		t->dticks = 0;
    fc74:	2200      	movs	r2, #0
    fc76:	2300      	movs	r3, #0
		curr_tick += dt;
    fc78:	eb18 0806 	adds.w	r8, r8, r6
    fc7c:	eb49 79e6 	adc.w	r9, r9, r6, asr #31
		t->dticks = 0;
    fc80:	e9c0 2304 	strd	r2, r3, [r0, #16]
		announce_remaining -= dt;
    fc84:	ebac 0606 	sub.w	r6, ip, r6
		curr_tick += dt;
    fc88:	e9ca 8900 	strd	r8, r9, [sl]
		announce_remaining -= dt;
    fc8c:	602e      	str	r6, [r5, #0]
		remove_timeout(t);
    fc8e:	f7ff fed9 	bl	fa44 <remove_timeout>
    fc92:	f384 8811 	msr	BASEPRI, r4
    fc96:	f3bf 8f6f 	isb	sy
		t->fn(t);
    fc9a:	6883      	ldr	r3, [r0, #8]
    fc9c:	4798      	blx	r3
	__asm__ volatile(
    fc9e:	f04f 0320 	mov.w	r3, #32
    fca2:	f3ef 8411 	mrs	r4, BASEPRI
    fca6:	f383 8811 	msr	BASEPRI, r3
    fcaa:	f3bf 8f6f 	isb	sy

	/* Note that we need to use the underlying arch-specific lock
	 * implementation.  The "irq_lock()" API in SMP context is
	 * actually a wrapper for a global spinlock!
	 */
	k.key = arch_irq_lock();
    fcae:	4902      	ldr	r1, [pc, #8]	; (fcb8 <z_clock_announce+0xcc>)
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
    fcb0:	e7b0      	b.n	fc14 <z_clock_announce+0x28>
    fcb2:	bf00      	nop
    fcb4:	20000948 	.word	0x20000948
    fcb8:	20000260 	.word	0x20000260
    fcbc:	20000040 	.word	0x20000040

0000fcc0 <z_tick_get>:

int64_t z_tick_get(void)
{
    fcc0:	b510      	push	{r4, lr}
    fcc2:	f04f 0320 	mov.w	r3, #32
    fcc6:	f3ef 8411 	mrs	r4, BASEPRI
    fcca:	f383 8811 	msr	BASEPRI, r3
    fcce:	f3bf 8f6f 	isb	sy
	uint64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + z_clock_elapsed();
    fcd2:	f7fd fca9 	bl	d628 <z_clock_elapsed>
    fcd6:	4b06      	ldr	r3, [pc, #24]	; (fcf0 <z_tick_get+0x30>)
    fcd8:	e9d3 2300 	ldrd	r2, r3, [r3]
    fcdc:	1812      	adds	r2, r2, r0
    fcde:	f143 0300 	adc.w	r3, r3, #0
	__asm__ volatile(
    fce2:	f384 8811 	msr	BASEPRI, r4
    fce6:	f3bf 8f6f 	isb	sy
	}
	return t;
}
    fcea:	4610      	mov	r0, r2
    fcec:	4619      	mov	r1, r3
    fcee:	bd10      	pop	{r4, pc}
    fcf0:	20000260 	.word	0x20000260

0000fcf4 <statics_init>:
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
}

static int statics_init(const struct device *unused)
{
    fcf4:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
    fcf6:	4c06      	ldr	r4, [pc, #24]	; (fd10 <statics_init+0x1c>)
    fcf8:	4d06      	ldr	r5, [pc, #24]	; (fd14 <statics_init+0x20>)
    fcfa:	42ac      	cmp	r4, r5
    fcfc:	d301      	bcc.n	fd02 <statics_init+0xe>
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
	}
	return 0;
}
    fcfe:	2000      	movs	r0, #0
    fd00:	bd38      	pop	{r3, r4, r5, pc}
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
    fd02:	4620      	mov	r0, r4
    fd04:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
    fd08:	f000 ff1f 	bl	10b4a <k_heap_init>
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
    fd0c:	3414      	adds	r4, #20
    fd0e:	e7f4      	b.n	fcfa <statics_init+0x6>
    fd10:	2000010c 	.word	0x2000010c
    fd14:	2000010c 	.word	0x2000010c

0000fd18 <nrf_cc3xx_platform_init_no_rng>:
    fd18:	b510      	push	{r4, lr}
    fd1a:	4c0a      	ldr	r4, [pc, #40]	; (fd44 <nrf_cc3xx_platform_init_no_rng+0x2c>)
    fd1c:	6823      	ldr	r3, [r4, #0]
    fd1e:	b11b      	cbz	r3, fd28 <nrf_cc3xx_platform_init_no_rng+0x10>
    fd20:	2301      	movs	r3, #1
    fd22:	2000      	movs	r0, #0
    fd24:	6023      	str	r3, [r4, #0]
    fd26:	bd10      	pop	{r4, pc}
    fd28:	f000 f8b2 	bl	fe90 <CC_LibInitNoRng>
    fd2c:	2800      	cmp	r0, #0
    fd2e:	d0f7      	beq.n	fd20 <nrf_cc3xx_platform_init_no_rng+0x8>
    fd30:	3801      	subs	r0, #1
    fd32:	2807      	cmp	r0, #7
    fd34:	d803      	bhi.n	fd3e <nrf_cc3xx_platform_init_no_rng+0x26>
    fd36:	4b04      	ldr	r3, [pc, #16]	; (fd48 <nrf_cc3xx_platform_init_no_rng+0x30>)
    fd38:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
    fd3c:	bd10      	pop	{r4, pc}
    fd3e:	4803      	ldr	r0, [pc, #12]	; (fd4c <nrf_cc3xx_platform_init_no_rng+0x34>)
    fd40:	bd10      	pop	{r4, pc}
    fd42:	bf00      	nop
    fd44:	2000094c 	.word	0x2000094c
    fd48:	00010f08 	.word	0x00010f08
    fd4c:	ffff8ffe 	.word	0xffff8ffe

0000fd50 <nrf_cc3xx_platform_abort>:
    fd50:	f3bf 8f4f 	dsb	sy
    fd54:	4905      	ldr	r1, [pc, #20]	; (fd6c <nrf_cc3xx_platform_abort+0x1c>)
    fd56:	4b06      	ldr	r3, [pc, #24]	; (fd70 <nrf_cc3xx_platform_abort+0x20>)
    fd58:	68ca      	ldr	r2, [r1, #12]
    fd5a:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    fd5e:	4313      	orrs	r3, r2
    fd60:	60cb      	str	r3, [r1, #12]
    fd62:	f3bf 8f4f 	dsb	sy
    fd66:	bf00      	nop
    fd68:	e7fd      	b.n	fd66 <nrf_cc3xx_platform_abort+0x16>
    fd6a:	bf00      	nop
    fd6c:	e000ed00 	.word	0xe000ed00
    fd70:	05fa0004 	.word	0x05fa0004

0000fd74 <CC_PalAbort>:
    fd74:	f04f 33fe 	mov.w	r3, #4278124286	; 0xfefefefe
    fd78:	2100      	movs	r1, #0
    fd7a:	b430      	push	{r4, r5}
    fd7c:	4a08      	ldr	r2, [pc, #32]	; (fda0 <CC_PalAbort+0x2c>)
    fd7e:	4c09      	ldr	r4, [pc, #36]	; (fda4 <CC_PalAbort+0x30>)
    fd80:	4d09      	ldr	r5, [pc, #36]	; (fda8 <CC_PalAbort+0x34>)
    fd82:	6023      	str	r3, [r4, #0]
    fd84:	602b      	str	r3, [r5, #0]
    fd86:	6013      	str	r3, [r2, #0]
    fd88:	60e3      	str	r3, [r4, #12]
    fd8a:	60eb      	str	r3, [r5, #12]
    fd8c:	60d3      	str	r3, [r2, #12]
    fd8e:	61a3      	str	r3, [r4, #24]
    fd90:	4a06      	ldr	r2, [pc, #24]	; (fdac <CC_PalAbort+0x38>)
    fd92:	4c07      	ldr	r4, [pc, #28]	; (fdb0 <CC_PalAbort+0x3c>)
    fd94:	61ab      	str	r3, [r5, #24]
    fd96:	6863      	ldr	r3, [r4, #4]
    fd98:	f8c2 1500 	str.w	r1, [r2, #1280]	; 0x500
    fd9c:	bc30      	pop	{r4, r5}
    fd9e:	4718      	bx	r3
    fda0:	50845408 	.word	0x50845408
    fda4:	50845400 	.word	0x50845400
    fda8:	50845404 	.word	0x50845404
    fdac:	50844000 	.word	0x50844000
    fdb0:	20000048 	.word	0x20000048

0000fdb4 <nrf_cc3xx_platform_set_abort>:
    fdb4:	4b02      	ldr	r3, [pc, #8]	; (fdc0 <nrf_cc3xx_platform_set_abort+0xc>)
    fdb6:	e9d0 1200 	ldrd	r1, r2, [r0]
    fdba:	e9c3 1200 	strd	r1, r2, [r3]
    fdbe:	4770      	bx	lr
    fdc0:	20000048 	.word	0x20000048

0000fdc4 <mutex_unlock>:
    fdc4:	b148      	cbz	r0, fdda <mutex_unlock+0x16>
    fdc6:	6843      	ldr	r3, [r0, #4]
    fdc8:	b12b      	cbz	r3, fdd6 <mutex_unlock+0x12>
    fdca:	f3bf 8f5f 	dmb	sy
    fdce:	2300      	movs	r3, #0
    fdd0:	6003      	str	r3, [r0, #0]
    fdd2:	4618      	mov	r0, r3
    fdd4:	4770      	bx	lr
    fdd6:	4802      	ldr	r0, [pc, #8]	; (fde0 <mutex_unlock+0x1c>)
    fdd8:	4770      	bx	lr
    fdda:	f46f 40e0 	mvn.w	r0, #28672	; 0x7000
    fdde:	4770      	bx	lr
    fde0:	ffff8fea 	.word	0xffff8fea

0000fde4 <mutex_free>:
    fde4:	b510      	push	{r4, lr}
    fde6:	4604      	mov	r4, r0
    fde8:	b128      	cbz	r0, fdf6 <mutex_free+0x12>
    fdea:	6863      	ldr	r3, [r4, #4]
    fdec:	b113      	cbz	r3, fdf4 <mutex_free+0x10>
    fdee:	2300      	movs	r3, #0
    fdf0:	6023      	str	r3, [r4, #0]
    fdf2:	6063      	str	r3, [r4, #4]
    fdf4:	bd10      	pop	{r4, pc}
    fdf6:	4b02      	ldr	r3, [pc, #8]	; (fe00 <mutex_free+0x1c>)
    fdf8:	4802      	ldr	r0, [pc, #8]	; (fe04 <mutex_free+0x20>)
    fdfa:	685b      	ldr	r3, [r3, #4]
    fdfc:	4798      	blx	r3
    fdfe:	e7f4      	b.n	fdea <mutex_free+0x6>
    fe00:	20000048 	.word	0x20000048
    fe04:	00010f28 	.word	0x00010f28

0000fe08 <mutex_init>:
    fe08:	b510      	push	{r4, lr}
    fe0a:	4604      	mov	r4, r0
    fe0c:	b130      	cbz	r0, fe1c <mutex_init+0x14>
    fe0e:	2200      	movs	r2, #0
    fe10:	6863      	ldr	r3, [r4, #4]
    fe12:	6022      	str	r2, [r4, #0]
    fe14:	f043 0301 	orr.w	r3, r3, #1
    fe18:	6063      	str	r3, [r4, #4]
    fe1a:	bd10      	pop	{r4, pc}
    fe1c:	4801      	ldr	r0, [pc, #4]	; (fe24 <mutex_init+0x1c>)
    fe1e:	f7ff ffa9 	bl	fd74 <CC_PalAbort>
    fe22:	e7f4      	b.n	fe0e <mutex_init+0x6>
    fe24:	00010f50 	.word	0x00010f50

0000fe28 <mutex_lock>:
    fe28:	b180      	cbz	r0, fe4c <mutex_lock+0x24>
    fe2a:	6843      	ldr	r3, [r0, #4]
    fe2c:	b163      	cbz	r3, fe48 <mutex_lock+0x20>
    fe2e:	2201      	movs	r2, #1
    fe30:	e8d0 3fef 	ldaex	r3, [r0]
    fe34:	e8c0 2fe1 	stlex	r1, r2, [r0]
    fe38:	2900      	cmp	r1, #0
    fe3a:	d1f9      	bne.n	fe30 <mutex_lock+0x8>
    fe3c:	2b01      	cmp	r3, #1
    fe3e:	d0f7      	beq.n	fe30 <mutex_lock+0x8>
    fe40:	f3bf 8f5f 	dmb	sy
    fe44:	2000      	movs	r0, #0
    fe46:	4770      	bx	lr
    fe48:	4802      	ldr	r0, [pc, #8]	; (fe54 <mutex_lock+0x2c>)
    fe4a:	4770      	bx	lr
    fe4c:	f46f 40e0 	mvn.w	r0, #28672	; 0x7000
    fe50:	4770      	bx	lr
    fe52:	bf00      	nop
    fe54:	ffff8fea 	.word	0xffff8fea

0000fe58 <nrf_cc3xx_platform_set_mutexes>:
    fe58:	b470      	push	{r4, r5, r6}
    fe5a:	4b0b      	ldr	r3, [pc, #44]	; (fe88 <nrf_cc3xx_platform_set_mutexes+0x30>)
    fe5c:	6806      	ldr	r6, [r0, #0]
    fe5e:	68c2      	ldr	r2, [r0, #12]
    fe60:	e9d0 5401 	ldrd	r5, r4, [r0, #4]
    fe64:	e9c3 4202 	strd	r4, r2, [r3, #8]
    fe68:	e9c3 6500 	strd	r6, r5, [r3]
    fe6c:	e9d1 0203 	ldrd	r0, r2, [r1, #12]
    fe70:	680e      	ldr	r6, [r1, #0]
    fe72:	4b06      	ldr	r3, [pc, #24]	; (fe8c <nrf_cc3xx_platform_set_mutexes+0x34>)
    fe74:	e9d1 5401 	ldrd	r5, r4, [r1, #4]
    fe78:	e9c3 6500 	strd	r6, r5, [r3]
    fe7c:	e9c3 4002 	strd	r4, r0, [r3, #8]
    fe80:	611a      	str	r2, [r3, #16]
    fe82:	bc70      	pop	{r4, r5, r6}
    fe84:	4770      	bx	lr
    fe86:	bf00      	nop
    fe88:	20000058 	.word	0x20000058
    fe8c:	20000068 	.word	0x20000068

0000fe90 <CC_LibInitNoRng>:
    fe90:	b508      	push	{r3, lr}
    fe92:	f000 f80f 	bl	feb4 <CC_HalInit>
    fe96:	b928      	cbnz	r0, fea4 <CC_LibInitNoRng+0x14>
    fe98:	f000 f80e 	bl	feb8 <CC_PalInit>
    fe9c:	b930      	cbnz	r0, feac <CC_LibInitNoRng+0x1c>
    fe9e:	4a04      	ldr	r2, [pc, #16]	; (feb0 <CC_LibInitNoRng+0x20>)
    fea0:	6010      	str	r0, [r2, #0]
    fea2:	bd08      	pop	{r3, pc}
    fea4:	f000 f836 	bl	ff14 <CC_PalTerminate>
    fea8:	2003      	movs	r0, #3
    feaa:	bd08      	pop	{r3, pc}
    feac:	2004      	movs	r0, #4
    feae:	bd08      	pop	{r3, pc}
    feb0:	50845a0c 	.word	0x50845a0c

0000feb4 <CC_HalInit>:
    feb4:	2000      	movs	r0, #0
    feb6:	4770      	bx	lr

0000feb8 <CC_PalInit>:
    feb8:	b510      	push	{r4, lr}
    feba:	4811      	ldr	r0, [pc, #68]	; (ff00 <CC_PalInit+0x48>)
    febc:	f000 f848 	bl	ff50 <CC_PalMutexCreate>
    fec0:	b100      	cbz	r0, fec4 <CC_PalInit+0xc>
    fec2:	bd10      	pop	{r4, pc}
    fec4:	480f      	ldr	r0, [pc, #60]	; (ff04 <CC_PalInit+0x4c>)
    fec6:	f000 f843 	bl	ff50 <CC_PalMutexCreate>
    feca:	2800      	cmp	r0, #0
    fecc:	d1f9      	bne.n	fec2 <CC_PalInit+0xa>
    fece:	4c0e      	ldr	r4, [pc, #56]	; (ff08 <CC_PalInit+0x50>)
    fed0:	4620      	mov	r0, r4
    fed2:	f000 f83d 	bl	ff50 <CC_PalMutexCreate>
    fed6:	2800      	cmp	r0, #0
    fed8:	d1f3      	bne.n	fec2 <CC_PalInit+0xa>
    feda:	4b0c      	ldr	r3, [pc, #48]	; (ff0c <CC_PalInit+0x54>)
    fedc:	480c      	ldr	r0, [pc, #48]	; (ff10 <CC_PalInit+0x58>)
    fede:	601c      	str	r4, [r3, #0]
    fee0:	f000 f836 	bl	ff50 <CC_PalMutexCreate>
    fee4:	4601      	mov	r1, r0
    fee6:	2800      	cmp	r0, #0
    fee8:	d1eb      	bne.n	fec2 <CC_PalInit+0xa>
    feea:	f000 f82d 	bl	ff48 <CC_PalDmaInit>
    feee:	4604      	mov	r4, r0
    fef0:	b108      	cbz	r0, fef6 <CC_PalInit+0x3e>
    fef2:	4620      	mov	r0, r4
    fef4:	bd10      	pop	{r4, pc}
    fef6:	f000 f83f 	bl	ff78 <CC_PalPowerSaveModeInit>
    fefa:	4620      	mov	r0, r4
    fefc:	e7fa      	b.n	fef4 <CC_PalInit+0x3c>
    fefe:	bf00      	nop
    ff00:	200000a0 	.word	0x200000a0
    ff04:	20000094 	.word	0x20000094
    ff08:	2000009c 	.word	0x2000009c
    ff0c:	200000a4 	.word	0x200000a4
    ff10:	20000098 	.word	0x20000098

0000ff14 <CC_PalTerminate>:
    ff14:	b508      	push	{r3, lr}
    ff16:	4808      	ldr	r0, [pc, #32]	; (ff38 <CC_PalTerminate+0x24>)
    ff18:	f000 f824 	bl	ff64 <CC_PalMutexDestroy>
    ff1c:	4807      	ldr	r0, [pc, #28]	; (ff3c <CC_PalTerminate+0x28>)
    ff1e:	f000 f821 	bl	ff64 <CC_PalMutexDestroy>
    ff22:	4807      	ldr	r0, [pc, #28]	; (ff40 <CC_PalTerminate+0x2c>)
    ff24:	f000 f81e 	bl	ff64 <CC_PalMutexDestroy>
    ff28:	4806      	ldr	r0, [pc, #24]	; (ff44 <CC_PalTerminate+0x30>)
    ff2a:	f000 f81b 	bl	ff64 <CC_PalMutexDestroy>
    ff2e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    ff32:	f000 b80b 	b.w	ff4c <CC_PalDmaTerminate>
    ff36:	bf00      	nop
    ff38:	200000a0 	.word	0x200000a0
    ff3c:	20000094 	.word	0x20000094
    ff40:	2000009c 	.word	0x2000009c
    ff44:	20000098 	.word	0x20000098

0000ff48 <CC_PalDmaInit>:
    ff48:	2000      	movs	r0, #0
    ff4a:	4770      	bx	lr

0000ff4c <CC_PalDmaTerminate>:
    ff4c:	4770      	bx	lr
    ff4e:	bf00      	nop

0000ff50 <CC_PalMutexCreate>:
    ff50:	b508      	push	{r3, lr}
    ff52:	4b03      	ldr	r3, [pc, #12]	; (ff60 <CC_PalMutexCreate+0x10>)
    ff54:	6802      	ldr	r2, [r0, #0]
    ff56:	681b      	ldr	r3, [r3, #0]
    ff58:	6810      	ldr	r0, [r2, #0]
    ff5a:	4798      	blx	r3
    ff5c:	2000      	movs	r0, #0
    ff5e:	bd08      	pop	{r3, pc}
    ff60:	20000058 	.word	0x20000058

0000ff64 <CC_PalMutexDestroy>:
    ff64:	b508      	push	{r3, lr}
    ff66:	4b03      	ldr	r3, [pc, #12]	; (ff74 <CC_PalMutexDestroy+0x10>)
    ff68:	6802      	ldr	r2, [r0, #0]
    ff6a:	685b      	ldr	r3, [r3, #4]
    ff6c:	6810      	ldr	r0, [r2, #0]
    ff6e:	4798      	blx	r3
    ff70:	2000      	movs	r0, #0
    ff72:	bd08      	pop	{r3, pc}
    ff74:	20000058 	.word	0x20000058

0000ff78 <CC_PalPowerSaveModeInit>:
    ff78:	b570      	push	{r4, r5, r6, lr}
    ff7a:	4c09      	ldr	r4, [pc, #36]	; (ffa0 <CC_PalPowerSaveModeInit+0x28>)
    ff7c:	4d09      	ldr	r5, [pc, #36]	; (ffa4 <CC_PalPowerSaveModeInit+0x2c>)
    ff7e:	6920      	ldr	r0, [r4, #16]
    ff80:	68ab      	ldr	r3, [r5, #8]
    ff82:	4798      	blx	r3
    ff84:	b118      	cbz	r0, ff8e <CC_PalPowerSaveModeInit+0x16>
    ff86:	4b08      	ldr	r3, [pc, #32]	; (ffa8 <CC_PalPowerSaveModeInit+0x30>)
    ff88:	4808      	ldr	r0, [pc, #32]	; (ffac <CC_PalPowerSaveModeInit+0x34>)
    ff8a:	685b      	ldr	r3, [r3, #4]
    ff8c:	4798      	blx	r3
    ff8e:	2100      	movs	r1, #0
    ff90:	4a07      	ldr	r2, [pc, #28]	; (ffb0 <CC_PalPowerSaveModeInit+0x38>)
    ff92:	68eb      	ldr	r3, [r5, #12]
    ff94:	6011      	str	r1, [r2, #0]
    ff96:	6920      	ldr	r0, [r4, #16]
    ff98:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    ff9c:	4718      	bx	r3
    ff9e:	bf00      	nop
    ffa0:	20000068 	.word	0x20000068
    ffa4:	20000058 	.word	0x20000058
    ffa8:	20000048 	.word	0x20000048
    ffac:	00010f74 	.word	0x00010f74
    ffb0:	20000960 	.word	0x20000960

0000ffb4 <sys_notify_validate>:

int sys_notify_validate(struct sys_notify *notify)
{
	int rv = 0;

	if (notify == NULL) {
    ffb4:	4603      	mov	r3, r0
    ffb6:	b158      	cbz	r0, ffd0 <sys_notify_validate+0x1c>
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
    ffb8:	6842      	ldr	r2, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
    ffba:	f002 0203 	and.w	r2, r2, #3
		return -EINVAL;
	}

	/* Validate configuration based on mode */
	switch (sys_notify_get_method(notify)) {
    ffbe:	2a01      	cmp	r2, #1
    ffc0:	d003      	beq.n	ffca <sys_notify_validate+0x16>
    ffc2:	2a03      	cmp	r2, #3
    ffc4:	d104      	bne.n	ffd0 <sys_notify_validate+0x1c>
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		if (notify->method.callback == NULL) {
    ffc6:	6802      	ldr	r2, [r0, #0]
    ffc8:	b112      	cbz	r2, ffd0 <sys_notify_validate+0x1c>
		break;
	}

	/* Clear the result here instead of in all callers. */
	if (rv == 0) {
		notify->result = 0;
    ffca:	2000      	movs	r0, #0
    ffcc:	6098      	str	r0, [r3, #8]
    ffce:	4770      	bx	lr
		return -EINVAL;
    ffd0:	f06f 0015 	mvn.w	r0, #21
	}

	return rv;
}
    ffd4:	4770      	bx	lr

0000ffd6 <sys_notify_finalize>:
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
    ffd6:	6842      	ldr	r2, [r0, #4]

sys_notify_generic_callback sys_notify_finalize(struct sys_notify *notify,
						    int res)
{
    ffd8:	4603      	mov	r3, r0
	return method & SYS_NOTIFY_METHOD_MASK;
    ffda:	f002 0203 	and.w	r2, r2, #3

	/* Store the result and capture secondary notification
	 * information.
	 */
	notify->result = res;
	switch (method) {
    ffde:	2a03      	cmp	r2, #3
    ffe0:	f04f 0200 	mov.w	r2, #0
	notify->result = res;
    ffe4:	6081      	str	r1, [r0, #8]
	sys_notify_generic_callback rv = 0;
    ffe6:	bf14      	ite	ne
    ffe8:	4610      	movne	r0, r2
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		rv = notify->method.callback;
    ffea:	6800      	ldreq	r0, [r0, #0]
	/* Mark completion by clearing the flags field to the
	 * completed state, releasing any spin-waiters, then complete
	 * secondary notification.
	 */
	compiler_barrier();
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
    ffec:	605a      	str	r2, [r3, #4]
	if (IS_ENABLED(CONFIG_POLL) && (sig != NULL)) {
		k_poll_signal_raise(sig, res);
	}

	return rv;
}
    ffee:	4770      	bx	lr

0000fff0 <arch_printk_char_out>:
}
    fff0:	2000      	movs	r0, #0
    fff2:	4770      	bx	lr

0000fff4 <printk>:
 * @param fmt formatted string to output
 *
 * @return N/A
 */
void printk(const char *fmt, ...)
{
    fff4:	b40f      	push	{r0, r1, r2, r3}
    fff6:	b507      	push	{r0, r1, r2, lr}
    fff8:	a904      	add	r1, sp, #16
    fffa:	f851 0b04 	ldr.w	r0, [r1], #4
	va_list ap;

	va_start(ap, fmt);
    fffe:	9101      	str	r1, [sp, #4]

	if (IS_ENABLED(CONFIG_LOG_PRINTK)) {
		log_printk(fmt, ap);
	} else {
		vprintk(fmt, ap);
   10000:	f7fc fb3c 	bl	c67c <vprintk>
	}
	va_end(ap);
}
   10004:	b003      	add	sp, #12
   10006:	f85d eb04 	ldr.w	lr, [sp], #4
   1000a:	b004      	add	sp, #16
   1000c:	4770      	bx	lr

0001000e <process_recheck>:
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   1000e:	8b03      	ldrh	r3, [r0, #24]
	if ((state == ONOFF_STATE_OFF)
   10010:	f013 0307 	ands.w	r3, r3, #7
   10014:	d105      	bne.n	10022 <process_recheck+0x14>
	    && !sys_slist_is_empty(&mgr->clients)) {
   10016:	6803      	ldr	r3, [r0, #0]
   10018:	2b00      	cmp	r3, #0
		evt = EVT_START;
   1001a:	bf0c      	ite	eq
   1001c:	2000      	moveq	r0, #0
   1001e:	2003      	movne	r0, #3
   10020:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ON)
   10022:	2b02      	cmp	r3, #2
   10024:	d105      	bne.n	10032 <process_recheck+0x24>
		   && (mgr->refs == 0U)) {
   10026:	8b43      	ldrh	r3, [r0, #26]
   10028:	2b00      	cmp	r3, #0
		evt = EVT_STOP;
   1002a:	bf14      	ite	ne
   1002c:	2000      	movne	r0, #0
   1002e:	2004      	moveq	r0, #4
   10030:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ERROR)
   10032:	2b01      	cmp	r3, #1
   10034:	d105      	bne.n	10042 <process_recheck+0x34>
		   && !sys_slist_is_empty(&mgr->clients)) {
   10036:	6803      	ldr	r3, [r0, #0]
   10038:	2b00      	cmp	r3, #0
		evt = EVT_RESET;
   1003a:	bf0c      	ite	eq
   1003c:	2000      	moveq	r0, #0
   1003e:	2005      	movne	r0, #5
   10040:	4770      	bx	lr
	int evt = EVT_NOP;
   10042:	2000      	movs	r0, #0
}
   10044:	4770      	bx	lr

00010046 <notify_one>:
{
   10046:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   1004a:	460d      	mov	r5, r1
   1004c:	4607      	mov	r7, r0
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
   1004e:	4619      	mov	r1, r3
   10050:	1d28      	adds	r0, r5, #4
{
   10052:	4690      	mov	r8, r2
   10054:	461e      	mov	r6, r3
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
   10056:	f7ff ffbe 	bl	ffd6 <sys_notify_finalize>
	if (cb) {
   1005a:	4604      	mov	r4, r0
   1005c:	b138      	cbz	r0, 1006e <notify_one+0x28>
		cb(mgr, cli, state, res);
   1005e:	4633      	mov	r3, r6
   10060:	4642      	mov	r2, r8
   10062:	4629      	mov	r1, r5
   10064:	4638      	mov	r0, r7
   10066:	46a4      	mov	ip, r4
}
   10068:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		cb(mgr, cli, state, res);
   1006c:	4760      	bx	ip
}
   1006e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00010072 <transition_complete>:
{
   10072:	b410      	push	{r4}
	__asm__ volatile(
   10074:	f04f 0420 	mov.w	r4, #32
   10078:	f3ef 8211 	mrs	r2, BASEPRI
   1007c:	f384 8811 	msr	BASEPRI, r4
   10080:	f3bf 8f6f 	isb	sy
	mgr->last_res = res;
   10084:	6141      	str	r1, [r0, #20]
}
   10086:	bc10      	pop	{r4}
	process_event(mgr, EVT_COMPLETE, key);
   10088:	2101      	movs	r1, #1
   1008a:	f7fc bb05 	b.w	c698 <process_event>

0001008e <validate_args>:
{
   1008e:	b510      	push	{r4, lr}
   10090:	460c      	mov	r4, r1
	if ((mgr == NULL) || (cli == NULL)) {
   10092:	b140      	cbz	r0, 100a6 <validate_args+0x18>
   10094:	b139      	cbz	r1, 100a6 <validate_args+0x18>
	int rv = sys_notify_validate(&cli->notify);
   10096:	1d08      	adds	r0, r1, #4
   10098:	f7ff ff8c 	bl	ffb4 <sys_notify_validate>
	if ((rv == 0)
   1009c:	b928      	cbnz	r0, 100aa <validate_args+0x1c>
	    && ((cli->notify.flags
   1009e:	68a3      	ldr	r3, [r4, #8]
   100a0:	f033 0303 	bics.w	r3, r3, #3
   100a4:	d001      	beq.n	100aa <validate_args+0x1c>
		rv = -EINVAL;
   100a6:	f06f 0015 	mvn.w	r0, #21
}
   100aa:	bd10      	pop	{r4, pc}

000100ac <onoff_manager_init>:
{
   100ac:	b538      	push	{r3, r4, r5, lr}
   100ae:	460c      	mov	r4, r1
	if ((mgr == NULL)
   100b0:	4605      	mov	r5, r0
   100b2:	b158      	cbz	r0, 100cc <onoff_manager_init+0x20>
	    || (transitions == NULL)
   100b4:	b151      	cbz	r1, 100cc <onoff_manager_init+0x20>
	    || (transitions->start == NULL)
   100b6:	680b      	ldr	r3, [r1, #0]
   100b8:	b143      	cbz	r3, 100cc <onoff_manager_init+0x20>
	    || (transitions->stop == NULL)) {
   100ba:	684b      	ldr	r3, [r1, #4]
   100bc:	b133      	cbz	r3, 100cc <onoff_manager_init+0x20>
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
   100be:	221c      	movs	r2, #28
   100c0:	2100      	movs	r1, #0
   100c2:	f000 fac1 	bl	10648 <memset>
	return 0;
   100c6:	2000      	movs	r0, #0
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
   100c8:	612c      	str	r4, [r5, #16]
}
   100ca:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
   100cc:	f06f 0015 	mvn.w	r0, #21
   100d0:	e7fb      	b.n	100ca <onoff_manager_init+0x1e>

000100d2 <onoff_request>:

int onoff_request(struct onoff_manager *mgr,
		  struct onoff_client *cli)
{
   100d2:	b570      	push	{r4, r5, r6, lr}
   100d4:	4604      	mov	r4, r0
   100d6:	460e      	mov	r6, r1
	bool add_client = false;        /* add client to pending list */
	bool start = false;             /* trigger a start transition */
	bool notify = false;            /* do client notification */
	int rv = validate_args(mgr, cli);
   100d8:	f7ff ffd9 	bl	1008e <validate_args>

	if (rv < 0) {
   100dc:	1e05      	subs	r5, r0, #0
   100de:	db31      	blt.n	10144 <onoff_request+0x72>
   100e0:	f04f 0320 	mov.w	r3, #32
   100e4:	f3ef 8111 	mrs	r1, BASEPRI
   100e8:	f383 8811 	msr	BASEPRI, r3
   100ec:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;

	/* Reject if this would overflow the reference count. */
	if (mgr->refs == SERVICE_REFS_MAX) {
   100f0:	f64f 75ff 	movw	r5, #65535	; 0xffff
   100f4:	8b63      	ldrh	r3, [r4, #26]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
   100f6:	8b20      	ldrh	r0, [r4, #24]
	if (mgr->refs == SERVICE_REFS_MAX) {
   100f8:	42ab      	cmp	r3, r5
   100fa:	f000 0207 	and.w	r2, r0, #7
   100fe:	d02e      	beq.n	1015e <onoff_request+0x8c>
		rv = -EAGAIN;
		goto out;
	}

	rv = state;
	if (state == ONOFF_STATE_ON) {
   10100:	2a02      	cmp	r2, #2
   10102:	d10e      	bne.n	10122 <onoff_request+0x50>
		/* Increment reference count, notify in exit */
		notify = true;
		mgr->refs += 1U;
   10104:	3301      	adds	r3, #1
   10106:	8363      	strh	r3, [r4, #26]
	rv = state;
   10108:	4615      	mov	r5, r2
		notify = true;
   1010a:	2301      	movs	r3, #1
	__asm__ volatile(
   1010c:	f381 8811 	msr	BASEPRI, r1
   10110:	f3bf 8f6f 	isb	sy
	if (start) {
		process_event(mgr, EVT_RECHECK, key);
	} else {
		k_spin_unlock(&mgr->lock, key);

		if (notify) {
   10114:	b1b3      	cbz	r3, 10144 <onoff_request+0x72>
			notify_one(mgr, cli, state, 0);
   10116:	2300      	movs	r3, #0
   10118:	4631      	mov	r1, r6
   1011a:	4620      	mov	r0, r4
   1011c:	f7ff ff93 	bl	10046 <notify_one>
   10120:	e010      	b.n	10144 <onoff_request+0x72>
	} else if ((state == ONOFF_STATE_OFF)
   10122:	0783      	lsls	r3, r0, #30
   10124:	d001      	beq.n	1012a <onoff_request+0x58>
		   || (state == ONOFF_STATE_TO_ON)) {
   10126:	2a06      	cmp	r2, #6
   10128:	d10e      	bne.n	10148 <onoff_request+0x76>
	parent->next = child;
   1012a:	2300      	movs	r3, #0
   1012c:	6033      	str	r3, [r6, #0]
Z_GENLIST_APPEND(slist, snode)
   1012e:	6863      	ldr	r3, [r4, #4]
   10130:	b993      	cbnz	r3, 10158 <onoff_request+0x86>
	list->head = node;
   10132:	e9c4 6600 	strd	r6, r6, [r4]
	if (start) {
   10136:	4615      	mov	r5, r2
   10138:	b962      	cbnz	r2, 10154 <onoff_request+0x82>
		process_event(mgr, EVT_RECHECK, key);
   1013a:	460a      	mov	r2, r1
   1013c:	4620      	mov	r0, r4
   1013e:	2102      	movs	r1, #2
   10140:	f7fc faaa 	bl	c698 <process_event>
		}
	}

	return rv;
}
   10144:	4628      	mov	r0, r5
   10146:	bd70      	pop	{r4, r5, r6, pc}
		rv = -EIO;
   10148:	2a05      	cmp	r2, #5
   1014a:	bf0c      	ite	eq
   1014c:	f06f 0522 	mvneq.w	r5, #34	; 0x22
   10150:	f06f 0504 	mvnne.w	r5, #4
   10154:	2300      	movs	r3, #0
   10156:	e7d9      	b.n	1010c <onoff_request+0x3a>
	parent->next = child;
   10158:	601e      	str	r6, [r3, #0]
	list->tail = node;
   1015a:	6066      	str	r6, [r4, #4]
}
   1015c:	e7eb      	b.n	10136 <onoff_request+0x64>
		rv = -EAGAIN;
   1015e:	f06f 050a 	mvn.w	r5, #10
   10162:	e7f7      	b.n	10154 <onoff_request+0x82>

00010164 <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
   10164:	4604      	mov	r4, r0
   10166:	b508      	push	{r3, lr}
   10168:	4608      	mov	r0, r1
   1016a:	4611      	mov	r1, r2
	entry(p1, p2, p3);
   1016c:	461a      	mov	r2, r3
   1016e:	47a0      	blx	r4
	return z_impl_k_current_get();
   10170:	f7ff fb46 	bl	f800 <z_impl_k_current_get>
	z_impl_k_thread_abort(thread);
   10174:	f7fd fde2 	bl	dd3c <z_impl_k_thread_abort>

00010178 <chunk_field>:
				 enum chunk_fields f)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
   10178:	6883      	ldr	r3, [r0, #8]
	void *cmem = &buf[c];
   1017a:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
	if (big_heap(h)) {
   1017e:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
		return ((uint32_t *)cmem)[f];
   10182:	bf2c      	ite	cs
   10184:	f851 0022 	ldrcs.w	r0, [r1, r2, lsl #2]
	} else {
		return ((uint16_t *)cmem)[f];
   10188:	f831 0012 	ldrhcc.w	r0, [r1, r2, lsl #1]
	}
}
   1018c:	4770      	bx	lr

0001018e <chunk_set>:
			     enum chunk_fields f, chunkid_t val)
{
	CHECK(c <= h->len);

	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];
   1018e:	eb00 01c1 	add.w	r1, r0, r1, lsl #3

	if (big_heap(h)) {
   10192:	6880      	ldr	r0, [r0, #8]
   10194:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
		CHECK(val == (uint32_t)val);
		((uint32_t *)cmem)[f] = val;
   10198:	bf2c      	ite	cs
   1019a:	f841 3022 	strcs.w	r3, [r1, r2, lsl #2]
	} else {
		CHECK(val == (uint16_t)val);
		((uint16_t *)cmem)[f] = val;
   1019e:	f821 3012 	strhcc.w	r3, [r1, r2, lsl #1]
	}
}
   101a2:	4770      	bx	lr

000101a4 <chunk_size>:
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
}

static inline size_t chunk_size(struct z_heap *h, chunkid_t c)
{
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
   101a4:	2201      	movs	r2, #1
{
   101a6:	b508      	push	{r3, lr}
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
   101a8:	f7ff ffe6 	bl	10178 <chunk_field>
}
   101ac:	0840      	lsrs	r0, r0, #1
   101ae:	bd08      	pop	{r3, pc}

000101b0 <set_chunk_used>:
static inline void set_chunk_used(struct z_heap *h, chunkid_t c, bool used)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
   101b0:	6883      	ldr	r3, [r0, #8]
	void *cmem = &buf[c];
   101b2:	eb00 01c1 	add.w	r1, r0, r1, lsl #3
	if (big_heap(h)) {
   101b6:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   101ba:	d308      	bcc.n	101ce <set_chunk_used+0x1e>
		if (used) {
   101bc:	684b      	ldr	r3, [r1, #4]
   101be:	b11a      	cbz	r2, 101c8 <set_chunk_used+0x18>
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
   101c0:	f043 0301 	orr.w	r3, r3, #1
		} else {
			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
   101c4:	604b      	str	r3, [r1, #4]
   101c6:	4770      	bx	lr
   101c8:	f023 0301 	bic.w	r3, r3, #1
   101cc:	e7fa      	b.n	101c4 <set_chunk_used+0x14>
		}
	} else {
		if (used) {
   101ce:	884b      	ldrh	r3, [r1, #2]
   101d0:	b11a      	cbz	r2, 101da <set_chunk_used+0x2a>
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
   101d2:	f043 0301 	orr.w	r3, r3, #1
		} else {
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
   101d6:	804b      	strh	r3, [r1, #2]
		}
	}
}
   101d8:	4770      	bx	lr
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
   101da:	f023 0301 	bic.w	r3, r3, #1
   101de:	e7fa      	b.n	101d6 <set_chunk_used+0x26>

000101e0 <set_chunk_size>:
 * when its size is modified, and potential set_chunk_used() is always
 * invoked after set_chunk_size().
 */
static inline void set_chunk_size(struct z_heap *h, chunkid_t c, size_t size)
{
	chunk_set(h, c, SIZE_AND_USED, size << 1);
   101e0:	0053      	lsls	r3, r2, #1
   101e2:	2201      	movs	r2, #1
   101e4:	f7ff bfd3 	b.w	1018e <chunk_set>

000101e8 <bucket_idx>:
	return big_heap(h) && chunk_size(h, c) == 1U;
}

static inline size_t chunk_header_bytes(struct z_heap *h)
{
	return big_heap(h) ? 8 : 4;
   101e8:	6880      	ldr	r0, [r0, #8]
	return bytes_to_chunksz(h, 1);
}

static inline int bucket_idx(struct z_heap *h, size_t sz)
{
	size_t usable_sz = sz - min_chunk_size(h) + 1;
   101ea:	3101      	adds	r1, #1
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   101ec:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
   101f0:	bf2c      	ite	cs
   101f2:	2002      	movcs	r0, #2
   101f4:	2001      	movcc	r0, #1
	size_t usable_sz = sz - min_chunk_size(h) + 1;
   101f6:	1a08      	subs	r0, r1, r0
	return 31 - __builtin_clz(usable_sz);
   101f8:	fab0 f080 	clz	r0, r0
}
   101fc:	f1c0 001f 	rsb	r0, r0, #31
   10200:	4770      	bx	lr

00010202 <free_list_add>:
		set_prev_free_chunk(h, second, c);
	}
}

static void free_list_add(struct z_heap *h, chunkid_t c)
{
   10202:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   10206:	4604      	mov	r4, r0
   10208:	460d      	mov	r5, r1
	return sizeof(void *) > 4U || chunks > 0x7fffU;
   1020a:	f7ff ffcb 	bl	101a4 <chunk_size>
	return big_heap(h) && chunk_size(h, c) == 1U;
   1020e:	68a3      	ldr	r3, [r4, #8]
   10210:	4601      	mov	r1, r0
   10212:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
   10216:	d301      	bcc.n	1021c <free_list_add+0x1a>
	if (!solo_free_header(h, c)) {
   10218:	2801      	cmp	r0, #1
   1021a:	d035      	beq.n	10288 <free_list_add+0x86>
		int bidx = bucket_idx(h, chunk_size(h, c));
   1021c:	4620      	mov	r0, r4
   1021e:	f7ff ffe3 	bl	101e8 <bucket_idx>
	if (b->next == 0U) {
   10222:	eb04 0280 	add.w	r2, r4, r0, lsl #2
   10226:	6916      	ldr	r6, [r2, #16]
   10228:	b99e      	cbnz	r6, 10252 <free_list_add+0x50>
		h->avail_buckets |= (1 << bidx);
   1022a:	2301      	movs	r3, #1
   1022c:	fa03 f000 	lsl.w	r0, r3, r0
   10230:	68e3      	ldr	r3, [r4, #12]
	chunk_set(h, c, FREE_PREV, prev);
   10232:	4629      	mov	r1, r5
   10234:	4303      	orrs	r3, r0
   10236:	60e3      	str	r3, [r4, #12]
   10238:	4620      	mov	r0, r4
		b->next = c;
   1023a:	6115      	str	r5, [r2, #16]
   1023c:	462b      	mov	r3, r5
   1023e:	2202      	movs	r2, #2
   10240:	f7ff ffa5 	bl	1018e <chunk_set>
	chunk_set(h, c, FREE_NEXT, next);
   10244:	2203      	movs	r2, #3
   10246:	4629      	mov	r1, r5
	chunk_set(h, c, FREE_PREV, prev);
   10248:	4620      	mov	r0, r4
		free_list_add_bidx(h, c, bidx);
	}
}
   1024a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   1024e:	f7ff bf9e 	b.w	1018e <chunk_set>
	return chunk_field(h, c, FREE_PREV);
   10252:	2202      	movs	r2, #2
   10254:	4631      	mov	r1, r6
   10256:	4620      	mov	r0, r4
   10258:	f7ff ff8e 	bl	10178 <chunk_field>
   1025c:	4607      	mov	r7, r0
	chunk_set(h, c, FREE_PREV, prev);
   1025e:	4603      	mov	r3, r0
   10260:	2202      	movs	r2, #2
   10262:	4629      	mov	r1, r5
   10264:	4620      	mov	r0, r4
   10266:	f7ff ff92 	bl	1018e <chunk_set>
	chunk_set(h, c, FREE_NEXT, next);
   1026a:	4633      	mov	r3, r6
   1026c:	2203      	movs	r2, #3
   1026e:	4629      	mov	r1, r5
   10270:	4620      	mov	r0, r4
   10272:	f7ff ff8c 	bl	1018e <chunk_set>
   10276:	2203      	movs	r2, #3
   10278:	4639      	mov	r1, r7
   1027a:	462b      	mov	r3, r5
   1027c:	4620      	mov	r0, r4
   1027e:	f7ff ff86 	bl	1018e <chunk_set>
	chunk_set(h, c, FREE_PREV, prev);
   10282:	2202      	movs	r2, #2
   10284:	4631      	mov	r1, r6
   10286:	e7df      	b.n	10248 <free_list_add+0x46>
   10288:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0001028c <sys_heap_init>:
	return big_heap_bytes(size) ? 8 : 4;
   1028c:	f5b2 2f80 	cmp.w	r2, #262144	; 0x40000
		return ptr2;
	}
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
   10290:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   10292:	bf2c      	ite	cs
   10294:	2508      	movcs	r5, #8
   10296:	2504      	movcc	r5, #4
	CHECK(end > addr);
	__ASSERT(buf_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
	h->chunk0_hdr_area = 0;
   10298:	2300      	movs	r3, #0
	bytes -= heap_footer_bytes(bytes);
   1029a:	1b55      	subs	r5, r2, r5
	h->chunk0_hdr_area = 0;
   1029c:	2200      	movs	r2, #0
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
   1029e:	1dcc      	adds	r4, r1, #7
   102a0:	f024 0407 	bic.w	r4, r4, #7
	heap->heap = h;
   102a4:	6004      	str	r4, [r0, #0]
	h->chunk0_hdr_area = 0;
   102a6:	e9c4 2300 	strd	r2, r3, [r4]
	h->len = buf_sz;
	h->avail_buckets = 0;
   102aa:	2300      	movs	r3, #0
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
   102ac:	440d      	add	r5, r1
   102ae:	f025 0507 	bic.w	r5, r5, #7
	size_t buf_sz = (end - addr) / CHUNK_UNIT;
   102b2:	1b2d      	subs	r5, r5, r4
   102b4:	08ed      	lsrs	r5, r5, #3

	int nb_buckets = bucket_idx(h, buf_sz) + 1;
   102b6:	4629      	mov	r1, r5
   102b8:	4620      	mov	r0, r4
	h->len = buf_sz;
   102ba:	60a5      	str	r5, [r4, #8]
	h->avail_buckets = 0;
   102bc:	60e3      	str	r3, [r4, #12]
	int nb_buckets = bucket_idx(h, buf_sz) + 1;
   102be:	f7ff ff93 	bl	101e8 <bucket_idx>
	size_t chunk0_size = chunksz(sizeof(struct z_heap) +
   102c2:	0086      	lsls	r6, r0, #2
	int nb_buckets = bucket_idx(h, buf_sz) + 1;
   102c4:	1c41      	adds	r1, r0, #1
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) < buf_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
		h->buckets[i].next = 0;
   102c6:	4618      	mov	r0, r3
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
   102c8:	361b      	adds	r6, #27
   102ca:	08f6      	lsrs	r6, r6, #3
	for (int i = 0; i < nb_buckets; i++) {
   102cc:	f104 0210 	add.w	r2, r4, #16
   102d0:	428b      	cmp	r3, r1
   102d2:	db29      	blt.n	10328 <sys_heap_init+0x9c>
	}

	/* chunk containing our struct z_heap */
	set_chunk_size(h, 0, chunk0_size);
   102d4:	4632      	mov	r2, r6
   102d6:	4620      	mov	r0, r4
   102d8:	2100      	movs	r1, #0
   102da:	f7ff ff81 	bl	101e0 <set_chunk_size>
	set_chunk_used(h, 0, true);

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, buf_sz - chunk0_size);
   102de:	1baf      	subs	r7, r5, r6
	set_chunk_used(h, 0, true);
   102e0:	4620      	mov	r0, r4
   102e2:	2201      	movs	r2, #1
   102e4:	2100      	movs	r1, #0
   102e6:	f7ff ff63 	bl	101b0 <set_chunk_used>
	set_chunk_size(h, chunk0_size, buf_sz - chunk0_size);
   102ea:	463a      	mov	r2, r7
   102ec:	4631      	mov	r1, r6
   102ee:	f7ff ff77 	bl	101e0 <set_chunk_size>
	chunk_set(h, c, LEFT_SIZE, size);
   102f2:	4633      	mov	r3, r6
   102f4:	4631      	mov	r1, r6
   102f6:	4620      	mov	r0, r4
   102f8:	2200      	movs	r2, #0
   102fa:	f7ff ff48 	bl	1018e <chunk_set>
	set_left_chunk_size(h, chunk0_size, chunk0_size);

	/* the end marker chunk */
	set_chunk_size(h, buf_sz, 0);
   102fe:	4629      	mov	r1, r5
   10300:	4620      	mov	r0, r4
   10302:	2200      	movs	r2, #0
   10304:	f7ff ff6c 	bl	101e0 <set_chunk_size>
   10308:	463b      	mov	r3, r7
   1030a:	4629      	mov	r1, r5
   1030c:	4620      	mov	r0, r4
   1030e:	2200      	movs	r2, #0
   10310:	f7ff ff3d 	bl	1018e <chunk_set>
	set_left_chunk_size(h, buf_sz, buf_sz - chunk0_size);
	set_chunk_used(h, buf_sz, true);
   10314:	4629      	mov	r1, r5
   10316:	4620      	mov	r0, r4
   10318:	2201      	movs	r2, #1
   1031a:	f7ff ff49 	bl	101b0 <set_chunk_used>

	free_list_add(h, chunk0_size);
   1031e:	4631      	mov	r1, r6
}
   10320:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	free_list_add(h, chunk0_size);
   10324:	f7ff bf6d 	b.w	10202 <free_list_add>
		h->buckets[i].next = 0;
   10328:	f842 0b04 	str.w	r0, [r2], #4
	for (int i = 0; i < nb_buckets; i++) {
   1032c:	3301      	adds	r3, #1
   1032e:	e7cf      	b.n	102d0 <sys_heap_init+0x44>

00010330 <encode_uint>:
{
   10330:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   10334:	4699      	mov	r9, r3
	bool upcase = isupper((int)conv->specifier);
   10336:	78d3      	ldrb	r3, [r2, #3]
{
   10338:	4614      	mov	r4, r2
	switch (specifier) {
   1033a:	2b6f      	cmp	r3, #111	; 0x6f
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
   1033c:	f1a3 0241 	sub.w	r2, r3, #65	; 0x41
{
   10340:	4606      	mov	r6, r0
   10342:	460f      	mov	r7, r1
   10344:	9201      	str	r2, [sp, #4]
	switch (specifier) {
   10346:	d02d      	beq.n	103a4 <encode_uint+0x74>
   10348:	d828      	bhi.n	1039c <encode_uint+0x6c>
		return 16;
   1034a:	2b58      	cmp	r3, #88	; 0x58
   1034c:	bf14      	ite	ne
   1034e:	250a      	movne	r5, #10
   10350:	2510      	moveq	r5, #16
		unsigned int lsv = (unsigned int)(value % radix);
   10352:	46aa      	mov	sl, r5
   10354:	f04f 0b00 	mov.w	fp, #0
	char *bp = bps + (bpe - bps);
   10358:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
		unsigned int lsv = (unsigned int)(value % radix);
   1035c:	4652      	mov	r2, sl
   1035e:	465b      	mov	r3, fp
   10360:	4630      	mov	r0, r6
   10362:	4639      	mov	r1, r7
   10364:	f7fb fff6 	bl	c354 <__aeabi_uldivmod>
		*--bp = (lsv <= 9) ? ('0' + lsv)
   10368:	2a09      	cmp	r2, #9
   1036a:	b2d3      	uxtb	r3, r2
   1036c:	d81f      	bhi.n	103ae <encode_uint+0x7e>
   1036e:	3330      	adds	r3, #48	; 0x30
	} while ((value != 0) && (bps < bp));
   10370:	455f      	cmp	r7, fp
		*--bp = (lsv <= 9) ? ('0' + lsv)
   10372:	b2db      	uxtb	r3, r3
	} while ((value != 0) && (bps < bp));
   10374:	bf08      	it	eq
   10376:	4556      	cmpeq	r6, sl
		*--bp = (lsv <= 9) ? ('0' + lsv)
   10378:	f808 3d01 	strb.w	r3, [r8, #-1]!
	} while ((value != 0) && (bps < bp));
   1037c:	d301      	bcc.n	10382 <encode_uint+0x52>
   1037e:	45c8      	cmp	r8, r9
   10380:	d812      	bhi.n	103a8 <encode_uint+0x78>
	if (conv->flag_hash) {
   10382:	7823      	ldrb	r3, [r4, #0]
   10384:	069b      	lsls	r3, r3, #26
   10386:	d505      	bpl.n	10394 <encode_uint+0x64>
		if (radix == 8) {
   10388:	2d08      	cmp	r5, #8
   1038a:	d116      	bne.n	103ba <encode_uint+0x8a>
			conv->altform_0 = true;
   1038c:	78a3      	ldrb	r3, [r4, #2]
   1038e:	f043 0308 	orr.w	r3, r3, #8
			conv->altform_0c = true;
   10392:	70a3      	strb	r3, [r4, #2]
}
   10394:	4640      	mov	r0, r8
   10396:	b003      	add	sp, #12
   10398:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (specifier) {
   1039c:	f003 03f7 	and.w	r3, r3, #247	; 0xf7
		return 16;
   103a0:	2b70      	cmp	r3, #112	; 0x70
   103a2:	e7d3      	b.n	1034c <encode_uint+0x1c>
	switch (specifier) {
   103a4:	2508      	movs	r5, #8
   103a6:	e7d4      	b.n	10352 <encode_uint+0x22>
		value /= radix;
   103a8:	4606      	mov	r6, r0
   103aa:	460f      	mov	r7, r1
   103ac:	e7d6      	b.n	1035c <encode_uint+0x2c>
		*--bp = (lsv <= 9) ? ('0' + lsv)
   103ae:	9a01      	ldr	r2, [sp, #4]
   103b0:	2a19      	cmp	r2, #25
   103b2:	bf94      	ite	ls
   103b4:	3337      	addls	r3, #55	; 0x37
   103b6:	3357      	addhi	r3, #87	; 0x57
   103b8:	e7da      	b.n	10370 <encode_uint+0x40>
		} else if (radix == 16) {
   103ba:	2d10      	cmp	r5, #16
   103bc:	d1ea      	bne.n	10394 <encode_uint+0x64>
			conv->altform_0c = true;
   103be:	78a3      	ldrb	r3, [r4, #2]
   103c0:	f043 0310 	orr.w	r3, r3, #16
   103c4:	e7e5      	b.n	10392 <encode_uint+0x62>

000103c6 <outs>:
{
   103c6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   103ca:	4607      	mov	r7, r0
   103cc:	4688      	mov	r8, r1
   103ce:	4615      	mov	r5, r2
   103d0:	461e      	mov	r6, r3
	while ((sp < ep) || ((ep == NULL) && *sp)) {
   103d2:	4614      	mov	r4, r2
   103d4:	42b4      	cmp	r4, r6
   103d6:	eba4 0005 	sub.w	r0, r4, r5
   103da:	d302      	bcc.n	103e2 <outs+0x1c>
   103dc:	b93e      	cbnz	r6, 103ee <outs+0x28>
   103de:	7823      	ldrb	r3, [r4, #0]
   103e0:	b12b      	cbz	r3, 103ee <outs+0x28>
		int rc = out((int)*sp++, ctx);
   103e2:	4641      	mov	r1, r8
   103e4:	f814 0b01 	ldrb.w	r0, [r4], #1
   103e8:	47b8      	blx	r7
		if (rc < 0) {
   103ea:	2800      	cmp	r0, #0
   103ec:	daf2      	bge.n	103d4 <outs+0xe>
}
   103ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

000103f2 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_MCUBOOT_SIGNATURE_KEY_FILE, 1);
GEN_ABSOLUTE_SYM(CONFIG_MCUBOOT_EXTRA_IMGTOOL_ARGS, 1);
GEN_ABSOLUTE_SYM(CONFIG_REBOOT, 1);
GEN_ABSOLUTE_SYM(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
   103f2:	4770      	bx	lr

000103f4 <z_platform_init>:
	SystemInit();
   103f4:	f7fe b9d4 	b.w	e7a0 <SystemInit>

000103f8 <get_status>:
	return GET_STATUS(get_sub_data(dev, type)->flags);
   103f8:	b2cb      	uxtb	r3, r1
   103fa:	210c      	movs	r1, #12
   103fc:	68c2      	ldr	r2, [r0, #12]
   103fe:	fb03 2101 	mla	r1, r3, r1, r2
   10402:	6f88      	ldr	r0, [r1, #120]	; 0x78
}
   10404:	f000 0007 	and.w	r0, r0, #7
   10408:	4770      	bx	lr

0001040a <set_off_state>:
	__asm__ volatile(
   1040a:	f04f 0320 	mov.w	r3, #32
   1040e:	f3ef 8211 	mrs	r2, BASEPRI
   10412:	f383 8811 	msr	BASEPRI, r3
   10416:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   1041a:	6803      	ldr	r3, [r0, #0]
	if ((current_ctx != 0) && (current_ctx != ctx)) {
   1041c:	f013 03c0 	ands.w	r3, r3, #192	; 0xc0
   10420:	d001      	beq.n	10426 <set_off_state+0x1c>
   10422:	428b      	cmp	r3, r1
   10424:	d107      	bne.n	10436 <set_off_state+0x2c>
		*flags = CLOCK_CONTROL_STATUS_OFF;
   10426:	2301      	movs	r3, #1
   10428:	6003      	str	r3, [r0, #0]
	int err = 0;
   1042a:	2000      	movs	r0, #0
	__asm__ volatile(
   1042c:	f382 8811 	msr	BASEPRI, r2
   10430:	f3bf 8f6f 	isb	sy
}
   10434:	4770      	bx	lr
		err = -EPERM;
   10436:	f04f 30ff 	mov.w	r0, #4294967295
   1043a:	e7f7      	b.n	1042c <set_off_state+0x22>

0001043c <set_starting_state>:
{
   1043c:	b510      	push	{r4, lr}
	__asm__ volatile(
   1043e:	f04f 0320 	mov.w	r3, #32
   10442:	f3ef 8211 	mrs	r2, BASEPRI
   10446:	f383 8811 	msr	BASEPRI, r3
   1044a:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
   1044e:	6803      	ldr	r3, [r0, #0]
	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
   10450:	f003 0407 	and.w	r4, r3, #7
   10454:	2c01      	cmp	r4, #1
   10456:	d106      	bne.n	10466 <set_starting_state+0x2a>
		*flags = CLOCK_CONTROL_STATUS_STARTING | ctx;
   10458:	6001      	str	r1, [r0, #0]
	int err = 0;
   1045a:	2000      	movs	r0, #0
	__asm__ volatile(
   1045c:	f382 8811 	msr	BASEPRI, r2
   10460:	f3bf 8f6f 	isb	sy
}
   10464:	bd10      	pop	{r4, pc}
	uint32_t current_ctx = GET_CTX(*flags);
   10466:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
	} else if (current_ctx != ctx) {
   1046a:	428b      	cmp	r3, r1
		err = -EALREADY;
   1046c:	bf14      	ite	ne
   1046e:	f04f 30ff 	movne.w	r0, #4294967295
   10472:	f06f 0044 	mvneq.w	r0, #68	; 0x44
   10476:	e7f1      	b.n	1045c <set_starting_state+0x20>

00010478 <set_on_state>:
	__asm__ volatile(
   10478:	f04f 0320 	mov.w	r3, #32
   1047c:	f3ef 8211 	mrs	r2, BASEPRI
   10480:	f383 8811 	msr	BASEPRI, r3
   10484:	f3bf 8f6f 	isb	sy
	*flags = CLOCK_CONTROL_STATUS_ON | GET_CTX(*flags);
   10488:	6803      	ldr	r3, [r0, #0]
   1048a:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
   1048e:	f043 0302 	orr.w	r3, r3, #2
   10492:	6003      	str	r3, [r0, #0]
	__asm__ volatile(
   10494:	f382 8811 	msr	BASEPRI, r2
   10498:	f3bf 8f6f 	isb	sy
}
   1049c:	4770      	bx	lr

0001049e <onoff_started_callback>:
{
   1049e:	b410      	push	{r4}
	notify(mgr, 0);
   104a0:	241c      	movs	r4, #28
	return &data->mgr[type];
   104a2:	68c0      	ldr	r0, [r0, #12]
   104a4:	b2cb      	uxtb	r3, r1
	notify(mgr, 0);
   104a6:	fb03 0004 	mla	r0, r3, r4, r0
   104aa:	2100      	movs	r1, #0
}
   104ac:	bc10      	pop	{r4}
	notify(mgr, 0);
   104ae:	4710      	bx	r2

000104b0 <hfclkaudio_start>:
	nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLKAUDIO);
   104b0:	2003      	movs	r0, #3
   104b2:	f7fe ba07 	b.w	e8c4 <nrfx_clock_start>

000104b6 <hfclk192m_start>:
	nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK192M);
   104b6:	2002      	movs	r0, #2
   104b8:	f7fe ba04 	b.w	e8c4 <nrfx_clock_start>

000104bc <lfclk_start>:
    nrfx_clock_start(NRF_CLOCK_DOMAIN_LFCLK);
   104bc:	2000      	movs	r0, #0
   104be:	f7fe ba01 	b.w	e8c4 <nrfx_clock_start>

000104c2 <hfclkaudio_stop>:
	nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLKAUDIO);
   104c2:	2003      	movs	r0, #3
   104c4:	f7fe ba52 	b.w	e96c <nrfx_clock_stop>

000104c8 <hfclk192m_stop>:
	nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK192M);
   104c8:	2002      	movs	r0, #2
   104ca:	f7fe ba4f 	b.w	e96c <nrfx_clock_stop>

000104ce <lfclk_stop>:
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
   104ce:	2000      	movs	r0, #0
   104d0:	f7fe ba4c 	b.w	e96c <nrfx_clock_stop>

000104d4 <blocking_start_callback>:
{
   104d4:	4610      	mov	r0, r2
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
   104d6:	f7ff b999 	b.w	f80c <z_impl_k_sem_give>

000104da <api_stop>:
{
   104da:	b538      	push	{r3, r4, r5, lr}
	err = set_off_state(&subdata->flags, ctx);
   104dc:	230c      	movs	r3, #12
   104de:	b2cc      	uxtb	r4, r1
   104e0:	4363      	muls	r3, r4
{
   104e2:	4605      	mov	r5, r0
	err = set_off_state(&subdata->flags, ctx);
   104e4:	68c0      	ldr	r0, [r0, #12]
   104e6:	3378      	adds	r3, #120	; 0x78
   104e8:	2180      	movs	r1, #128	; 0x80
   104ea:	4418      	add	r0, r3
   104ec:	f7ff ff8d 	bl	1040a <set_off_state>
	if (err < 0) {
   104f0:	2800      	cmp	r0, #0
   104f2:	db05      	blt.n	10500 <api_stop+0x26>
	get_sub_config(dev, type)->stop();
   104f4:	6869      	ldr	r1, [r5, #4]
   104f6:	eb01 04c4 	add.w	r4, r1, r4, lsl #3
   104fa:	6863      	ldr	r3, [r4, #4]
   104fc:	4798      	blx	r3
	return 0;
   104fe:	2000      	movs	r0, #0
}
   10500:	bd38      	pop	{r3, r4, r5, pc}

00010502 <api_start>:
{
   10502:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	err = set_starting_state(&subdata->flags, ctx);
   10506:	270c      	movs	r7, #12
   10508:	b2cd      	uxtb	r5, r1
   1050a:	436f      	muls	r7, r5
	struct nrf_clock_control_sub_data *subdata = get_sub_data(dev, type);
   1050c:	68c4      	ldr	r4, [r0, #12]
{
   1050e:	4606      	mov	r6, r0
	err = set_starting_state(&subdata->flags, ctx);
   10510:	f107 0078 	add.w	r0, r7, #120	; 0x78
   10514:	2180      	movs	r1, #128	; 0x80
   10516:	4420      	add	r0, r4
{
   10518:	4690      	mov	r8, r2
   1051a:	4699      	mov	r9, r3
	err = set_starting_state(&subdata->flags, ctx);
   1051c:	f7ff ff8e 	bl	1043c <set_starting_state>
	if (err < 0) {
   10520:	2800      	cmp	r0, #0
   10522:	db07      	blt.n	10534 <api_start+0x32>
	subdata->cb = cb;
   10524:	443c      	add	r4, r7
	subdata->user_data = user_data;
   10526:	e9c4 891c 	strd	r8, r9, [r4, #112]	; 0x70
	 get_sub_config(dev, type)->start();
   1052a:	6873      	ldr	r3, [r6, #4]
   1052c:	f853 3035 	ldr.w	r3, [r3, r5, lsl #3]
   10530:	4798      	blx	r3
	return 0;
   10532:	2000      	movs	r0, #0
}
   10534:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00010538 <z_clock_isr>:
/* Weak-linked noop defaults for optional driver interfaces: */

void __weak z_clock_isr(void *arg)
{
	__ASSERT_NO_MSG(false);
}
   10538:	4770      	bx	lr

0001053a <z_clock_idle_exit>:
{
}

void __weak z_clock_idle_exit(void)
{
}
   1053a:	4770      	bx	lr

0001053c <sys_clock_disable>:
   1053c:	4770      	bx	lr

0001053e <abort_function>:
	sys_reboot(SYS_REBOOT_WARM);
   1053e:	2000      	movs	r0, #0
   10540:	f7fc bdba 	b.w	d0b8 <sys_reboot>

00010544 <z_irq_spurious>:
 */
void z_irq_spurious(const void *unused)
{
	ARG_UNUSED(unused);

	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
   10544:	2100      	movs	r1, #0
   10546:	2001      	movs	r0, #1
   10548:	f000 b804 	b.w	10554 <z_arm_fatal_error>

0001054c <configure_builtin_stack_guard>:
  __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
   1054c:	6e83      	ldr	r3, [r0, #104]	; 0x68
   1054e:	f383 880b 	msr	PSPLIM, r3
}
   10552:	4770      	bx	lr

00010554 <z_arm_fatal_error>:
{

	if (esf != NULL) {
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
   10554:	f000 b9c0 	b.w	108d8 <z_fatal_error>

00010558 <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
   10558:	4601      	mov	r1, r0
	z_fatal_error(reason, esf);
   1055a:	6800      	ldr	r0, [r0, #0]
   1055c:	f000 b9bc 	b.w	108d8 <z_fatal_error>

00010560 <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
   10560:	b508      	push	{r3, lr}
	handler();
   10562:	f7fd fa35 	bl	d9d0 <z_SysNmiOnReset>
	z_arm_int_exit();
}
   10566:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
   1056a:	f7fd bb85 	b.w	dc78 <z_arm_exc_exit>

0001056e <mpu_configure_region>:
{
   1056e:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	p_attr->rbar = attr->rbar &
   10570:	890a      	ldrh	r2, [r1, #8]
   10572:	7a8e      	ldrb	r6, [r1, #10]
	region_conf.base = new_region->start;
   10574:	680b      	ldr	r3, [r1, #0]
	get_region_attr_from_mpu_partition_info(&region_conf.attr,
   10576:	684d      	ldr	r5, [r1, #4]
   10578:	f002 021f 	and.w	r2, r2, #31
   1057c:	ea42 1246 	orr.w	r2, r2, r6, lsl #5
	region_conf.base = new_region->start;
   10580:	9300      	str	r3, [sp, #0]
   10582:	f88d 2008 	strb.w	r2, [sp, #8]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
   10586:	f023 031f 	bic.w	r3, r3, #31
   1058a:	1e6a      	subs	r2, r5, #1
   1058c:	4413      	add	r3, r2
   1058e:	f023 031f 	bic.w	r3, r3, #31
	if (index > (get_num_regions() - 1U)) {
   10592:	2807      	cmp	r0, #7
   10594:	9303      	str	r3, [sp, #12]
   10596:	d804      	bhi.n	105a2 <mpu_configure_region+0x34>
	region_init(index, region_conf);
   10598:	4669      	mov	r1, sp
   1059a:	f7fd fc0d 	bl	ddb8 <region_init>
}
   1059e:	b004      	add	sp, #16
   105a0:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
   105a2:	f06f 0015 	mvn.w	r0, #21
	return region_allocate_and_init(index,
   105a6:	e7fa      	b.n	1059e <mpu_configure_region+0x30>

000105a8 <arm_cmse_mpu_region_get>:
__CMSE_TT_ASM ()

__extension__ static __inline __attribute__ ((__always_inline__))
cmse_address_info_t
cmse_TT (void *__p)
__CMSE_TT_ASM ()
   105a8:	e840 f300 	tt	r3, r0

int arm_cmse_mpu_region_get(uint32_t addr)
{
	cmse_address_info_t addr_info =	cmse_TT((void *)addr);

	if (addr_info.flags.mpu_region_valid) {
   105ac:	f413 3f80 	tst.w	r3, #65536	; 0x10000
   105b0:	b2d8      	uxtb	r0, r3
		return addr_info.flags.mpu_region;
	}

	return -EINVAL;
}
   105b2:	bf08      	it	eq
   105b4:	f06f 0015 	mvneq.w	r0, #21
   105b8:	4770      	bx	lr

000105ba <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
   105ba:	4603      	mov	r3, r0
	size_t n = 0;
   105bc:	2000      	movs	r0, #0

	while (*s != '\0') {
   105be:	5c1a      	ldrb	r2, [r3, r0]
   105c0:	b902      	cbnz	r2, 105c4 <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
   105c2:	4770      	bx	lr
		n++;
   105c4:	3001      	adds	r0, #1
   105c6:	e7fa      	b.n	105be <strlen+0x4>

000105c8 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
   105c8:	4603      	mov	r3, r0
	size_t n = 0;
   105ca:	2000      	movs	r0, #0

	while (*s != '\0' && n < maxlen) {
   105cc:	5c1a      	ldrb	r2, [r3, r0]
   105ce:	b10a      	cbz	r2, 105d4 <strnlen+0xc>
   105d0:	4288      	cmp	r0, r1
   105d2:	d100      	bne.n	105d6 <strnlen+0xe>
		s++;
		n++;
	}

	return n;
}
   105d4:	4770      	bx	lr
		n++;
   105d6:	3001      	adds	r0, #1
   105d8:	e7f8      	b.n	105cc <strnlen+0x4>

000105da <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
   105da:	1e43      	subs	r3, r0, #1
   105dc:	3901      	subs	r1, #1
   105de:	f813 2f01 	ldrb.w	r2, [r3, #1]!
   105e2:	f811 0f01 	ldrb.w	r0, [r1, #1]!
   105e6:	4282      	cmp	r2, r0
   105e8:	d101      	bne.n	105ee <strcmp+0x14>
   105ea:	2a00      	cmp	r2, #0
   105ec:	d1f7      	bne.n	105de <strcmp+0x4>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
   105ee:	1a10      	subs	r0, r2, r0
   105f0:	4770      	bx	lr

000105f2 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
   105f2:	b5f0      	push	{r4, r5, r6, r7, lr}

	unsigned char *d_byte = (unsigned char *)d;
	const unsigned char *s_byte = (const unsigned char *)s;
	const uintptr_t mask = sizeof(mem_word_t) - 1;

	if ((((uintptr_t)d ^ (uintptr_t)s_byte) & mask) == 0) {
   105f4:	ea81 0400 	eor.w	r4, r1, r0
   105f8:	07a5      	lsls	r5, r4, #30
   105fa:	4603      	mov	r3, r0
   105fc:	d00b      	beq.n	10616 <memcpy+0x24>
   105fe:	3b01      	subs	r3, #1
   10600:	440a      	add	r2, r1
		s_byte = (unsigned char *)s_word;
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
   10602:	4291      	cmp	r1, r2
   10604:	d11b      	bne.n	1063e <memcpy+0x4c>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
   10606:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (n == 0) {
   10608:	2a00      	cmp	r2, #0
   1060a:	d0fc      	beq.n	10606 <memcpy+0x14>
			*(d_byte++) = *(s_byte++);
   1060c:	f811 4b01 	ldrb.w	r4, [r1], #1
			n--;
   10610:	3a01      	subs	r2, #1
			*(d_byte++) = *(s_byte++);
   10612:	f803 4b01 	strb.w	r4, [r3], #1
		while (((uintptr_t)d_byte) & mask) {
   10616:	079c      	lsls	r4, r3, #30
   10618:	d1f6      	bne.n	10608 <memcpy+0x16>
   1061a:	f022 0403 	bic.w	r4, r2, #3
   1061e:	1f1d      	subs	r5, r3, #4
   10620:	0896      	lsrs	r6, r2, #2
   10622:	190f      	adds	r7, r1, r4
		while (n >= sizeof(mem_word_t)) {
   10624:	42b9      	cmp	r1, r7
   10626:	d105      	bne.n	10634 <memcpy+0x42>
   10628:	f06f 0503 	mvn.w	r5, #3
   1062c:	4423      	add	r3, r4
   1062e:	fb05 2206 	mla	r2, r5, r6, r2
   10632:	e7e4      	b.n	105fe <memcpy+0xc>
			*(d_word++) = *(s_word++);
   10634:	f851 cb04 	ldr.w	ip, [r1], #4
   10638:	f845 cf04 	str.w	ip, [r5, #4]!
			n -= sizeof(mem_word_t);
   1063c:	e7f2      	b.n	10624 <memcpy+0x32>
		*(d_byte++) = *(s_byte++);
   1063e:	f811 4b01 	ldrb.w	r4, [r1], #1
   10642:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
   10646:	e7dc      	b.n	10602 <memcpy+0x10>

00010648 <memset>:

void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
   10648:	4603      	mov	r3, r0
{
   1064a:	b570      	push	{r4, r5, r6, lr}
	unsigned char c_byte = (unsigned char)c;
   1064c:	b2c9      	uxtb	r1, r1

	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
   1064e:	079c      	lsls	r4, r3, #30
   10650:	d111      	bne.n	10676 <memset+0x2e>
	/* do word-sized initialization as long as possible */

	mem_word_t *d_word = (mem_word_t *)d_byte;
	mem_word_t c_word = (mem_word_t)c_byte;

	c_word |= c_word << 8;
   10652:	ea41 2401 	orr.w	r4, r1, r1, lsl #8
	c_word |= c_word << 16;
   10656:	f022 0603 	bic.w	r6, r2, #3
   1065a:	ea44 4504 	orr.w	r5, r4, r4, lsl #16
#if Z_MEM_WORD_T_WIDTH > 32
	c_word |= c_word << 32;
#endif

	while (n >= sizeof(mem_word_t)) {
   1065e:	441e      	add	r6, r3
   10660:	0894      	lsrs	r4, r2, #2
   10662:	42b3      	cmp	r3, r6
   10664:	d10d      	bne.n	10682 <memset+0x3a>
   10666:	f06f 0503 	mvn.w	r5, #3
   1066a:	fb05 2204 	mla	r2, r5, r4, r2
   1066e:	441a      	add	r2, r3

	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
   10670:	4293      	cmp	r3, r2
   10672:	d109      	bne.n	10688 <memset+0x40>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
   10674:	bd70      	pop	{r4, r5, r6, pc}
		if (n == 0) {
   10676:	2a00      	cmp	r2, #0
   10678:	d0fc      	beq.n	10674 <memset+0x2c>
		*(d_byte++) = c_byte;
   1067a:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
   1067e:	3a01      	subs	r2, #1
   10680:	e7e5      	b.n	1064e <memset+0x6>
		*(d_word++) = c_word;
   10682:	f843 5b04 	str.w	r5, [r3], #4
		n -= sizeof(mem_word_t);
   10686:	e7ec      	b.n	10662 <memset+0x1a>
		*(d_byte++) = c_byte;
   10688:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
   1068c:	e7f0      	b.n	10670 <memset+0x28>

0001068e <_stdout_hook_default>:
}
   1068e:	f04f 30ff 	mov.w	r0, #4294967295
   10692:	4770      	bx	lr

00010694 <gpio_fire_callbacks>:
 * @param pins The actual pin mask that triggered the interrupt
 */
static inline void gpio_fire_callbacks(sys_slist_t *list,
					const struct device *port,
					uint32_t pins)
{
   10694:	b570      	push	{r4, r5, r6, lr}
   10696:	460e      	mov	r6, r1
	struct gpio_callback *cb, *tmp;

	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   10698:	6801      	ldr	r1, [r0, #0]
{
   1069a:	4615      	mov	r5, r2
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   1069c:	b189      	cbz	r1, 106c2 <gpio_fire_callbacks+0x2e>
	return node->next;
   1069e:	680c      	ldr	r4, [r1, #0]
   106a0:	2c00      	cmp	r4, #0
   106a2:	bf38      	it	cc
   106a4:	2400      	movcc	r4, #0
		if (cb->pin_mask & pins) {
   106a6:	688a      	ldr	r2, [r1, #8]
   106a8:	402a      	ands	r2, r5
   106aa:	d002      	beq.n	106b2 <gpio_fire_callbacks+0x1e>
			__ASSERT(cb->handler, "No callback handler!");
			cb->handler(port, cb, cb->pin_mask & pins);
   106ac:	4630      	mov	r0, r6
   106ae:	684b      	ldr	r3, [r1, #4]
   106b0:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
   106b2:	b134      	cbz	r4, 106c2 <gpio_fire_callbacks+0x2e>
   106b4:	6823      	ldr	r3, [r4, #0]
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   106b6:	4621      	mov	r1, r4
   106b8:	2b00      	cmp	r3, #0
   106ba:	bf38      	it	cc
   106bc:	2300      	movcc	r3, #0
   106be:	461c      	mov	r4, r3
   106c0:	e7f1      	b.n	106a6 <gpio_fire_callbacks+0x12>
		}
	}
}
   106c2:	bd70      	pop	{r4, r5, r6, pc}

000106c4 <gpio_nrfx_port_get_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   106c4:	6843      	ldr	r3, [r0, #4]
}
   106c6:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   106c8:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
   106ca:	691b      	ldr	r3, [r3, #16]
	*value = nrf_gpio_port_in_read(reg);
   106cc:	600b      	str	r3, [r1, #0]
}
   106ce:	4770      	bx	lr

000106d0 <gpio_nrfx_port_set_masked_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   106d0:	6843      	ldr	r3, [r0, #4]
   106d2:	685b      	ldr	r3, [r3, #4]
    return p_reg->OUT;
   106d4:	6858      	ldr	r0, [r3, #4]
	nrf_gpio_port_out_write(reg, value_tmp | (mask & value));
   106d6:	4042      	eors	r2, r0
   106d8:	400a      	ands	r2, r1
   106da:	4042      	eors	r2, r0
    p_reg->OUT = value;
   106dc:	605a      	str	r2, [r3, #4]
}
   106de:	2000      	movs	r0, #0
   106e0:	4770      	bx	lr

000106e2 <gpio_nrfx_port_set_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   106e2:	6843      	ldr	r3, [r0, #4]
}
   106e4:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   106e6:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTSET = set_mask;
   106e8:	6099      	str	r1, [r3, #8]
}
   106ea:	4770      	bx	lr

000106ec <gpio_nrfx_port_clear_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   106ec:	6843      	ldr	r3, [r0, #4]
}
   106ee:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   106f0:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTCLR = clr_mask;
   106f2:	60d9      	str	r1, [r3, #12]
}
   106f4:	4770      	bx	lr

000106f6 <gpio_nrfx_port_toggle_bits>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   106f6:	6843      	ldr	r3, [r0, #4]
}
   106f8:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
   106fa:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
   106fc:	6853      	ldr	r3, [r2, #4]
	nrf_gpio_port_out_write(reg, value ^ mask);
   106fe:	404b      	eors	r3, r1
    p_reg->OUT = value;
   10700:	6053      	str	r3, [r2, #4]
}
   10702:	4770      	bx	lr

00010704 <gpio_nrfx_manage_callback>:
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   10704:	68c3      	ldr	r3, [r0, #12]
{
   10706:	b530      	push	{r4, r5, lr}
Z_GENLIST_IS_EMPTY(slist)
   10708:	6858      	ldr	r0, [r3, #4]
	if (!sys_slist_is_empty(callbacks)) {
   1070a:	b158      	cbz	r0, 10724 <gpio_nrfx_manage_callback+0x20>
 * @return true if node was removed
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1070c:	2400      	movs	r4, #0
   1070e:	4281      	cmp	r1, r0
   10710:	d113      	bne.n	1073a <gpio_nrfx_manage_callback+0x36>
Z_GENLIST_REMOVE(slist, snode)
   10712:	6808      	ldr	r0, [r1, #0]
   10714:	b95c      	cbnz	r4, 1072e <gpio_nrfx_manage_callback+0x2a>
   10716:	689c      	ldr	r4, [r3, #8]
	list->head = node;
   10718:	6058      	str	r0, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
   1071a:	42a1      	cmp	r1, r4
   1071c:	d100      	bne.n	10720 <gpio_nrfx_manage_callback+0x1c>
	list->tail = node;
   1071e:	6098      	str	r0, [r3, #8]
	parent->next = child;
   10720:	2000      	movs	r0, #0
   10722:	6008      	str	r0, [r1, #0]
	if (set) {
   10724:	b972      	cbnz	r2, 10744 <gpio_nrfx_manage_callback+0x40>
	return 0;
   10726:	2000      	movs	r0, #0
}
   10728:	bd30      	pop	{r4, r5, pc}
   1072a:	4628      	mov	r0, r5
   1072c:	e7ef      	b.n	1070e <gpio_nrfx_manage_callback+0xa>
   1072e:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
   10730:	6898      	ldr	r0, [r3, #8]
   10732:	4281      	cmp	r1, r0
	list->tail = node;
   10734:	bf08      	it	eq
   10736:	609c      	streq	r4, [r3, #8]
}
   10738:	e7f2      	b.n	10720 <gpio_nrfx_manage_callback+0x1c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
   1073a:	6805      	ldr	r5, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
   1073c:	4604      	mov	r4, r0
   1073e:	2d00      	cmp	r5, #0
   10740:	d1f3      	bne.n	1072a <gpio_nrfx_manage_callback+0x26>
			if (!set) {
   10742:	b13a      	cbz	r2, 10754 <gpio_nrfx_manage_callback+0x50>
Z_GENLIST_PREPEND(slist, snode)
   10744:	685a      	ldr	r2, [r3, #4]
	parent->next = child;
   10746:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
   10748:	6898      	ldr	r0, [r3, #8]
	list->head = node;
   1074a:	6059      	str	r1, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
   1074c:	2800      	cmp	r0, #0
   1074e:	d1ea      	bne.n	10726 <gpio_nrfx_manage_callback+0x22>
	list->tail = node;
   10750:	6099      	str	r1, [r3, #8]
}
   10752:	e7e9      	b.n	10728 <gpio_nrfx_manage_callback+0x24>
				return -EINVAL;
   10754:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&get_port_data(port)->callbacks,
   10758:	e7e6      	b.n	10728 <gpio_nrfx_manage_callback+0x24>

0001075a <check_level_trigger_pins>:
{
   1075a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint32_t bit = 1U << pin;
   1075e:	2601      	movs	r6, #1
	uint32_t pin = 0U;
   10760:	2700      	movs	r7, #0
	struct gpio_nrfx_data *data = get_port_data(port);
   10762:	68c3      	ldr	r3, [r0, #12]
	const struct gpio_nrfx_cfg *cfg = get_port_cfg(port);
   10764:	f8d0 8004 	ldr.w	r8, [r0, #4]
	uint32_t out = data->pin_int_en;
   10768:	68dc      	ldr	r4, [r3, #12]
	out &= ~data->trig_edge & ~data->double_edge;
   1076a:	e9d3 2105 	ldrd	r2, r1, [r3, #20]
   1076e:	430a      	orrs	r2, r1
   10770:	ea24 0402 	bic.w	r4, r4, r2
	uint32_t port_in = nrf_gpio_port_in_read(cfg->port);
   10774:	f8d8 2004 	ldr.w	r2, [r8, #4]
	uint32_t pin_states = ~(port_in ^ data->int_active_level);
   10778:	691b      	ldr	r3, [r3, #16]
    return p_reg->IN;
   1077a:	6915      	ldr	r5, [r2, #16]
   1077c:	405d      	eors	r5, r3
	uint32_t out = pin_states & level_pins;
   1077e:	ea24 0505 	bic.w	r5, r4, r5
	while (level_pins) {
   10782:	b914      	cbnz	r4, 1078a <check_level_trigger_pins+0x30>
}
   10784:	4628      	mov	r0, r5
   10786:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (level_pins & bit) {
   1078a:	4234      	tst	r4, r6
   1078c:	d00a      	beq.n	107a4 <check_level_trigger_pins+0x4a>
			uint32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   1078e:	f898 3008 	ldrb.w	r3, [r8, #8]
   10792:	f007 001f 	and.w	r0, r7, #31
			nrf_gpio_cfg_sense_set(abs_pin, NRF_GPIO_PIN_NOSENSE);
   10796:	2100      	movs	r1, #0
   10798:	ea40 1043 	orr.w	r0, r0, r3, lsl #5
   1079c:	f7fd fcd8 	bl	e150 <nrf_gpio_cfg_sense_set>
			level_pins &= ~bit;
   107a0:	ea24 0406 	bic.w	r4, r4, r6
		++pin;
   107a4:	3701      	adds	r7, #1
		bit <<= 1;
   107a6:	0076      	lsls	r6, r6, #1
   107a8:	e7eb      	b.n	10782 <check_level_trigger_pins+0x28>

000107aa <cfg_level_pins>:
{
   107aa:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint32_t bit = 1U << pin;
   107ae:	2601      	movs	r6, #1
	uint32_t pin = 0U;
   107b0:	2500      	movs	r5, #0
	const struct gpio_nrfx_data *data = get_port_data(port);
   107b2:	68c7      	ldr	r7, [r0, #12]
	const struct gpio_nrfx_cfg *cfg = get_port_cfg(port);
   107b4:	f8d0 8004 	ldr.w	r8, [r0, #4]
	uint32_t out = data->pin_int_en;
   107b8:	68fc      	ldr	r4, [r7, #12]
	out &= ~data->trig_edge & ~data->double_edge;
   107ba:	e9d7 3205 	ldrd	r3, r2, [r7, #20]
   107be:	4313      	orrs	r3, r2
   107c0:	ea24 0403 	bic.w	r4, r4, r3
	while (level_pins) {
   107c4:	b90c      	cbnz	r4, 107ca <cfg_level_pins+0x20>
}
   107c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (level_pins & bit) {
   107ca:	4226      	tst	r6, r4
   107cc:	d010      	beq.n	107f0 <cfg_level_pins+0x46>
	if ((BIT(pin) & data->int_active_level) != 0U) {
   107ce:	6939      	ldr	r1, [r7, #16]
			uint32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   107d0:	f898 3008 	ldrb.w	r3, [r8, #8]
	if ((BIT(pin) & data->int_active_level) != 0U) {
   107d4:	40e9      	lsrs	r1, r5
   107d6:	f001 0101 	and.w	r1, r1, #1
   107da:	f1c1 0103 	rsb	r1, r1, #3
			uint32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
   107de:	f005 001f 	and.w	r0, r5, #31
			nrf_gpio_cfg_sense_set(abs_pin, sense);
   107e2:	b2c9      	uxtb	r1, r1
   107e4:	ea40 1043 	orr.w	r0, r0, r3, lsl #5
   107e8:	f7fd fcb2 	bl	e150 <nrf_gpio_cfg_sense_set>
			level_pins &= ~bit;
   107ec:	ea24 0406 	bic.w	r4, r4, r6
		++pin;
   107f0:	3501      	adds	r5, #1
		bit <<= 1;
   107f2:	0076      	lsls	r6, r6, #1
   107f4:	e7e6      	b.n	107c4 <cfg_level_pins+0x1a>

000107f6 <uarte_nrfx_isr_int>:
	return config->uarte_regs;
   107f6:	6843      	ldr	r3, [r0, #4]
   107f8:	681b      	ldr	r3, [r3, #0]
    return p_reg->INTENSET & mask;
   107fa:	f8d3 2304 	ldr.w	r2, [r3, #772]	; 0x304
	if (nrf_uarte_int_enable_check(uarte, NRF_UARTE_INT_ENDTX_MASK) &&
   107fe:	05d2      	lsls	r2, r2, #23
   10800:	d518      	bpl.n	10834 <uarte_nrfx_isr_int+0x3e>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   10802:	f8d3 2120 	ldr.w	r2, [r3, #288]	; 0x120
   10806:	b1aa      	cbz	r2, 10834 <uarte_nrfx_isr_int+0x3e>
	__asm__ volatile(
   10808:	f04f 0120 	mov.w	r1, #32
   1080c:	f3ef 8211 	mrs	r2, BASEPRI
   10810:	f381 8811 	msr	BASEPRI, r1
   10814:	f3bf 8f6f 	isb	sy
   10818:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
	if (nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX)) {
   1081c:	b131      	cbz	r1, 1082c <uarte_nrfx_isr_int+0x36>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1081e:	2100      	movs	r1, #0
   10820:	f8c3 1120 	str.w	r1, [r3, #288]	; 0x120
   10824:	f8d3 1120 	ldr.w	r1, [r3, #288]	; 0x120
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   10828:	2101      	movs	r1, #1
   1082a:	60d9      	str	r1, [r3, #12]
	__asm__ volatile(
   1082c:	f382 8811 	msr	BASEPRI, r2
   10830:	f3bf 8f6f 	isb	sy
}
   10834:	4770      	bx	lr

00010836 <uarte_nrfx_config_get>:
{
   10836:	460b      	mov	r3, r1
	*cfg = get_dev_data(dev)->uart_config;
   10838:	68c2      	ldr	r2, [r0, #12]
   1083a:	e9d2 0101 	ldrd	r0, r1, [r2, #4]
   1083e:	e883 0003 	stmia.w	r3, {r0, r1}
}
   10842:	2000      	movs	r0, #0
   10844:	4770      	bx	lr

00010846 <uarte_nrfx_err_check>:
	return config->uarte_regs;
   10846:	6843      	ldr	r3, [r0, #4]
   10848:	681b      	ldr	r3, [r3, #0]
    uint32_t errsrc_mask = p_reg->ERRORSRC;
   1084a:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
   1084e:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
}
   10852:	4770      	bx	lr

00010854 <is_tx_ready>:
	const struct uarte_nrfx_config *config = get_dev_config(dev);
   10854:	6842      	ldr	r2, [r0, #4]
	return config->uarte_regs;
   10856:	6813      	ldr	r3, [r2, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
   10858:	f8d3 0158 	ldr.w	r0, [r3, #344]	; 0x158
	return nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_TXSTOPPED) ||
   1085c:	b938      	cbnz	r0, 1086e <is_tx_ready+0x1a>
   1085e:	7992      	ldrb	r2, [r2, #6]
   10860:	b932      	cbnz	r2, 10870 <is_tx_ready+0x1c>
   10862:	f8d3 0120 	ldr.w	r0, [r3, #288]	; 0x120
   10866:	3800      	subs	r0, #0
   10868:	bf18      	it	ne
   1086a:	2001      	movne	r0, #1
   1086c:	4770      	bx	lr
   1086e:	2001      	movs	r0, #1
}
   10870:	4770      	bx	lr

00010872 <uarte_nrfx_poll_in>:
	return config->uarte_regs;
   10872:	6843      	ldr	r3, [r0, #4]
	const struct uarte_nrfx_data *data = get_dev_data(dev);
   10874:	68c2      	ldr	r2, [r0, #12]
	return config->uarte_regs;
   10876:	681b      	ldr	r3, [r3, #0]
   10878:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
   1087c:	b148      	cbz	r0, 10892 <uarte_nrfx_poll_in+0x20>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
   1087e:	2000      	movs	r0, #0
	*c = data->rx_data;
   10880:	7c52      	ldrb	r2, [r2, #17]
   10882:	700a      	strb	r2, [r1, #0]
   10884:	f8c3 0110 	str.w	r0, [r3, #272]	; 0x110
   10888:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
   1088c:	2201      	movs	r2, #1
   1088e:	601a      	str	r2, [r3, #0]
	return 0;
   10890:	4770      	bx	lr
		return -1;
   10892:	f04f 30ff 	mov.w	r0, #4294967295
}
   10896:	4770      	bx	lr

00010898 <k_sys_fatal_error_handler>:
	ARG_UNUSED(reason);

	LOG_PANIC();

	LOG_ERR("Resetting system");
	sys_arch_reboot(0);
   10898:	2000      	movs	r0, #0
{
   1089a:	b508      	push	{r3, lr}
	sys_arch_reboot(0);
   1089c:	f7fd f9fa 	bl	dc94 <sys_arch_reboot>

000108a0 <hw_cc3xx_init>:
#include <nrf_cc3xx_platform.h>

#if CONFIG_HW_CC3XX

static int hw_cc3xx_init(const struct device *dev)
{
   108a0:	b508      	push	{r3, lr}
	int res;

	__ASSERT_NO_MSG(dev != NULL);

	/* Set the RTOS abort APIs */
	nrf_cc3xx_platform_abort_init();
   108a2:	f7fc fedb 	bl	d65c <nrf_cc3xx_platform_abort_init>

	/* Set the RTOS mutex APIs */
	nrf_cc3xx_platform_mutex_init();
   108a6:	f7fc ff9f 	bl	d7e8 <nrf_cc3xx_platform_mutex_init>
	res = nrf_cc3xx_platform_init();
#else
	res = nrf_cc3xx_platform_init_no_rng();
#endif
	return res;
}
   108aa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	res = nrf_cc3xx_platform_init_no_rng();
   108ae:	f7ff ba33 	b.w	fd18 <nrf_cc3xx_platform_init_no_rng>

000108b2 <nrfx_isr>:
#include <nrfx.h>
#include <kernel.h>

void nrfx_isr(const void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
   108b2:	4700      	bx	r0

000108b4 <nrfx_busy_wait>:
	z_impl_k_busy_wait(usec_to_wait);
   108b4:	f000 b901 	b.w	10aba <z_impl_k_busy_wait>

000108b8 <nrfx_clock_enable>:
{
   108b8:	b508      	push	{r3, lr}
    priority = NRFX_CLOCK_DEFAULT_CONFIG_IRQ_PRIORITY;
#else
    #error "This code is not supposed to be compiled when neither POWER nor CLOCK is enabled."
#endif

    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
   108ba:	2005      	movs	r0, #5
   108bc:	f7fd f810 	bl	d8e0 <arch_irq_is_enabled>
   108c0:	b910      	cbnz	r0, 108c8 <nrfx_clock_enable+0x10>
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_CLOCK), priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
   108c2:	2005      	movs	r0, #5
   108c4:	f7fc fffc 	bl	d8c0 <arch_irq_enable>
}

#if NRF_CLOCK_HAS_HFCLKSRC
NRF_STATIC_INLINE void nrf_clock_hf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_hfclk_t source)
{
    p_reg->HFCLKSRC = (uint32_t)(source);
   108c8:	f04f 2350 	mov.w	r3, #1342197760	; 0x50005000
   108cc:	2201      	movs	r2, #1
   108ce:	f8c3 2514 	str.w	r2, [r3, #1300]	; 0x514
                                   >> CLOCK_HFCLK192MCTRL_HCLK192M_Pos);
}

NRF_STATIC_INLINE void nrf_clock_hfclk192m_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_hfclk_t source)
{
    p_reg->HFCLK192MSRC = (uint32_t)(source);
   108d2:	f8c3 2580 	str.w	r2, [r3, #1408]	; 0x580
}
   108d6:	bd08      	pop	{r3, pc}

000108d8 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
   108d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   108da:	4605      	mov	r5, r0
   108dc:	460e      	mov	r6, r1
	__asm__ volatile(
   108de:	f04f 0320 	mov.w	r3, #32
   108e2:	f3ef 8711 	mrs	r7, BASEPRI
   108e6:	f383 8811 	msr	BASEPRI, r3
   108ea:	f3bf 8f6f 	isb	sy
	return z_impl_k_current_get();
   108ee:	f7fe ff87 	bl	f800 <z_impl_k_current_get>
	LOG_ERR("Current thread: %p (%s)", thread,
		log_strdup(thread_name_get(thread)));

	z_coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
   108f2:	4631      	mov	r1, r6
   108f4:	4604      	mov	r4, r0
   108f6:	4628      	mov	r0, r5
   108f8:	f7ff ffce 	bl	10898 <k_sys_fatal_error_handler>
	__asm__ volatile(
   108fc:	f387 8811 	msr	BASEPRI, r7
   10900:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
   10904:	4620      	mov	r0, r4
#endif /*CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION */
	}

	arch_irq_unlock(key);
	k_thread_abort(thread);
}
   10906:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
   1090a:	f7fd ba17 	b.w	dd3c <z_impl_k_thread_abort>

0001090e <z_pm_save_idle_exit>:
	z_clock_idle_exit();
   1090e:	f7ff be14 	b.w	1053a <z_clock_idle_exit>

00010912 <k_mem_slab_init>:
{
   10912:	b530      	push	{r4, r5, lr}
	slab->num_used = 0U;
   10914:	2400      	movs	r4, #0
   10916:	6184      	str	r4, [r0, #24]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   10918:	ea41 0402 	orr.w	r4, r1, r2
   1091c:	f014 0403 	ands.w	r4, r4, #3
	slab->block_size = block_size;
   10920:	e9c0 3202 	strd	r3, r2, [r0, #8]
	slab->buffer = buffer;
   10924:	6101      	str	r1, [r0, #16]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
   10926:	d10c      	bne.n	10942 <k_mem_slab_init+0x30>
	slab->free_list = NULL;
   10928:	6144      	str	r4, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   1092a:	42a3      	cmp	r3, r4
   1092c:	d103      	bne.n	10936 <k_mem_slab_init+0x24>
	list->tail = (sys_dnode_t *)list;
   1092e:	e9c0 0000 	strd	r0, r0, [r0]
}
   10932:	2000      	movs	r0, #0
}
   10934:	bd30      	pop	{r4, r5, pc}
		*(char **)p = slab->free_list;
   10936:	6945      	ldr	r5, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
   10938:	3401      	adds	r4, #1
		*(char **)p = slab->free_list;
   1093a:	600d      	str	r5, [r1, #0]
		slab->free_list = p;
   1093c:	6141      	str	r1, [r0, #20]
		p += slab->block_size;
   1093e:	4411      	add	r1, r2
	for (j = 0U; j < slab->num_blocks; j++) {
   10940:	e7f3      	b.n	1092a <k_mem_slab_init+0x18>
		return -EINVAL;
   10942:	f06f 0015 	mvn.w	r0, #21
	return rc;
   10946:	e7f5      	b.n	10934 <k_mem_slab_init+0x22>

00010948 <z_impl_k_mutex_init>:
{
   10948:	4603      	mov	r3, r0
	mutex->owner = NULL;
   1094a:	2000      	movs	r0, #0
   1094c:	e9c3 3300 	strd	r3, r3, [r3]
	mutex->lock_count = 0U;
   10950:	e9c3 0002 	strd	r0, r0, [r3, #8]
}
   10954:	4770      	bx	lr

00010956 <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
   10956:	4603      	mov	r3, r0
   10958:	b920      	cbnz	r0, 10964 <z_reschedule_irqlock+0xe>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
   1095a:	f3ef 8205 	mrs	r2, IPSR
   1095e:	b90a      	cbnz	r2, 10964 <z_reschedule_irqlock+0xe>
   10960:	f7fc bf58 	b.w	d814 <arch_swap>
   10964:	f383 8811 	msr	BASEPRI, r3
   10968:	f3bf 8f6f 	isb	sy
}
   1096c:	4770      	bx	lr

0001096e <z_reschedule_unlocked>:
	__asm__ volatile(
   1096e:	f04f 0320 	mov.w	r3, #32
   10972:	f3ef 8011 	mrs	r0, BASEPRI
   10976:	f383 8811 	msr	BASEPRI, r3
   1097a:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
   1097e:	f7ff bfea 	b.w	10956 <z_reschedule_irqlock>

00010982 <unpend_thread_no_timeout>:
{
   10982:	4601      	mov	r1, r0
   10984:	b508      	push	{r3, lr}
	_priq_wait_remove(&pended_on(thread)->waitq, thread);
   10986:	6880      	ldr	r0, [r0, #8]
   10988:	f7fe fc0a 	bl	f1a0 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
   1098c:	7b4b      	ldrb	r3, [r1, #13]
   1098e:	f023 0302 	bic.w	r3, r3, #2
   10992:	734b      	strb	r3, [r1, #13]
	thread->base.pended_on = NULL;
   10994:	2300      	movs	r3, #0
   10996:	608b      	str	r3, [r1, #8]
}
   10998:	bd08      	pop	{r3, pc}

0001099a <z_priq_dumb_best>:
{
   1099a:	4603      	mov	r3, r0
	return list->head == list;
   1099c:	6800      	ldr	r0, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   1099e:	4283      	cmp	r3, r0
   109a0:	d003      	beq.n	109aa <z_priq_dumb_best+0x10>
	if (n != NULL) {
   109a2:	2800      	cmp	r0, #0
   109a4:	bf38      	it	cc
   109a6:	2000      	movcc	r0, #0
   109a8:	4770      	bx	lr
	struct k_thread *thread = NULL;
   109aa:	2000      	movs	r0, #0
}
   109ac:	4770      	bx	lr

000109ae <z_ready_thread>:
{
   109ae:	b510      	push	{r4, lr}
   109b0:	f04f 0320 	mov.w	r3, #32
   109b4:	f3ef 8411 	mrs	r4, BASEPRI
   109b8:	f383 8811 	msr	BASEPRI, r3
   109bc:	f3bf 8f6f 	isb	sy
		ready_thread(thread);
   109c0:	f7fe fc48 	bl	f254 <ready_thread>
	__asm__ volatile(
   109c4:	f384 8811 	msr	BASEPRI, r4
   109c8:	f3bf 8f6f 	isb	sy
}
   109cc:	bd10      	pop	{r4, pc}

000109ce <z_thread_timeout>:
{
   109ce:	b570      	push	{r4, r5, r6, lr}
   109d0:	4604      	mov	r4, r0
	__asm__ volatile(
   109d2:	f04f 0320 	mov.w	r3, #32
   109d6:	f3ef 8611 	mrs	r6, BASEPRI
   109da:	f383 8811 	msr	BASEPRI, r3
   109de:	f3bf 8f6f 	isb	sy
		if (thread->base.pended_on != NULL) {
   109e2:	f850 3c10 	ldr.w	r3, [r0, #-16]
		struct k_thread *thread = CONTAINER_OF(timeout,
   109e6:	f1a0 0518 	sub.w	r5, r0, #24
		if (thread->base.pended_on != NULL) {
   109ea:	b113      	cbz	r3, 109f2 <z_thread_timeout+0x24>
			unpend_thread_no_timeout(thread);
   109ec:	4628      	mov	r0, r5
   109ee:	f7ff ffc8 	bl	10982 <unpend_thread_no_timeout>
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
   109f2:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
		ready_thread(thread);
   109f6:	4628      	mov	r0, r5
   109f8:	f023 0314 	bic.w	r3, r3, #20
   109fc:	f804 3c0b 	strb.w	r3, [r4, #-11]
   10a00:	f7fe fc28 	bl	f254 <ready_thread>
	__asm__ volatile(
   10a04:	f386 8811 	msr	BASEPRI, r6
   10a08:	f3bf 8f6f 	isb	sy
}
   10a0c:	bd70      	pop	{r4, r5, r6, pc}

00010a0e <add_to_waitq_locked>:
{
   10a0e:	b538      	push	{r3, r4, r5, lr}
   10a10:	4604      	mov	r4, r0
   10a12:	460d      	mov	r5, r1
	unready_thread(thread);
   10a14:	f7fe fda6 	bl	f564 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
   10a18:	7b63      	ldrb	r3, [r4, #13]
   10a1a:	f043 0302 	orr.w	r3, r3, #2
   10a1e:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
   10a20:	b1c5      	cbz	r5, 10a54 <add_to_waitq_locked+0x46>
	return list->head == list;
   10a22:	682b      	ldr	r3, [r5, #0]
		thread->base.pended_on = wait_q;
   10a24:	60a5      	str	r5, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
   10a26:	429d      	cmp	r5, r3
   10a28:	bf08      	it	eq
   10a2a:	2300      	moveq	r3, #0
   10a2c:	2b00      	cmp	r3, #0
   10a2e:	bf38      	it	cc
   10a30:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
   10a32:	b183      	cbz	r3, 10a56 <add_to_waitq_locked+0x48>
	if (thread_1->base.prio < thread_2->base.prio) {
   10a34:	f994 100e 	ldrsb.w	r1, [r4, #14]
   10a38:	f993 200e 	ldrsb.w	r2, [r3, #14]
   10a3c:	4291      	cmp	r1, r2
   10a3e:	db04      	blt.n	10a4a <add_to_waitq_locked+0x3c>
	return (node == list->tail) ? NULL : node->next;
   10a40:	686a      	ldr	r2, [r5, #4]
   10a42:	429a      	cmp	r2, r3
   10a44:	d007      	beq.n	10a56 <add_to_waitq_locked+0x48>
   10a46:	681b      	ldr	r3, [r3, #0]
   10a48:	e7f3      	b.n	10a32 <add_to_waitq_locked+0x24>
	node->prev = successor->prev;
   10a4a:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
   10a4c:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
   10a50:	6014      	str	r4, [r2, #0]
	successor->prev = node;
   10a52:	605c      	str	r4, [r3, #4]
}
   10a54:	bd38      	pop	{r3, r4, r5, pc}
	node->prev = list->tail;
   10a56:	686b      	ldr	r3, [r5, #4]
	node->next = list;
   10a58:	6025      	str	r5, [r4, #0]
	node->prev = list->tail;
   10a5a:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
   10a5c:	686b      	ldr	r3, [r5, #4]
   10a5e:	601c      	str	r4, [r3, #0]
	list->tail = node;
   10a60:	606c      	str	r4, [r5, #4]
   10a62:	e7f7      	b.n	10a54 <add_to_waitq_locked+0x46>

00010a64 <z_unpend_first_thread>:
{
   10a64:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
   10a66:	f04f 0320 	mov.w	r3, #32
   10a6a:	f3ef 8211 	mrs	r2, BASEPRI
   10a6e:	f383 8811 	msr	BASEPRI, r3
   10a72:	f3bf 8f6f 	isb	sy
		ret = _priq_wait_best(&wait_q->waitq);
   10a76:	f7ff ff90 	bl	1099a <z_priq_dumb_best>
   10a7a:	4604      	mov	r4, r0
	__asm__ volatile(
   10a7c:	f382 8811 	msr	BASEPRI, r2
   10a80:	f3bf 8f6f 	isb	sy

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
   10a84:	b188      	cbz	r0, 10aaa <z_unpend_first_thread+0x46>
	__asm__ volatile(
   10a86:	f04f 0320 	mov.w	r3, #32
   10a8a:	f3ef 8511 	mrs	r5, BASEPRI
   10a8e:	f383 8811 	msr	BASEPRI, r3
   10a92:	f3bf 8f6f 	isb	sy
		unpend_thread_no_timeout(thread);
   10a96:	f7ff ff74 	bl	10982 <unpend_thread_no_timeout>
	__asm__ volatile(
   10a9a:	f385 8811 	msr	BASEPRI, r5
   10a9e:	f3bf 8f6f 	isb	sy
	return z_abort_timeout(&thread->base.timeout);
   10aa2:	f104 0018 	add.w	r0, r4, #24
   10aa6:	f000 f80c 	bl	10ac2 <z_abort_timeout>
}
   10aaa:	4620      	mov	r0, r4
   10aac:	bd38      	pop	{r3, r4, r5, pc}

00010aae <k_is_in_isr>:
   10aae:	f3ef 8005 	mrs	r0, IPSR
}
   10ab2:	3800      	subs	r0, #0
   10ab4:	bf18      	it	ne
   10ab6:	2001      	movne	r0, #1
   10ab8:	4770      	bx	lr

00010aba <z_impl_k_busy_wait>:
	if (usec_to_wait == 0) {
   10aba:	b108      	cbz	r0, 10ac0 <z_impl_k_busy_wait+0x6>
	arch_busy_wait(usec_to_wait);
   10abc:	f7fc baea 	b.w	d094 <arch_busy_wait>
}
   10ac0:	4770      	bx	lr

00010ac2 <z_abort_timeout>:
{
   10ac2:	b510      	push	{r4, lr}
	__asm__ volatile(
   10ac4:	f04f 0220 	mov.w	r2, #32
   10ac8:	f3ef 8411 	mrs	r4, BASEPRI
   10acc:	f382 8811 	msr	BASEPRI, r2
   10ad0:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
   10ad4:	6803      	ldr	r3, [r0, #0]
   10ad6:	b13b      	cbz	r3, 10ae8 <z_abort_timeout+0x26>
			remove_timeout(to);
   10ad8:	f7fe ffb4 	bl	fa44 <remove_timeout>
			ret = 0;
   10adc:	2000      	movs	r0, #0
	__asm__ volatile(
   10ade:	f384 8811 	msr	BASEPRI, r4
   10ae2:	f3bf 8f6f 	isb	sy
}
   10ae6:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
   10ae8:	f06f 0015 	mvn.w	r0, #21
   10aec:	e7f7      	b.n	10ade <z_abort_timeout+0x1c>

00010aee <z_get_next_timeout_expiry>:
{
   10aee:	b510      	push	{r4, lr}
	__asm__ volatile(
   10af0:	f04f 0320 	mov.w	r3, #32
   10af4:	f3ef 8411 	mrs	r4, BASEPRI
   10af8:	f383 8811 	msr	BASEPRI, r3
   10afc:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
   10b00:	f7fe ffba 	bl	fa78 <next_timeout>
	__asm__ volatile(
   10b04:	f384 8811 	msr	BASEPRI, r4
   10b08:	f3bf 8f6f 	isb	sy
}
   10b0c:	bd10      	pop	{r4, pc}

00010b0e <z_set_timeout_expiry>:
{
   10b0e:	b570      	push	{r4, r5, r6, lr}
   10b10:	4604      	mov	r4, r0
   10b12:	460d      	mov	r5, r1
	__asm__ volatile(
   10b14:	f04f 0320 	mov.w	r3, #32
   10b18:	f3ef 8611 	mrs	r6, BASEPRI
   10b1c:	f383 8811 	msr	BASEPRI, r3
   10b20:	f3bf 8f6f 	isb	sy
		int next_to = next_timeout();
   10b24:	f7fe ffa8 	bl	fa78 <next_timeout>
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
   10b28:	2801      	cmp	r0, #1
   10b2a:	dd05      	ble.n	10b38 <z_set_timeout_expiry+0x2a>
   10b2c:	42a0      	cmp	r0, r4
   10b2e:	dd03      	ble.n	10b38 <z_set_timeout_expiry+0x2a>
			z_clock_set_timeout(ticks, is_idle);
   10b30:	4629      	mov	r1, r5
   10b32:	4620      	mov	r0, r4
   10b34:	f7fc fd46 	bl	d5c4 <z_clock_set_timeout>
	__asm__ volatile(
   10b38:	f386 8811 	msr	BASEPRI, r6
   10b3c:	f3bf 8f6f 	isb	sy
}
   10b40:	bd70      	pop	{r4, r5, r6, pc}

00010b42 <z_tick_get_32>:

uint32_t z_tick_get_32(void)
{
   10b42:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (uint32_t)z_tick_get();
   10b44:	f7ff f8bc 	bl	fcc0 <z_tick_get>
#else
	return (uint32_t)curr_tick;
#endif
}
   10b48:	bd08      	pop	{r3, pc}

00010b4a <k_heap_init>:
{
   10b4a:	b410      	push	{r4}
	sys_dlist_init(&w->waitq);
   10b4c:	f100 040c 	add.w	r4, r0, #12
	list->tail = (sys_dnode_t *)list;
   10b50:	e9c0 4403 	strd	r4, r4, [r0, #12]
}
   10b54:	bc10      	pop	{r4}
	sys_heap_init(&h->heap, mem, bytes);
   10b56:	f7ff bb99 	b.w	1028c <sys_heap_init>

00010b5a <_OffsetAbsSyms>:
#include "offsets_aarch64.c"
#else
#include "offsets_aarch32.c"
#endif

GEN_ABS_SYM_END
   10b5a:	4770      	bx	lr
